diff --git a/.gitignore b/.gitignore
index 11558a2..b729340 100644
--- a/.gitignore
+++ b/.gitignore
@@ -41,3 +41,10 @@ simulatorDataSets/
 
 **/**/build/
 slamMaps/
+.vs
+.vscode
+vcpkg_installed/
+out/
+videos/
+**/bin**
+**/Debug**
\ No newline at end of file
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 83772de..0ba0e48 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,79 +1,42 @@
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 3.0)
 project(ORB_SLAM2)
-find_package(nlohmann_json 3.2.0 REQUIRED)
+set(CMAKE_CXX_STANDARD 17)
 IF (NOT CMAKE_BUILD_TYPE)
-    SET(CMAKE_BUILD_TYPE Release)
+    SET(CMAKE_BUILD_TYPE Debug)
 ENDIF ()
-
 MESSAGE("Build type: " ${CMAKE_BUILD_TYPE})
-set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}  -Wall  -O3 -lncurses")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall   -O3 -lboost_serialization -lncurses")
-#set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS}  -Wall  -O3 -march=native")
-#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS} -Wall   -O3 -lboost_serialization -march=native")
-
-# Check C++17 or C++0x support
-include(CheckCXXCompilerFlag)
-CHECK_CXX_COMPILER_FLAG("-std=c++17" COMPILER_SUPPORTS_CXX17)
-CHECK_CXX_COMPILER_FLAG("-std=c++0x" COMPILER_SUPPORTS_CXX0X)
-if (COMPILER_SUPPORTS_CXX17)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17")
-    add_definitions(-DCOMPILEDWITHC17)
-    message(STATUS "Using flag -std=c++17.")
-elseif (COMPILER_SUPPORTS_CXX0X)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
-    add_definitions(-DCOMPILEDWITHC0X)
-    message(STATUS "Using flag -std=c++0x.")
-else ()
-    message(FATAL_ERROR "The compiler ${CMAKE_CXX_COMPILER} has no C++17 support. Please use a different C++ compiler.")
-endif ()
-
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}  -W0 -MT -bigobj")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -W0 -MT -bigobj")
 LIST(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules)
-
-find_package(OpenCV 3.0 QUIET)
-if (NOT OpenCV_FOUND)
-    find_package(OpenCV 2.4.3 QUIET)
-    if (NOT OpenCV_FOUND)
-        message(FATAL_ERROR "OpenCV > 2.4.3 not found.")
-    endif ()
-endif ()
-
-
-find_package(PkgConfig)
-pkg_search_module(Eigen3 REQUIRED eigen3)
-find_package(Pangolin REQUIRED)
+list(APPEND VCPKG_FEATURE_FLAGS "versions")
+find_package(lz4 CONFIG REQUIRED)
+find_package(PythonLibs REQUIRED)
+find_package(nlohmann_json REQUIRED)
+find_package(Eigen3 REQUIRED)
 find_package(PythonLibs REQUIRED)
 find_package(Threads REQUIRED)
 find_package(Boost REQUIRED COMPONENTS system serialization)
-find_package(PCL 1.8 REQUIRED)
-
+find_package(Pangolin REQUIRED PATHS "${CMAKE_CURRENT_SOURCE_DIR}Thirdparty/Pangolin")
+find_package(OpenCV REQUIRED)
+add_subdirectory(Thirdparty)
 include_directories(
-
-        ${PROJECT_SOURCE_DIR}/Thirdparty/g2o/
-        ${PROJECT_SOURCE_DIR}/Thirdparty/DBoW2/
-        ${PROJECT_SOURCE_DIR}/Thirdparty/Pangolin/
-        ${PROJECT_SOURCE_DIR}/Thirdparty/eigen-3.1.3/
-        ${PROJECT_SOURCE_DIR}/utils
-        ${PROJECT_SOURCE_DIR}/slam/include
-        ${EIGEN3_INCLUDE_DIR}
+            ${EIGEN3_INCLUDE_DIR}        
         ${Pangolin_INCLUDE_DIRS}
         ${PYTHON_INCLUDE_DIRS}
         ${Boost_INCLUDE_DIRS}
-        ${PCL_INCLUDE_DIRS}
+        ${PROJECT_SOURCE_DIR}/Thirdparty/g2o/
+        ${PROJECT_SOURCE_DIR}/Thirdparty/DBoW2/
+        ${PROJECT_SOURCE_DIR}/utils
+        ${PROJECT_SOURCE_DIR}/slam/include/
         ${PROJECT_SOURCE_DIR}/tools
 )
 
-# Add definitions
-add_definitions(${PCL_DEFINITIONS})
-
-set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/lib)
-
-add_library(${PROJECT_NAME}
+add_library(${PROJECT_NAME} STATIC
         slam/src/System.cc
         slam/src/Tracking.cc
         slam/src/LocalMapping.cc
         slam/src/ORBextractor.cc
         slam/src/ORBmatcher.cc
-        slam/src/RaspberryKeyFrame.cc
         slam/src/FrameDrawer.cc
         slam/src/Sim3Solver.cc
         slam/src/Converter.cc
@@ -95,118 +58,15 @@ add_library(${PROJECT_NAME}
         )
 
 
-target_link_libraries(${PROJECT_NAME}
+target_link_libraries(${PROJECT_NAME} PUBLIC
         ${OpenCV_LIBS}
         ${EIGEN3_LIBS}
-        ${Boost_LIBRARIES}
+        lz4::lz4
         ${Pangolin_LIBRARIES}
-        ${PROJECT_SOURCE_DIR}/Thirdparty/DBoW2/lib/libDBoW2.so
-        ${PROJECT_SOURCE_DIR}/Thirdparty/g2o/lib/libg2o.so
-        ${PCL_LIBRARIES}
-        -lpthread ctello spdlog ${PYTHON_LIBRARIES} -lbluetooth
-	    -lboost_serialization
-	    -lboost_system
+        g2o
+        DBoW2
+        Threads::Threads Boost::boost Boost::serialization Boost::system ${PYTHON_LIBRARIES} nlohmann_json::nlohmann_json
         )
 add_library(simulator tools/simulator.cpp)
 target_link_libraries(simulator ${PROJECT_NAME})
-add_executable(runSimulator exe/runSimulator.cpp)
-target_link_libraries(runSimulator simulator)
-
-add_executable(offline_orb_slam exe/offline_orb_slam.cc)
-target_link_libraries(offline_orb_slam ${PROJECT_NAME})
-
-add_executable(get_point_data exe/get_point_data.cc)
-target_link_libraries(get_point_data ${PROJECT_NAME})
-
-add_executable(unused_get_points_from_camera exe/unused/get_points_from_camera.cc)
-target_link_libraries(unused_get_points_from_camera ${PROJECT_NAME})
-
-add_executable(unused_test_is_point_visible exe/unused/test_is_point_visible.cc)
-target_link_libraries(unused_test_is_point_visible ${PROJECT_NAME})
-
-add_executable(unused_get_points_from_camera_second exe/unused/get_points_from_camera_second.cc)
-target_link_libraries(unused_get_points_from_camera_second ${PROJECT_NAME})
-
-add_executable(unused_points_seen_by_camera_by_frame exe/unused/points_seen_by_camera_by_frame.cc)
-target_link_libraries(unused_points_seen_by_camera_by_frame ${PROJECT_NAME})
-
-add_executable(unused_points_seen_by_camera_by_frame_second exe/unused/points_seen_by_camera_by_frame_second.cc)
-target_link_libraries(unused_points_seen_by_camera_by_frame_second ${PROJECT_NAME})
-
-add_executable(get_points_from_frame_orb_slam exe/get_points_from_frame_orb_slam.cc)
-target_link_libraries(get_points_from_frame_orb_slam ${PROJECT_NAME})
-
-add_executable(unused_get_points_from_camera_third exe/unused/get_points_from_camera_third.cc)
-target_link_libraries(unused_get_points_from_camera_third ${PROJECT_NAME})
-
-add_executable(unused_points_seen_by_camera_by_frame_third exe/unused/points_seen_by_camera_by_frame_third.cc)
-target_link_libraries(unused_points_seen_by_camera_by_frame_third ${PROJECT_NAME})
-
-add_executable(points_seen_by_frame_data exe/points_seen_by_frame_data.cc)
-target_link_libraries(points_seen_by_frame_data ${PROJECT_NAME})
-
-add_executable(points_seen_by_frames exe/points_seen_by_frames.cc)
-target_link_libraries(points_seen_by_frames ${PROJECT_NAME})
-
-add_executable(points_seen_by_pos exe/points_seen_by_pos.cc)
-target_link_libraries(points_seen_by_pos ${PROJECT_NAME})
-
-add_executable(mapping exe/mapping.cc)
-target_link_libraries(mapping ${PROJECT_NAME})
-
-#add_executable(simulator exe/simulator.cc)
-#target_link_libraries(simulator ${PROJECT_NAME})
-
-add_executable(run_model exe/run_model.cc)
-target_link_libraries(run_model ${PROJECT_NAME})
-
-add_executable(get_pos_from_frame_orb_slam exe/get_pos_from_frame_orb_slam.cc)
-target_link_libraries(get_pos_from_frame_orb_slam ${PROJECT_NAME})
-
-add_executable(check_matches exe/check_matches.cc)
-target_link_libraries(check_matches ${PROJECT_NAME})
-
-add_executable(icp_model_orbs_slam exe/icp_model_orbs_slam.cc)
-target_link_libraries(icp_model_orbs_slam ${PROJECT_NAME})
-
-add_executable(take_frame_images exe/take_frame_images.cc)
-target_link_libraries(take_frame_images ${PROJECT_NAME})
-
-add_executable(run_orb_slam_matching exe/run_orb_slam_matching.cc)
-target_link_libraries(run_orb_slam_matching ${PROJECT_NAME})
-
-add_executable(check_matches_opencv exe/check_matches_opencv.cc)
-target_link_libraries(check_matches_opencv ${PROJECT_NAME})
-
-add_executable(check_matches_one_by_one exe/check_matches_one_by_one.cc)
-target_link_libraries(check_matches_one_by_one ${PROJECT_NAME})
-
-add_executable(run_model_with_printed_orbs exe/run_model_with_printed_orbs.cc)
-target_link_libraries(run_model_with_printed_orbs ${PROJECT_NAME})
-
-add_executable(run_model_with_icp exe/run_model_with_icp.cc)
-target_link_libraries(run_model_with_icp ${PROJECT_NAME})
-
-add_executable(run_model_on_orb_slam exe/run_model_on_orb_slam.cc)
-target_link_libraries(run_model_on_orb_slam ${PROJECT_NAME})
-
-add_executable(see_keypoints exe/see_keypoints.cc)
-target_link_libraries(see_keypoints ${PROJECT_NAME})
-
-add_executable(save_map exe/save_map.cc)
-target_link_libraries(save_map ${PROJECT_NAME})
-
-add_executable(remove_outliers exe/remove_outliers.cc)
-target_link_libraries(remove_outliers ${PROJECT_NAME})
-
-add_executable(run_model_with_orb_slam_points exe/run_model_with_orb_slam_points.cc)
-target_link_libraries(run_model_with_orb_slam_points ${PROJECT_NAME})
-
-add_executable(pcd_to_xyz exe/pcd_to_xyz.cc)
-target_link_libraries(pcd_to_xyz ${PROJECT_NAME})
-
-add_executable(csv_to_xyz exe/csv_to_xyz.cc)
-target_link_libraries(csv_to_xyz ${PROJECT_NAME})
-
-add_executable(run_model_with_orbs_and_orb_slam_map exe/run_model_with_orbs_and_orb_slam_map.cc)
-target_link_libraries(run_model_with_orbs_and_orb_slam_map ${PROJECT_NAME})
+add_subdirectory(exe)
\ No newline at end of file
diff --git a/CMakeSettings.json b/CMakeSettings.json
new file mode 100644
index 0000000..c3ba9b7
--- /dev/null
+++ b/CMakeSettings.json
@@ -0,0 +1,27 @@
+∩╗┐{
+  "configurations": [
+    {
+      "name": "x64-Debug",
+      "generator": "Ninja",
+      "configurationType": "Debug",
+      "inheritEnvironments": [ "msvc_x64_x64" ],
+      "buildRoot": "${projectDir}\\out\\build\\${name}",
+      "installRoot": "${projectDir}\\out\\install\\${name}",
+      "cmakeCommandArgs": "",
+      "buildCommandArgs": "",
+      "ctestCommandArgs": "",
+      "intelliSenseMode": "windows-msvc-x64"
+    },
+    {
+      "name": "x64-Release",
+      "generator": "Ninja",
+      "configurationType": "Release",
+      "buildRoot": "${projectDir}\\out\\build\\${name}",
+      "installRoot": "${projectDir}\\out\\install\\${name}",
+      "cmakeCommandArgs": "",
+      "buildCommandArgs": "",
+      "ctestCommandArgs": "",
+      "inheritEnvironments": [ "msvc_x64_x64" ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/CameraTrajectory.txt b/CameraTrajectory.txt
new file mode 100644
index 0000000..57eda8b
--- /dev/null
+++ b/CameraTrajectory.txt
@@ -0,0 +1 @@
+1.000000000 0.000000000 0.000000000 0.000000000 0.000000000 1.000000000 0.000000000 0.000000000 0.000000000 0.000000000 1.000000000 0.000000000
diff --git a/TLV-data/ceiling.png b/TLV-data/ceiling.png
new file mode 100644
index 0000000..d21893c
Binary files /dev/null and b/TLV-data/ceiling.png differ
diff --git a/TLV-data/ceiling_lamps.png b/TLV-data/ceiling_lamps.png
new file mode 100644
index 0000000..7a29770
Binary files /dev/null and b/TLV-data/ceiling_lamps.png differ
diff --git a/TLV-data/concrete_wall.png b/TLV-data/concrete_wall.png
new file mode 100644
index 0000000..6f6a156
Binary files /dev/null and b/TLV-data/concrete_wall.png differ
diff --git a/TLV-data/drones_lab.fbx b/TLV-data/drones_lab.fbx
new file mode 100644
index 0000000..9c928fb
Binary files /dev/null and b/TLV-data/drones_lab.fbx differ
diff --git a/TLV-data/drones_lab.mtl b/TLV-data/drones_lab.mtl
new file mode 100644
index 0000000..d7d6d45
--- /dev/null
+++ b/TLV-data/drones_lab.mtl
@@ -0,0 +1,122 @@
+# Blender 3.4.1 MTL File: 'None'
+# www.blender.org
+
+newmtl ceiling
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 1.000000 1.000000 1.000000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd ceiling.png
+
+newmtl extrior_walls
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd concrete_wall.png
+
+newmtl floor
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd floor.png
+
+newmtl lamps
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd ceiling_lamps.png
+
+newmtl posters
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd posters.png
+
+newmtl wall1
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd wall1.png
+
+newmtl wall2
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd wall2.png
+
+newmtl wall3
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd wall3.png
+
+newmtl wall4
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd wall4.png
+
+newmtl wall9
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd wall9.png
+
+newmtl walls5_6
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd walls5_6.png
+
+newmtl walls7_8
+Ns 250.000000
+Ka 1.000000 1.000000 1.000000
+Ks 0.500000 0.500000 0.500000
+Ke 0.000000 0.000000 0.000000
+Ni 1.450000
+d 1.000000
+illum 2
+map_Kd walls7_8.png
diff --git a/TLV-data/floor.png b/TLV-data/floor.png
new file mode 100644
index 0000000..5221296
Binary files /dev/null and b/TLV-data/floor.png differ
diff --git a/TLV-data/posters.png b/TLV-data/posters.png
new file mode 100644
index 0000000..27acdf5
Binary files /dev/null and b/TLV-data/posters.png differ
diff --git a/TLV-data/wall1.png b/TLV-data/wall1.png
new file mode 100644
index 0000000..bfbc130
Binary files /dev/null and b/TLV-data/wall1.png differ
diff --git a/TLV-data/wall2.png b/TLV-data/wall2.png
new file mode 100644
index 0000000..dbf23ff
Binary files /dev/null and b/TLV-data/wall2.png differ
diff --git a/Vocabulary/ORBvoc.txt.tar.gz b/TLV-data/wall3.png
similarity index 52%
rename from Vocabulary/ORBvoc.txt.tar.gz
rename to TLV-data/wall3.png
index 96f5a81..1cbffed 100644
Binary files a/Vocabulary/ORBvoc.txt.tar.gz and b/TLV-data/wall3.png differ
diff --git a/TLV-data/wall4.png b/TLV-data/wall4.png
new file mode 100644
index 0000000..6c6663d
Binary files /dev/null and b/TLV-data/wall4.png differ
diff --git a/TLV-data/wall9.png b/TLV-data/wall9.png
new file mode 100644
index 0000000..05406fb
Binary files /dev/null and b/TLV-data/wall9.png differ
diff --git a/TLV-data/walls5_6.png b/TLV-data/walls5_6.png
new file mode 100644
index 0000000..a0e67ff
Binary files /dev/null and b/TLV-data/walls5_6.png differ
diff --git a/TLV-data/walls7_8.png b/TLV-data/walls7_8.png
new file mode 100644
index 0000000..7c3c5a9
Binary files /dev/null and b/TLV-data/walls7_8.png differ
diff --git a/Thirdparty/CMakeLists.txt b/Thirdparty/CMakeLists.txt
new file mode 100644
index 0000000..c8fcd27
--- /dev/null
+++ b/Thirdparty/CMakeLists.txt
@@ -0,0 +1,4 @@
+SET(CMAKE_BUILD_TYPE Release)
+add_subdirectory(DBoW2)
+add_subdirectory(g2o)
+add_subdirectory(Pangolin)
\ No newline at end of file
diff --git a/Thirdparty/DBoW2/CMakeLists.txt b/Thirdparty/DBoW2/CMakeLists.txt
index 4da56b2..544dd79 100644
--- a/Thirdparty/DBoW2/CMakeLists.txt
+++ b/Thirdparty/DBoW2/CMakeLists.txt
@@ -1,9 +1,8 @@
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 3.0)
 project(DBoW2)
-
-set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}  -Wall  -O3 -march=native ")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall  -O3 -march=native")
-
+IF (NOT CMAKE_BUILD_TYPE)
+    SET(CMAKE_BUILD_TYPE Debug)
+ENDIF ()
 set(HDRS_DBOW2
   DBoW2/BowVector.h
   DBoW2/FORB.h 
@@ -23,12 +22,12 @@ set(HDRS_DUTILS
 set(SRCS_DUTILS
   DUtils/Random.cpp
   DUtils/Timestamp.cpp)
-
 find_package(OpenCV REQUIRED)
+SET(DBUILD_SHARED true)
 
 set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
 
 include_directories(${OpenCV_INCLUDE_DIRS})
-add_library(DBoW2 SHARED ${SRCS_DBOW2} ${SRCS_DUTILS})
+add_library(DBoW2 ${SRCS_DBOW2} ${SRCS_DUTILS})
 target_link_libraries(DBoW2 ${OpenCV_LIBS})
 
diff --git a/Thirdparty/DBoW2/DBoW2/FORB.cpp b/Thirdparty/DBoW2/DBoW2/FORB.cpp
index 2b750d2..5739ee0 100644
--- a/Thirdparty/DBoW2/DBoW2/FORB.cpp
+++ b/Thirdparty/DBoW2/DBoW2/FORB.cpp
@@ -5,188 +5,192 @@
  * Description: functions for ORB descriptors
  * License: see the LICENSE.txt file
  *
- * Distance function has been modified 
+ * Distance function has been modified
  *
  */
 
- 
 #include <vector>
 #include <string>
 #include <sstream>
-#include <stdint-gcc.h>
+#include <stdint.h>
 
 #include "FORB.h"
 
+namespace DBoW2
+{
 
-namespace DBoW2 {
-
-// --------------------------------------------------------------------------
+  // --------------------------------------------------------------------------
 
-const int FORB::L=32;
+  const int FORB::L = 32;
 
-void FORB::meanValue(const std::vector<FORB::pDescriptor> &descriptors, 
-  FORB::TDescriptor &mean)
-{
-  if(descriptors.empty())
-  {
-    mean.release();
-    return;
-  }
-  else if(descriptors.size() == 1)
-  {
-    mean = descriptors[0]->clone();
-  }
-  else
+  void FORB::meanValue(const std::vector<FORB::pDescriptor> &descriptors,
+                       FORB::TDescriptor &mean)
   {
-    std::vector<int> sum(FORB::L * 8, 0);
-    
-    for(size_t i = 0; i < descriptors.size(); ++i)
+    if (descriptors.empty())
     {
-      const cv::Mat &d = *descriptors[i];
-      const unsigned char *p = d.ptr<unsigned char>();
-      
-      for(int j = 0; j < d.cols; ++j, ++p)
-      {
-        if(*p & (1 << 7)) ++sum[ j*8     ];
-        if(*p & (1 << 6)) ++sum[ j*8 + 1 ];
-        if(*p & (1 << 5)) ++sum[ j*8 + 2 ];
-        if(*p & (1 << 4)) ++sum[ j*8 + 3 ];
-        if(*p & (1 << 3)) ++sum[ j*8 + 4 ];
-        if(*p & (1 << 2)) ++sum[ j*8 + 5 ];
-        if(*p & (1 << 1)) ++sum[ j*8 + 6 ];
-        if(*p & (1))      ++sum[ j*8 + 7 ];
-      }
+      mean.release();
+      return;
+    }
+    else if (descriptors.size() == 1)
+    {
+      mean = descriptors[0]->clone();
     }
-    
-    mean = cv::Mat::zeros(1, FORB::L, CV_8U);
-    unsigned char *p = mean.ptr<unsigned char>();
-    
-    const int N2 = (int)descriptors.size() / 2 + descriptors.size() % 2;
-    for(size_t i = 0; i < sum.size(); ++i)
+    else
     {
-      if(sum[i] >= N2)
+      std::vector<int> sum(FORB::L * 8, 0);
+
+      for (size_t i = 0; i < descriptors.size(); ++i)
+      {
+        const cv::Mat &d = *descriptors[i];
+        const unsigned char *p = d.ptr<unsigned char>();
+
+        for (int j = 0; j < d.cols; ++j, ++p)
+        {
+          if (*p & (1 << 7))
+            ++sum[j * 8];
+          if (*p & (1 << 6))
+            ++sum[j * 8 + 1];
+          if (*p & (1 << 5))
+            ++sum[j * 8 + 2];
+          if (*p & (1 << 4))
+            ++sum[j * 8 + 3];
+          if (*p & (1 << 3))
+            ++sum[j * 8 + 4];
+          if (*p & (1 << 2))
+            ++sum[j * 8 + 5];
+          if (*p & (1 << 1))
+            ++sum[j * 8 + 6];
+          if (*p & (1))
+            ++sum[j * 8 + 7];
+        }
+      }
+
+      mean = cv::Mat::zeros(1, FORB::L, CV_8U);
+      unsigned char *p = mean.ptr<unsigned char>();
+
+      const int N2 = (int)descriptors.size() / 2 + descriptors.size() % 2;
+      for (size_t i = 0; i < sum.size(); ++i)
       {
-        // set bit
-        *p |= 1 << (7 - (i % 8));
+        if (sum[i] >= N2)
+        {
+          // set bit
+          *p |= 1 << (7 - (i % 8));
+        }
+
+        if (i % 8 == 7)
+          ++p;
       }
-      
-      if(i % 8 == 7) ++p;
     }
   }
-}
 
-// --------------------------------------------------------------------------
-  
-int FORB::distance(const FORB::TDescriptor &a,
-  const FORB::TDescriptor &b)
-{
-  // Bit set count operation from
-  // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
+  // --------------------------------------------------------------------------
 
-  const int *pa = a.ptr<int32_t>();
-  const int *pb = b.ptr<int32_t>();
+  int FORB::distance(const FORB::TDescriptor &a,
+                     const FORB::TDescriptor &b)
+  {
+    // Bit set count operation from
+    // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
 
-  int dist=0;
+    const int *pa = a.ptr<int32_t>();
+    const int *pb = b.ptr<int32_t>();
 
-  for(int i=0; i<8; i++, pa++, pb++)
-  {
-      unsigned  int v = *pa ^ *pb;
+    int dist = 0;
+
+    for (int i = 0; i < 8; i++, pa++, pb++)
+    {
+      unsigned int v = *pa ^ *pb;
       v = v - ((v >> 1) & 0x55555555);
       v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
       dist += (((v + (v >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
+    }
+
+    return dist;
   }
 
-  return dist;
-}
+  // --------------------------------------------------------------------------
 
-// --------------------------------------------------------------------------
-  
-std::string FORB::toString(const FORB::TDescriptor &a)
-{
-    std::stringstream ss;
-  const unsigned char *p = a.ptr<unsigned char>();
-  
-  for(int i = 0; i < a.cols; ++i, ++p)
+  std::string FORB::toString(const FORB::TDescriptor &a)
   {
-    ss << (int)*p << " ";
-  }
-  
-  return ss.str();
-}
+    std::stringstream ss;
+    const unsigned char *p = a.ptr<unsigned char>();
 
-// --------------------------------------------------------------------------
-  
-void FORB::fromString(FORB::TDescriptor &a, const std::string &s)
-{
-  a.create(1, FORB::L, CV_8U);
-  unsigned char *p = a.ptr<unsigned char>();
+    for (int i = 0; i < a.cols; ++i, ++p)
+    {
+      ss << (int)*p << " ";
+    }
 
-    std::stringstream ss(s);
-  for(int i = 0; i < FORB::L; ++i, ++p)
-  {
-    int n;
-    ss >> n;
-    
-    if(!ss.fail()) 
-      *p = (unsigned char)n;
+    return ss.str();
   }
-  
-}
 
-// --------------------------------------------------------------------------
+  // --------------------------------------------------------------------------
 
-void FORB::toMat32F(const std::vector<TDescriptor> &descriptors, 
-  cv::Mat &mat)
-{
-  if(descriptors.empty())
+  void FORB::fromString(FORB::TDescriptor &a, const std::string &s)
   {
-    mat.release();
-    return;
+    a.create(1, FORB::L, CV_8U);
+    unsigned char *p = a.ptr<unsigned char>();
+
+    std::stringstream ss(s);
+    for (int i = 0; i < FORB::L; ++i, ++p)
+    {
+      int n;
+      ss >> n;
+
+      if (!ss.fail())
+        *p = (unsigned char)n;
+    }
   }
-  
-  const size_t N = descriptors.size();
-  
-  mat.create(N, FORB::L*8, CV_32F);
-  float *p = mat.ptr<float>();
-  
-  for(size_t i = 0; i < N; ++i)
+
+  // --------------------------------------------------------------------------
+
+  void FORB::toMat32F(const std::vector<TDescriptor> &descriptors,
+                      cv::Mat &mat)
   {
-    const int C = descriptors[i].cols;
-    const unsigned char *desc = descriptors[i].ptr<unsigned char>();
-    
-    for(int j = 0; j < C; ++j, p += 8)
+    if (descriptors.empty())
     {
-      p[0] = (desc[j] & (1 << 7) ? 1 : 0);
-      p[1] = (desc[j] & (1 << 6) ? 1 : 0);
-      p[2] = (desc[j] & (1 << 5) ? 1 : 0);
-      p[3] = (desc[j] & (1 << 4) ? 1 : 0);
-      p[4] = (desc[j] & (1 << 3) ? 1 : 0);
-      p[5] = (desc[j] & (1 << 2) ? 1 : 0);
-      p[6] = (desc[j] & (1 << 1) ? 1 : 0);
-      p[7] = desc[j] & (1);
+      mat.release();
+      return;
     }
-  } 
-}
 
-// --------------------------------------------------------------------------
+    const size_t N = descriptors.size();
 
-void FORB::toMat8U(const std::vector<TDescriptor> &descriptors, 
-  cv::Mat &mat)
-{
-  mat.create(descriptors.size(), 32, CV_8U);
-  
-  unsigned char *p = mat.ptr<unsigned char>();
-  
-  for(size_t i = 0; i < descriptors.size(); ++i, p += 32)
-  {
-    const unsigned char *d = descriptors[i].ptr<unsigned char>();
-    std::copy(d, d+32, p);
+    mat.create(N, FORB::L * 8, CV_32F);
+    float *p = mat.ptr<float>();
+
+    for (size_t i = 0; i < N; ++i)
+    {
+      const int C = descriptors[i].cols;
+      const unsigned char *desc = descriptors[i].ptr<unsigned char>();
+
+      for (int j = 0; j < C; ++j, p += 8)
+      {
+        p[0] = (desc[j] & (1 << 7) ? 1 : 0);
+        p[1] = (desc[j] & (1 << 6) ? 1 : 0);
+        p[2] = (desc[j] & (1 << 5) ? 1 : 0);
+        p[3] = (desc[j] & (1 << 4) ? 1 : 0);
+        p[4] = (desc[j] & (1 << 3) ? 1 : 0);
+        p[5] = (desc[j] & (1 << 2) ? 1 : 0);
+        p[6] = (desc[j] & (1 << 1) ? 1 : 0);
+        p[7] = desc[j] & (1);
+      }
+    }
   }
-  
-}
 
-// --------------------------------------------------------------------------
+  // --------------------------------------------------------------------------
 
-} // namespace DBoW2
+  void FORB::toMat8U(const std::vector<TDescriptor> &descriptors,
+                     cv::Mat &mat)
+  {
+    mat.create(descriptors.size(), 32, CV_8U);
 
+    unsigned char *p = mat.ptr<unsigned char>();
 
+    for (size_t i = 0; i < descriptors.size(); ++i, p += 32)
+    {
+      const unsigned char *d = descriptors[i].ptr<unsigned char>();
+      std::copy(d, d + 32, p);
+    }
+  }
+
+  // --------------------------------------------------------------------------
+
+} // namespace DBoW2
diff --git a/Thirdparty/DBoW2/DBoW2/TemplatedVocabulary.h b/Thirdparty/DBoW2/DBoW2/TemplatedVocabulary.h
index 1d61752..1553879 100644
--- a/Thirdparty/DBoW2/DBoW2/TemplatedVocabulary.h
+++ b/Thirdparty/DBoW2/DBoW2/TemplatedVocabulary.h
@@ -1373,7 +1373,7 @@ namespace DBoW2 {
         m_nodes.clear();
         m_nodes.resize(nb_nodes + 1);
         m_nodes[0].id = 0;
-        char buf[size_node];
+        char* buf=new char[size_node];
         int nid = 1;
         while (!f.eof()) {
             f.read(buf, size_node);
@@ -1396,6 +1396,7 @@ namespace DBoW2 {
             nid += 1;
         }
         f.close();
+        delete buf;
         return true;
     }
 
diff --git a/Thirdparty/DBoW2/DUtils/Timestamp.cpp b/Thirdparty/DBoW2/DUtils/Timestamp.cpp
index c444c7d..3f40a12 100644
--- a/Thirdparty/DBoW2/DUtils/Timestamp.cpp
+++ b/Thirdparty/DBoW2/DUtils/Timestamp.cpp
@@ -3,7 +3,7 @@
  * Author: Dorian Galvez-Lopez
  * Date: March 2009
  * Description: timestamping functions
- * 
+ *
  * Note: in windows, this class has a 1ms resolution
  *
  * License: see the LICENSE.txt file
@@ -34,28 +34,31 @@
 
 #include "Timestamp.h"
 
-
 using namespace DUtils;
 
-Timestamp::Timestamp(Timestamp::tOptions option) {
+Timestamp::Timestamp(Timestamp::tOptions option)
+{
     if (option & CURRENT_TIME)
         setToCurrentTime();
     else if (option & ZERO)
         setTime(0.);
 }
 
-Timestamp::~Timestamp(void) {
+Timestamp::~Timestamp(void)
+{
 }
 
-bool Timestamp::empty() const {
+bool Timestamp::empty() const
+{
     return m_secs == 0 && m_usecs == 0;
 }
 
-void Timestamp::setToCurrentTime() {
+void Timestamp::setToCurrentTime()
+{
 
 #ifdef WIN32
     struct __timeb32 timebuffer;
-    _ftime32_s( &timebuffer ); // C4996
+    _ftime32_s(&timebuffer); // C4996
     // Note: _ftime is deprecated; consider using _ftime_s instead
     m_secs = timebuffer.time;
     m_usecs = timebuffer.millitm * 1000;
@@ -65,60 +68,71 @@ void Timestamp::setToCurrentTime() {
     m_secs = now.tv_sec;
     m_usecs = now.tv_usec;
 #endif
-
 }
 
-void Timestamp::setTime(const std::string &stime) {
+void Timestamp::setTime(const std::string &stime)
+{
     std::string::size_type p = stime.find('.');
-    if (p == std::string::npos) {
+    if (p == std::string::npos)
+    {
         m_secs = atol(stime.c_str());
         m_usecs = 0;
-    } else {
+    }
+    else
+    {
         m_secs = atol(stime.substr(0, p).c_str());
 
         std::string s_usecs = stime.substr(p + 1, 6);
         m_usecs = atol(stime.substr(p + 1).c_str());
-        m_usecs *= (unsigned long) pow(10.0, double(6 - s_usecs.length()));
+        m_usecs *= (unsigned long)pow(10.0, double(6 - s_usecs.length()));
     }
 }
 
-void Timestamp::setTime(double s) {
-    m_secs = (unsigned long) s;
-    m_usecs = (s - (double) m_secs) * 1e6;
+void Timestamp::setTime(double s)
+{
+    m_secs = (unsigned long)s;
+    m_usecs = (s - (double)m_secs) * 1e6;
 }
 
-double Timestamp::getFloatTime() const {
+double Timestamp::getFloatTime() const
+{
     return double(m_secs) + double(m_usecs) / 1000000.0;
 }
 
-std::string Timestamp::getStringTime() const {
+std::string Timestamp::getStringTime() const
+{
     char buf[32];
     sprintf(buf, "%.6lf", this->getFloatTime());
     return std::string(buf);
 }
 
-double Timestamp::operator-(const Timestamp &t) const {
+double Timestamp::operator-(const Timestamp &t) const
+{
     return this->getFloatTime() - t.getFloatTime();
 }
 
-Timestamp &Timestamp::operator+=(double s) {
+Timestamp &Timestamp::operator+=(double s)
+{
     *this = *this + s;
     return *this;
 }
 
-Timestamp &Timestamp::operator-=(double s) {
+Timestamp &Timestamp::operator-=(double s)
+{
     *this = *this - s;
     return *this;
 }
 
-Timestamp Timestamp::operator+(double s) const {
-    unsigned long secs = (long) floor(s);
-    unsigned long usecs = (long) ((s - (double) secs) * 1e6);
+Timestamp Timestamp::operator+(double s) const
+{
+    unsigned long secs = (long)floor(s);
+    unsigned long usecs = (long)((s - (double)secs) * 1e6);
 
     return this->plus(secs, usecs);
 }
 
-Timestamp Timestamp::plus(unsigned long secs, unsigned long usecs) const {
+Timestamp Timestamp::plus(unsigned long secs, unsigned long usecs) const
+{
     Timestamp t;
 
     const unsigned long max = 1000000ul;
@@ -131,14 +145,16 @@ Timestamp Timestamp::plus(unsigned long secs, unsigned long usecs) const {
     return t;
 }
 
-Timestamp Timestamp::operator-(double s) const {
-    unsigned long secs = (long) floor(s);
-    unsigned long usecs = (long) ((s - (double) secs) * 1e6);
+Timestamp Timestamp::operator-(double s) const
+{
+    unsigned long secs = (long)floor(s);
+    unsigned long usecs = (long)((s - (double)secs) * 1e6);
 
     return this->minus(secs, usecs);
 }
 
-Timestamp Timestamp::minus(unsigned long secs, unsigned long usecs) const {
+Timestamp Timestamp::minus(unsigned long secs, unsigned long usecs) const
+{
     Timestamp t;
 
     const unsigned long max = 1000000ul;
@@ -151,39 +167,56 @@ Timestamp Timestamp::minus(unsigned long secs, unsigned long usecs) const {
     return t;
 }
 
-bool Timestamp::operator>(const Timestamp &t) const {
-    if (m_secs > t.m_secs) return true;
-    else if (m_secs == t.m_secs) return m_usecs > t.m_usecs;
-    else return false;
+bool Timestamp::operator>(const Timestamp &t) const
+{
+    if (m_secs > t.m_secs)
+        return true;
+    else if (m_secs == t.m_secs)
+        return m_usecs > t.m_usecs;
+    else
+        return false;
 }
 
-bool Timestamp::operator>=(const Timestamp &t) const {
-    if (m_secs > t.m_secs) return true;
-    else if (m_secs == t.m_secs) return m_usecs >= t.m_usecs;
-    else return false;
+bool Timestamp::operator>=(const Timestamp &t) const
+{
+    if (m_secs > t.m_secs)
+        return true;
+    else if (m_secs == t.m_secs)
+        return m_usecs >= t.m_usecs;
+    else
+        return false;
 }
 
-bool Timestamp::operator<(const Timestamp &t) const {
-    if (m_secs < t.m_secs) return true;
-    else if (m_secs == t.m_secs) return m_usecs < t.m_usecs;
-    else return false;
+bool Timestamp::operator<(const Timestamp &t) const
+{
+    if (m_secs < t.m_secs)
+        return true;
+    else if (m_secs == t.m_secs)
+        return m_usecs < t.m_usecs;
+    else
+        return false;
 }
 
-bool Timestamp::operator<=(const Timestamp &t) const {
-    if (m_secs < t.m_secs) return true;
-    else if (m_secs == t.m_secs) return m_usecs <= t.m_usecs;
-    else return false;
+bool Timestamp::operator<=(const Timestamp &t) const
+{
+    if (m_secs < t.m_secs)
+        return true;
+    else if (m_secs == t.m_secs)
+        return m_usecs <= t.m_usecs;
+    else
+        return false;
 }
 
-bool Timestamp::operator==(const Timestamp &t) const {
+bool Timestamp::operator==(const Timestamp &t) const
+{
     return (m_secs == t.m_secs && m_usecs == t.m_usecs);
 }
 
-
-std::string Timestamp::Format(bool machine_friendly) const {
+std::string Timestamp::Format(bool machine_friendly) const
+{
     struct tm tm_time;
 
-    time_t t = (time_t) getFloatTime();
+    time_t t = (time_t)getFloatTime();
 
 #ifdef WIN32
     localtime_s(&tm_time, &t);
@@ -193,16 +226,20 @@ std::string Timestamp::Format(bool machine_friendly) const {
 
     char buffer[128];
 
-    if (machine_friendly) {
+    if (machine_friendly)
+    {
         strftime(buffer, 128, "%Y%m%d_%H%M%S", &tm_time);
-    } else {
+    }
+    else
+    {
         strftime(buffer, 128, "%c", &tm_time); // Thu Aug 23 14:55:02 2001
     }
 
     return std::string(buffer);
 }
 
-std::string Timestamp::Format(double s) {
+std::string Timestamp::Format(double s)
+{
     int days = int(s / (24. * 3600.0));
     s -= days * (24. * 3600.0);
     int hours = int(s / 3600.0);
@@ -215,14 +252,17 @@ std::string Timestamp::Format(double s) {
     std::stringstream ss;
     ss.fill('0');
     bool b;
-    if ((b = (days > 0))) ss << days << "d ";
-    if ((b = (b || hours > 0))) ss << std::setw(2) << hours << ":";
-    if ((b = (b || minutes > 0))) ss << std::setw(2) << minutes << ":";
-    if (b) ss << std::setw(2);
+    if ((b = (days > 0)))
+        ss << days << "d ";
+    if ((b = (b || hours > 0)))
+        ss << std::setw(2) << hours << ":";
+    if ((b = (b || minutes > 0)))
+        ss << std::setw(2) << minutes << ":";
+    if (b)
+        ss << std::setw(2);
     ss << seconds;
-    if (!b) ss << "." << std::setw(6) << ms;
+    if (!b)
+        ss << "." << std::setw(6) << ms;
 
     return ss.str();
 }
-
-
diff --git a/Thirdparty/g2o/CMakeLists.txt b/Thirdparty/g2o/CMakeLists.txt
index 7939e66..9aecf44 100644
--- a/Thirdparty/g2o/CMakeLists.txt
+++ b/Thirdparty/g2o/CMakeLists.txt
@@ -13,7 +13,7 @@ ENDIF()
 
 MESSAGE(STATUS "BUILD TYPE:" ${CMAKE_BUILD_TYPE})
 
-SET (G2O_LIB_TYPE SHARED)
+SET (G2O_LIB_TYPE STATIC)
 
 # There seems to be an issue with MSVC8
 # see http://eigen.tuxfamily.org/bz/show_bug.cgi?id=83
@@ -42,10 +42,6 @@ IF(UNIX)
   MESSAGE(STATUS "Compiling on Unix")
 ENDIF(UNIX)
 
-# For building the CHOLMOD / CSPARSE solvers
-FIND_PACKAGE(BLAS REQUIRED)
-FIND_PACKAGE(LAPACK REQUIRED)
-
 # Eigen library parallelise itself, though, presumably due to performance issues
 # OPENMP is experimental. We experienced some slowdown with it
 FIND_PACKAGE(OpenMP)
@@ -58,27 +54,25 @@ IF(OPENMP_FOUND AND G2O_USE_OPENMP)
 ENDIF(OPENMP_FOUND AND G2O_USE_OPENMP)
 
 # Compiler specific options for gcc
-# SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -march=native")
-# SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O3 -march=native")
+SET(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -march=native") 
+SET(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O3 -march=native") 
 
 # activate warnings !!!
-SET(g2o_C_FLAGS "${g2o_C_FLAGS} -Wall -W")
-SET(g2o_CXX_FLAGS "${g2o_CXX_FLAGS} -Wall -W")
+SET(g2o_C_FLAGS "${g2o_C_FLAGS} ")
+SET(g2o_CXX_FLAGS "${g2o_CXX_FLAGS}")
 
 # specifying compiler flags
 SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${g2o_CXX_FLAGS}")
 SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${g2o_C_FLAGS}")
 
 # Find Eigen3
-#SET(EIGEN3_INCLUDE_DIR ${G2O_EIGEN3_INCLUDE})
-# FIND_PACKAGE(Eigen3 REQUIRED)
-find_package(PkgConfig)
-pkg_search_module(Eigen3 REQUIRED eigen3)
-# IF(EIGEN3_FOUND)
-SET(G2O_EIGEN3_INCLUDE ${Eigen3_INCLUDE_DIR} CACHE PATH "Directory of Eigen3")
-# ELSE(EIGEN3_FOUND)
-#   SET(G2O_EIGEN3_INCLUDE "" CACHE PATH "Directory of Eigen3")
-# ENDIF(EIGEN3_FOUND)
+SET(EIGEN3_INCLUDE_DIR ${G2O_EIGEN3_INCLUDE})
+FIND_PACKAGE(Eigen3 3.1.0 REQUIRED)
+IF(EIGEN3_FOUND)
+  SET(G2O_EIGEN3_INCLUDE ${EIGEN3_INCLUDE_DIR} CACHE PATH "Directory of Eigen3")
+ELSE(EIGEN3_FOUND)
+  SET(G2O_EIGEN3_INCLUDE "" CACHE PATH "Directory of Eigen3")
+ENDIF(EIGEN3_FOUND)
 
 # Generate config.h
 SET(G2O_CXX_COMPILER "${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER}")
@@ -86,95 +80,95 @@ configure_file(config.h.in ${g2o_SOURCE_DIR}/config.h)
 
 # Set up the top-level include directories
 INCLUDE_DIRECTORIES(
-        ${g2o_SOURCE_DIR}/core
-        ${g2o_SOURCE_DIR}/types
-        ${g2o_SOURCE_DIR}/stuff
-        ${G2O_EIGEN3_INCLUDE})
+${g2o_SOURCE_DIR}/core
+${g2o_SOURCE_DIR}/types
+${g2o_SOURCE_DIR}/stuff 
+${G2O_EIGEN3_INCLUDE})
 
 # Include the subdirectories
 ADD_LIBRARY(g2o ${G2O_LIB_TYPE}
-        #types
-        g2o/types/types_sba.h
-        g2o/types/types_six_dof_expmap.h
-        g2o/types/types_sba.cpp
-        g2o/types/types_six_dof_expmap.cpp
-        g2o/types/types_seven_dof_expmap.cpp
-        g2o/types/types_seven_dof_expmap.h
-        g2o/types/se3quat.h
-        g2o/types/se3_ops.h
-        g2o/types/se3_ops.hpp
-        #core
-        g2o/core/base_edge.h
-        g2o/core/base_binary_edge.h
-        g2o/core/hyper_graph_action.cpp
-        g2o/core/base_binary_edge.hpp
-        g2o/core/hyper_graph_action.h
-        g2o/core/base_multi_edge.h
-        g2o/core/hyper_graph.cpp
-        g2o/core/base_multi_edge.hpp
-        g2o/core/hyper_graph.h
-        g2o/core/base_unary_edge.h
-        g2o/core/linear_solver.h
-        g2o/core/base_unary_edge.hpp
-        g2o/core/marginal_covariance_cholesky.cpp
-        g2o/core/base_vertex.h
-        g2o/core/marginal_covariance_cholesky.h
-        g2o/core/base_vertex.hpp
-        g2o/core/matrix_structure.cpp
-        g2o/core/batch_stats.cpp
-        g2o/core/matrix_structure.h
-        g2o/core/batch_stats.h
-        g2o/core/openmp_mutex.h
-        g2o/core/block_solver.h
-        g2o/core/block_solver.hpp
-        g2o/core/parameter.cpp
-        g2o/core/parameter.h
-        g2o/core/cache.cpp
-        g2o/core/cache.h
-        g2o/core/optimizable_graph.cpp
-        g2o/core/optimizable_graph.h
-        g2o/core/solver.cpp
-        g2o/core/solver.h
-        g2o/core/creators.h
-        g2o/core/optimization_algorithm_factory.cpp
-        g2o/core/estimate_propagator.cpp
-        g2o/core/optimization_algorithm_factory.h
-        g2o/core/estimate_propagator.h
-        g2o/core/factory.cpp
-        g2o/core/optimization_algorithm_property.h
-        g2o/core/factory.h
-        g2o/core/sparse_block_matrix.h
-        g2o/core/sparse_optimizer.cpp
-        g2o/core/sparse_block_matrix.hpp
-        g2o/core/sparse_optimizer.h
-        g2o/core/hyper_dijkstra.cpp
-        g2o/core/hyper_dijkstra.h
-        g2o/core/parameter_container.cpp
-        g2o/core/parameter_container.h
-        g2o/core/optimization_algorithm.cpp
-        g2o/core/optimization_algorithm.h
-        g2o/core/optimization_algorithm_with_hessian.cpp
-        g2o/core/optimization_algorithm_with_hessian.h
-        g2o/core/optimization_algorithm_levenberg.cpp
-        g2o/core/optimization_algorithm_levenberg.h
-        g2o/core/jacobian_workspace.cpp
-        g2o/core/jacobian_workspace.h
-        g2o/core/robust_kernel.cpp
-        g2o/core/robust_kernel.h
-        g2o/core/robust_kernel_factory.cpp
-        g2o/core/robust_kernel_factory.h
-        g2o/core/robust_kernel_impl.cpp
-        g2o/core/robust_kernel_impl.h
-        #stuff
-        g2o/stuff/string_tools.h
-        g2o/stuff/color_macros.h
-        g2o/stuff/macros.h
-        g2o/stuff/timeutil.cpp
-        g2o/stuff/misc.h
-        g2o/stuff/timeutil.h
-        g2o/stuff/os_specific.c
-        g2o/stuff/os_specific.h
-        g2o/stuff/string_tools.cpp
-        g2o/stuff/property.cpp
-        g2o/stuff/property.h
-        )
+#types
+g2o/types/types_sba.h
+g2o/types/types_six_dof_expmap.h
+g2o/types/types_sba.cpp
+g2o/types/types_six_dof_expmap.cpp
+g2o/types/types_seven_dof_expmap.cpp
+g2o/types/types_seven_dof_expmap.h
+g2o/types/se3quat.h
+g2o/types/se3_ops.h
+g2o/types/se3_ops.hpp
+#core
+g2o/core/base_edge.h
+g2o/core/base_binary_edge.h
+g2o/core/hyper_graph_action.cpp
+g2o/core/base_binary_edge.hpp
+g2o/core/hyper_graph_action.h
+g2o/core/base_multi_edge.h           
+g2o/core/hyper_graph.cpp
+g2o/core/base_multi_edge.hpp         
+g2o/core/hyper_graph.h
+g2o/core/base_unary_edge.h          
+g2o/core/linear_solver.h
+g2o/core/base_unary_edge.hpp         
+g2o/core/marginal_covariance_cholesky.cpp
+g2o/core/base_vertex.h               
+g2o/core/marginal_covariance_cholesky.h
+g2o/core/base_vertex.hpp             
+g2o/core/matrix_structure.cpp
+g2o/core/batch_stats.cpp             
+g2o/core/matrix_structure.h
+g2o/core/batch_stats.h               
+g2o/core/openmp_mutex.h
+g2o/core/block_solver.h              
+g2o/core/block_solver.hpp            
+g2o/core/parameter.cpp               
+g2o/core/parameter.h                 
+g2o/core/cache.cpp                   
+g2o/core/cache.h
+g2o/core/optimizable_graph.cpp       
+g2o/core/optimizable_graph.h         
+g2o/core/solver.cpp                  
+g2o/core/solver.h
+g2o/core/creators.h                 
+g2o/core/optimization_algorithm_factory.cpp
+g2o/core/estimate_propagator.cpp     
+g2o/core/optimization_algorithm_factory.h
+g2o/core/estimate_propagator.h       
+g2o/core/factory.cpp                 
+g2o/core/optimization_algorithm_property.h
+g2o/core/factory.h                   
+g2o/core/sparse_block_matrix.h
+g2o/core/sparse_optimizer.cpp  
+g2o/core/sparse_block_matrix.hpp
+g2o/core/sparse_optimizer.h
+g2o/core/hyper_dijkstra.cpp 
+g2o/core/hyper_dijkstra.h
+g2o/core/parameter_container.cpp     
+g2o/core/parameter_container.h
+g2o/core/optimization_algorithm.cpp 
+g2o/core/optimization_algorithm.h
+g2o/core/optimization_algorithm_with_hessian.cpp 
+g2o/core/optimization_algorithm_with_hessian.h
+g2o/core/optimization_algorithm_levenberg.cpp 
+g2o/core/optimization_algorithm_levenberg.h
+g2o/core/jacobian_workspace.cpp 
+g2o/core/jacobian_workspace.h
+g2o/core/robust_kernel.cpp 
+g2o/core/robust_kernel.h
+g2o/core/robust_kernel_factory.cpp
+g2o/core/robust_kernel_factory.h
+g2o/core/robust_kernel_impl.cpp 
+g2o/core/robust_kernel_impl.h
+#stuff
+g2o/stuff/string_tools.h
+g2o/stuff/color_macros.h 
+g2o/stuff/macros.h
+g2o/stuff/timeutil.cpp
+g2o/stuff/misc.h
+g2o/stuff/timeutil.h
+g2o/stuff/os_specific.c    
+g2o/stuff/os_specific.h
+g2o/stuff/string_tools.cpp
+g2o/stuff/property.cpp       
+g2o/stuff/property.h       
+)
\ No newline at end of file
diff --git a/Thirdparty/g2o/cmake_modules/FindBLAS.cmake b/Thirdparty/g2o/cmake_modules/FindBLAS.cmake
index 68c4e07..e6c77af 100644
--- a/Thirdparty/g2o/cmake_modules/FindBLAS.cmake
+++ b/Thirdparty/g2o/cmake_modules/FindBLAS.cmake
@@ -24,6 +24,9 @@
 # - find libraries for a C++ compiler, instead of Fortran
 # - added BLAS_INCLUDE_DIR, BLAS_DEFINITIONS and BLAS_LIBRARIES_DIR
 # - removed BLAS95_LIBRARIES
+if(NOT WIN32)
+  
+
 
 include(CheckFunctionExists)
 
@@ -417,3 +420,4 @@ else()
   #message("DEBUG: BLAS_FOUND = ${BLAS_FOUND}")
 
 endif(BLAS_LIBRARIES_DIR OR BLAS_LIBRARIES)
+endif(NOT WIN32)
\ No newline at end of file
diff --git a/Thirdparty/g2o/g2o/core/base_edge.h b/Thirdparty/g2o/g2o/core/base_edge.h
index 78be5bb..91139e4 100644
--- a/Thirdparty/g2o/g2o/core/base_edge.h
+++ b/Thirdparty/g2o/g2o/core/base_edge.h
@@ -30,7 +30,7 @@
 #include <iostream>
 #include <limits>
 
-#include <eigen3/Eigen/Core>
+#include <Eigen/Core>
 
 #include "optimizable_graph.h"
 
diff --git a/Thirdparty/g2o/g2o/core/base_vertex.h b/Thirdparty/g2o/g2o/core/base_vertex.h
index eb92ca0..5f7075d 100644
--- a/Thirdparty/g2o/g2o/core/base_vertex.h
+++ b/Thirdparty/g2o/g2o/core/base_vertex.h
@@ -31,90 +31,122 @@
 #include "creators.h"
 #include "../stuff/macros.h"
 
-#include <eigen3/Eigen/Core>
-#include <eigen3/Eigen/Dense>
-#include <eigen3/Eigen/Cholesky>
-#include <eigen3/Eigen/StdVector>
+#include <Eigen/Core>
+#include <Eigen/Dense>
+#include <Eigen/Cholesky>
+#include <Eigen/StdVector>
 #include <stack>
 
-namespace g2o {
+namespace g2o
+{
 
   using namespace Eigen;
 
-
-/**
- * \brief Templatized BaseVertex
- *
- * Templatized BaseVertex
- * D  : minimal dimension of the vertex, e.g., 3 for rotation in 3D
- * T  : internal type to represent the estimate, e.g., Quaternion for rotation in 3D
- */
+  /**
+   * \brief Templatized BaseVertex
+   *
+   * Templatized BaseVertex
+   * D  : minimal dimension of the vertex, e.g., 3 for rotation in 3D
+   * T  : internal type to represent the estimate, e.g., Quaternion for rotation in 3D
+   */
   template <int D, typename T>
-  class BaseVertex : public OptimizableGraph::Vertex {
-    public:
+  class BaseVertex : public OptimizableGraph::Vertex
+  {
+  public:
     typedef T EstimateType;
-    typedef std::stack<EstimateType, 
-                       std::vector<EstimateType,  Eigen::aligned_allocator<EstimateType> > >
-    BackupStackType;
+    typedef std::stack<EstimateType,
+                       std::vector<EstimateType, Eigen::aligned_allocator<EstimateType>>>
+        BackupStackType;
 
-    static const int Dimension = D;           ///< dimension of the estimate (minimal) in the manifold space
+    static const int Dimension = D; ///< dimension of the estimate (minimal) in the manifold space
 
-    typedef Eigen::Map<Matrix<double, D, D>, Matrix<double,D,D>::Flags & AlignedBit ? Aligned : Unaligned >  HessianBlockType;
+    typedef Eigen::Map<Matrix<double, D, D>, Matrix<double, D, D>::Flags & AlignedBit ? Aligned : Unaligned> HessianBlockType;
 
   public:
     BaseVertex();
 
-    virtual const double& hessian(int i, int j) const { assert(i<D && j<D); return _hessian(i,j);}
-    virtual double& hessian(int i, int j)  { assert(i<D && j<D); return _hessian(i,j);}
-    virtual double hessianDeterminant() const {return _hessian.determinant();}
-    virtual double* hessianData() { return const_cast<double*>(_hessian.data());}
+    virtual const double &hessian(int i, int j) const
+    {
+      assert(i < D && j < D);
+      return _hessian(i, j);
+    }
+    virtual double &hessian(int i, int j)
+    {
+      assert(i < D && j < D);
+      return _hessian(i, j);
+    }
+    virtual double hessianDeterminant() const { return _hessian.determinant(); }
+    virtual double *hessianData() { return const_cast<double *>(_hessian.data()); }
 
-    virtual void mapHessianMemory(double* d);
+    virtual void mapHessianMemory(double *d);
 
-    virtual int copyB(double* b_) const {
+    virtual int copyB(double *b_) const
+    {
       memcpy(b_, _b.data(), Dimension * sizeof(double));
-      return Dimension; 
+      return Dimension;
     }
 
-    virtual const double& b(int i) const { assert(i < D); return _b(i);}
-    virtual double& b(int i) { assert(i < D); return _b(i);}
-    virtual double* bData() { return _b.data();}
+    virtual const double &b(int i) const
+    {
+      assert(i < D);
+      return _b(i);
+    }
+    virtual double &b(int i)
+    {
+      assert(i < D);
+      return _b(i);
+    }
+    virtual double *bData() { return _b.data(); }
 
     virtual void clearQuadraticForm();
 
     //! updates the current vertex with the direct solution x += H_ii\b_ii
     //! @returns the determinant of the inverted hessian
-    virtual double solveDirect(double lambda=0);
+    virtual double solveDirect(double lambda = 0);
 
     //! return right hand side b of the constructed linear system
-    Matrix<double, D, 1>& b() { return _b;}
-    const Matrix<double, D, 1>& b() const { return _b;}
+    Matrix<double, D, 1> &b() { return _b; }
+    const Matrix<double, D, 1> &b() const { return _b; }
     //! return the hessian block associated with the vertex
-    HessianBlockType& A() { return _hessian;}
-    const HessianBlockType& A() const { return _hessian;}
-
-    virtual void push() { _backup.push(_estimate);}
-    virtual void pop() { assert(!_backup.empty()); _estimate = _backup.top(); _backup.pop(); updateCache();}
-    virtual void discardTop() { assert(!_backup.empty()); _backup.pop();}
-    virtual int stackSize() const {return _backup.size();}
+    HessianBlockType &A() { return _hessian; }
+    const HessianBlockType &A() const { return _hessian; }
+
+    virtual void push() { _backup.push(_estimate); }
+    virtual void pop()
+    {
+      assert(!_backup.empty());
+      _estimate = _backup.top();
+      _backup.pop();
+      updateCache();
+    }
+    virtual void discardTop()
+    {
+      assert(!_backup.empty());
+      _backup.pop();
+    }
+    virtual int stackSize() const { return _backup.size(); }
 
     //! return the current estimate of the vertex
-    const EstimateType& estimate() const { return _estimate;}
+    const EstimateType &estimate() const { return _estimate; }
     //! set the estimate for the vertex also calls updateCache()
-    void setEstimate(const EstimateType& et) { _estimate = et; updateCache();}
+    void setEstimate(const EstimateType &et)
+    {
+      _estimate = et;
+      updateCache();
+    }
 
   protected:
     HessianBlockType _hessian;
     Matrix<double, D, 1> _b;
     EstimateType _estimate;
     BackupStackType _backup;
+
   public:
     EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-};
+  };
 
 #include "base_vertex.hpp"
 
 } // end namespace g2o
 
-
 #endif
diff --git a/Thirdparty/g2o/g2o/core/estimate_propagator.h b/Thirdparty/g2o/g2o/core/estimate_propagator.h
index 6a16d11..3120c4d 100644
--- a/Thirdparty/g2o/g2o/core/estimate_propagator.h
+++ b/Thirdparty/g2o/g2o/core/estimate_propagator.h
@@ -40,20 +40,23 @@
 #include <tr1/unordered_map>
 #endif
 
-namespace g2o {
+namespace g2o
+{
 
   /**
    * \brief cost for traversing along active edges in the optimizer
    *
    * You may derive an own one, if necessary. The default is to return initialEstimatePossible(from, to) for the edge.
    */
-  class  EstimatePropagatorCost {
-    public:
-      EstimatePropagatorCost (SparseOptimizer* graph);
-      virtual double operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to_) const;
-      virtual const char* name() const { return "spanning tree";}
-    protected:
-      SparseOptimizer* _graph;
+  class EstimatePropagatorCost
+  {
+  public:
+    EstimatePropagatorCost(SparseOptimizer *graph);
+    virtual double operator()(OptimizableGraph::Edge *edge, const OptimizableGraph::VertexSet &from, OptimizableGraph::Vertex *to_) const;
+    virtual const char *name() const { return "spanning tree"; }
+
+  protected:
+    SparseOptimizer *_graph;
   };
 
   /**
@@ -62,113 +65,119 @@ namespace g2o {
    * Initialize your graph along odometry edges. An odometry edge is assumed to connect vertices
    * whose IDs only differs by one.
    */
-  class  EstimatePropagatorCostOdometry : public EstimatePropagatorCost {
-    public:
-      EstimatePropagatorCostOdometry(SparseOptimizer* graph);
-      virtual double operator()(OptimizableGraph::Edge* edge, const OptimizableGraph::VertexSet& from_, OptimizableGraph::Vertex* to_) const;
-      virtual const char* name() const { return "odometry";}
+  class EstimatePropagatorCostOdometry : public EstimatePropagatorCost
+  {
+  public:
+    EstimatePropagatorCostOdometry(SparseOptimizer *graph);
+    virtual double operator()(OptimizableGraph::Edge *edge, const OptimizableGraph::VertexSet &from_, OptimizableGraph::Vertex *to_) const;
+    virtual const char *name() const { return "odometry"; }
   };
 
   /**
    * \brief propagation of an initial guess
    */
-  class  EstimatePropagator {
+  class EstimatePropagator
+  {
+  public:
+    /**
+     * \brief Applying the action for propagating.
+     *
+     * You may derive an own one, if necessary. The default is to call initialEstimate(from, to) for the edge.
+     */
+    struct PropagateAction
+    {
+      virtual void operator()(OptimizableGraph::Edge *e, const OptimizableGraph::VertexSet &from, OptimizableGraph::Vertex *to) const
+      {
+        if (!to->fixed())
+          e->initialEstimate(from, to);
+      }
+    };
+
+    typedef EstimatePropagatorCost PropagateCost;
+
+    class AdjacencyMapEntry;
+
+    /**
+     * \brief priority queue for AdjacencyMapEntry
+     */
+    class PriorityQueue : public std::multimap<double, AdjacencyMapEntry *>
+    {
     public:
-
-      /**
-       * \brief Applying the action for propagating.
-       *
-       * You may derive an own one, if necessary. The default is to call initialEstimate(from, to) for the edge.
-       */
-      struct PropagateAction {
-        virtual void operator()(OptimizableGraph::Edge* e, const OptimizableGraph::VertexSet& from, OptimizableGraph::Vertex* to) const
-        {
-          if (! to->fixed())
-            e->initialEstimate(from, to);
-        }
-      };
-
-      typedef EstimatePropagatorCost PropagateCost;
-
-      class AdjacencyMapEntry;
-
-      /**
-       * \brief priority queue for AdjacencyMapEntry
-       */
-      class PriorityQueue : public std::multimap<double, AdjacencyMapEntry*> {
-        public:
-          void push(AdjacencyMapEntry* entry);
-          AdjacencyMapEntry* pop();
-      };
-
-      /**
-       * \brief data structure for loopuk during Dijkstra
-       */
-      class AdjacencyMapEntry {
-        public:
-          friend class EstimatePropagator;
-          friend class PriorityQueue;
-          AdjacencyMapEntry();
-          void reset();
-          OptimizableGraph::Vertex* child() const {return _child;}
-          const OptimizableGraph::VertexSet& parent() const {return _parent;}
-          OptimizableGraph::Edge* edge() const {return _edge;}
-          double distance() const {return _distance;}
-          int frontierLevel() const { return _frontierLevel;}
-
-        protected:
-          OptimizableGraph::Vertex* _child;
-          OptimizableGraph::VertexSet _parent;
-          OptimizableGraph::Edge* _edge;
-          double _distance;
-          int _frontierLevel;
-        private: // for PriorityQueue
-          bool inQueue;
-          PriorityQueue::iterator queueIt;
-      };
-
-      /**
-       * \brief hash function for a vertex
-       */
-      class VertexIDHashFunction {
-        public:
-          size_t operator ()(const OptimizableGraph::Vertex* v) const { return v->id();}
-      };
-
-      typedef std::tr1::unordered_map<OptimizableGraph::Vertex*, AdjacencyMapEntry, VertexIDHashFunction> AdjacencyMap;
-
+      void push(AdjacencyMapEntry *entry);
+      AdjacencyMapEntry *pop();
+    };
+
+    /**
+     * \brief data structure for loopuk during Dijkstra
+     */
+    class AdjacencyMapEntry
+    {
     public:
-      EstimatePropagator(OptimizableGraph* g);
-      OptimizableGraph::VertexSet& visited() {return _visited; }
-      AdjacencyMap& adjacencyMap() {return _adjacencyMap; }
-      OptimizableGraph* graph() {return _graph;} 
-
-      /**
-       * propagate an initial guess starting from v. The function computes a spanning tree
-       * whereas the cost for each edge is determined by calling cost() and the action applied to
-       * each vertex is action().
-       */
-      void propagate(OptimizableGraph::Vertex* v, 
-          const EstimatePropagator::PropagateCost& cost, 
-          const EstimatePropagator::PropagateAction& action = PropagateAction(),
-          double maxDistance=std::numeric_limits<double>::max(), 
-          double maxEdgeCost=std::numeric_limits<double>::max());
-
-      /**
-       * same as above but starting to propagate from a set of vertices instead of just a single one.
-       */
-      void propagate(OptimizableGraph::VertexSet& vset, 
-          const EstimatePropagator::PropagateCost& cost, 
-          const EstimatePropagator::PropagateAction& action = PropagateAction(),
-          double maxDistance=std::numeric_limits<double>::max(), 
-          double maxEdgeCost=std::numeric_limits<double>::max());
-
-    protected:
+      friend class EstimatePropagator;
+      friend class PriorityQueue;
+      AdjacencyMapEntry();
       void reset();
+      OptimizableGraph::Vertex *child() const { return _child; }
+      const OptimizableGraph::VertexSet &parent() const { return _parent; }
+      OptimizableGraph::Edge *edge() const { return _edge; }
+      double distance() const { return _distance; }
+      int frontierLevel() const { return _frontierLevel; }
 
-      AdjacencyMap _adjacencyMap;
-      OptimizableGraph::VertexSet _visited;
-      OptimizableGraph* _graph;
+    protected:
+      OptimizableGraph::Vertex *_child;
+      OptimizableGraph::VertexSet _parent;
+      OptimizableGraph::Edge *_edge;
+      double _distance;
+      int _frontierLevel;
+
+    private: // for PriorityQueue
+      bool inQueue;
+      PriorityQueue::iterator queueIt;
+    };
+
+    /**
+     * \brief hash function for a vertex
+     */
+    class VertexIDHashFunction
+    {
+    public:
+      size_t operator()(const OptimizableGraph::Vertex *v) const { return v->id(); }
+    };
+
+    typedef std::unordered_map<OptimizableGraph::Vertex *, AdjacencyMapEntry, VertexIDHashFunction> AdjacencyMap;
+
+  public:
+    EstimatePropagator(OptimizableGraph *g);
+    OptimizableGraph::VertexSet &visited() { return _visited; }
+    AdjacencyMap &adjacencyMap() { return _adjacencyMap; }
+    OptimizableGraph *graph() { return _graph; }
+
+    /**
+     * propagate an initial guess starting from v. The function computes a spanning tree
+     * whereas the cost for each edge is determined by calling cost() and the action applied to
+     * each vertex is action().
+     */
+    void propagate(OptimizableGraph::Vertex *v,
+                   const EstimatePropagator::PropagateCost &cost,
+                   const EstimatePropagator::PropagateAction &action = PropagateAction(),
+                   double maxDistance = std::numeric_limits<double>::max(),
+                   double maxEdgeCost = std::numeric_limits<double>::max());
+
+    /**
+     * same as above but starting to propagate from a set of vertices instead of just a single one.
+     */
+    void propagate(OptimizableGraph::VertexSet &vset,
+                   const EstimatePropagator::PropagateCost &cost,
+                   const EstimatePropagator::PropagateAction &action = PropagateAction(),
+                   double maxDistance = std::numeric_limits<double>::max(),
+                   double maxEdgeCost = std::numeric_limits<double>::max());
+
+  protected:
+    void reset();
+
+    AdjacencyMap _adjacencyMap;
+    OptimizableGraph::VertexSet _visited;
+    OptimizableGraph *_graph;
   };
 
 }
diff --git a/Thirdparty/g2o/g2o/core/hyper_dijkstra.cpp b/Thirdparty/g2o/g2o/core/hyper_dijkstra.cpp
index 935e3db..104e4a8 100644
--- a/Thirdparty/g2o/g2o/core/hyper_dijkstra.cpp
+++ b/Thirdparty/g2o/g2o/core/hyper_dijkstra.cpp
@@ -30,41 +30,48 @@
 #include <iostream>
 #include "hyper_dijkstra.h"
 
-namespace g2o {
+namespace g2o
+{
 
-
-    double HyperDijkstra::TreeAction::perform(HyperGraph::Vertex *v, HyperGraph::Vertex *vParent, HyperGraph::Edge *e) {
-        (void) v;
-        (void) vParent;
-        (void) e;
+    double HyperDijkstra::TreeAction::perform(HyperGraph::Vertex *v, HyperGraph::Vertex *vParent, HyperGraph::Edge *e)
+    {
+        (void)v;
+        (void)vParent;
+        (void)e;
         return std::numeric_limits<double>::max();
     }
 
     double HyperDijkstra::TreeAction::perform(HyperGraph::Vertex *v, HyperGraph::Vertex *vParent, HyperGraph::Edge *e,
-                                              double distance) {
+                                              double distance)
+    {
         if (distance == -1)
             return perform(v, vParent, e);
         return std::numeric_limits<double>::max();
     }
 
     HyperDijkstra::AdjacencyMapEntry::AdjacencyMapEntry(HyperGraph::Vertex *child_, HyperGraph::Vertex *parent_,
-                                                        HyperGraph::Edge *edge_, double distance_) {
+                                                        HyperGraph::Edge *edge_, double distance_)
+    {
         _child = child_;
         _parent = parent_;
         _edge = edge_;
         _distance = distance_;
     }
 
-    HyperDijkstra::HyperDijkstra(HyperGraph *g) : _graph(g) {
+    HyperDijkstra::HyperDijkstra(HyperGraph *g) : _graph(g)
+    {
         for (HyperGraph::VertexIDMap::const_iterator it = _graph->vertices().begin();
-             it != _graph->vertices().end(); it++) {
+             it != _graph->vertices().end(); it++)
+        {
             AdjacencyMapEntry entry(it->second, 0, 0, std::numeric_limits<double>::max());
             _adjacencyMap.insert(std::make_pair(entry.child(), entry));
         }
     }
 
-    void HyperDijkstra::reset() {
-        for (HyperGraph::VertexSet::iterator it = _visited.begin(); it != _visited.end(); it++) {
+    void HyperDijkstra::reset()
+    {
+        for (HyperGraph::VertexSet::iterator it = _visited.begin(); it != _visited.end(); it++)
+        {
             AdjacencyMap::iterator at = _adjacencyMap.find(*it);
             assert(at != _adjacencyMap.end());
             at->second = AdjacencyMapEntry(at->first, 0, 0, std::numeric_limits<double>::max());
@@ -72,23 +79,25 @@ namespace g2o {
         _visited.clear();
     }
 
-
-    bool operator<(const HyperDijkstra::AdjacencyMapEntry &a, const HyperDijkstra::AdjacencyMapEntry &b) {
+    bool operator<(const HyperDijkstra::AdjacencyMapEntry &a, const HyperDijkstra::AdjacencyMapEntry &b)
+    {
         return a.distance() > b.distance();
     }
 
-
     void HyperDijkstra::shortestPaths(HyperGraph::VertexSet &vset, HyperDijkstra::CostFunction *cost,
                                       double maxDistance, double comparisonConditioner, bool directed,
-                                      double maxEdgeCost) {
+                                      double maxEdgeCost)
+    {
         reset();
         std::priority_queue<AdjacencyMapEntry> frontier;
-        for (HyperGraph::VertexSet::iterator vit = vset.begin(); vit != vset.end(); ++vit) {
+        for (HyperGraph::VertexSet::iterator vit = vset.begin(); vit != vset.end(); ++vit)
+        {
             HyperGraph::Vertex *v = *vit;
             assert(v != 0);
             AdjacencyMap::iterator it = _adjacencyMap.find(v);
-            if (it == _adjacencyMap.end()) {
-                std::cerr << __PRETTY_FUNCTION__ << "Vertex " << v->id() << " is not in the adjacency map" << std::endl;
+            if (it == _adjacencyMap.end())
+            {
+                std::cerr << "shortestPaths " << "Vertex " << v->id() << " is not in the adjacency map" << std::endl;
             }
             assert(it != _adjacencyMap.end());
             it->second._distance = 0.;
@@ -96,28 +105,32 @@ namespace g2o {
             frontier.push(it->second);
         }
 
-        while (!frontier.empty()) {
+        while (!frontier.empty())
+        {
             AdjacencyMapEntry entry = frontier.top();
             frontier.pop();
             HyperGraph::Vertex *u = entry.child();
             AdjacencyMap::iterator ut = _adjacencyMap.find(u);
-            if (ut == _adjacencyMap.end()) {
-                std::cerr << __PRETTY_FUNCTION__ << "Vertex " << u->id() << " is not in the adjacency map" << std::endl;
+            if (ut == _adjacencyMap.end())
+            {
+                std::cerr << "shortestPaths "<< "Vertex " << u->id() << " is not in the adjacency map" << std::endl;
             }
             assert(ut != _adjacencyMap.end());
             double uDistance = ut->second.distance();
 
             std::pair<HyperGraph::VertexSet::iterator, bool> insertResult = _visited.insert(u);
-            (void) insertResult;
+            (void)insertResult;
             HyperGraph::EdgeSet::iterator et = u->edges().begin();
-            while (et != u->edges().end()) {
+            while (et != u->edges().end())
+            {
                 HyperGraph::Edge *edge = *et;
                 ++et;
 
                 if (directed && edge->vertex(0) != u)
                     continue;
 
-                for (size_t i = 0; i < edge->vertices().size(); ++i) {
+                for (size_t i = 0; i < edge->vertices().size(); ++i)
+                {
                     HyperGraph::Vertex *z = edge->vertex(i);
                     if (z == u)
                         continue;
@@ -126,12 +139,13 @@ namespace g2o {
                     if (edgeDistance == std::numeric_limits<double>::max() || edgeDistance > maxEdgeCost)
                         continue;
                     double zDistance = uDistance + edgeDistance;
-                    //cerr << z->id() << " " << zDistance << endl;
+                    // cerr << z->id() << " " << zDistance << endl;
 
                     AdjacencyMap::iterator ot = _adjacencyMap.find(z);
                     assert(ot != _adjacencyMap.end());
 
-                    if (zDistance + comparisonConditioner < ot->second.distance() && zDistance < maxDistance) {
+                    if (zDistance + comparisonConditioner < ot->second.distance() && zDistance < maxDistance)
+                    {
                         ot->second._distance = zDistance;
                         ot->second._parent = u;
                         ot->second._edge = edge;
@@ -143,25 +157,30 @@ namespace g2o {
     }
 
     void HyperDijkstra::shortestPaths(HyperGraph::Vertex *v, HyperDijkstra::CostFunction *cost, double maxDistance,
-                                      double comparisonConditioner, bool directed, double maxEdgeCost) {
+                                      double comparisonConditioner, bool directed, double maxEdgeCost)
+    {
         HyperGraph::VertexSet vset;
         vset.insert(v);
         shortestPaths(vset, cost, maxDistance, comparisonConditioner, directed, maxEdgeCost);
     }
 
-    void HyperDijkstra::computeTree(AdjacencyMap &amap) {
-        for (AdjacencyMap::iterator it = amap.begin(); it != amap.end(); ++it) {
+    void HyperDijkstra::computeTree(AdjacencyMap &amap)
+    {
+        for (AdjacencyMap::iterator it = amap.begin(); it != amap.end(); ++it)
+        {
             AdjacencyMapEntry &entry(it->second);
             entry._children.clear();
         }
-        for (AdjacencyMap::iterator it = amap.begin(); it != amap.end(); ++it) {
+        for (AdjacencyMap::iterator it = amap.begin(); it != amap.end(); ++it)
+        {
             AdjacencyMapEntry &entry(it->second);
             HyperGraph::Vertex *parent = entry.parent();
-            if (!parent) {
+            if (!parent)
+            {
                 continue;
             }
             HyperGraph::Vertex *v = entry.child();
-            assert (v == it->first);
+            assert(v == it->first);
 
             AdjacencyMap::iterator pt = amap.find(parent);
             assert(pt != amap.end());
@@ -169,59 +188,67 @@ namespace g2o {
         }
     }
 
-
-    void HyperDijkstra::visitAdjacencyMap(AdjacencyMap &amap, TreeAction *action, bool useDistance) {
+    void HyperDijkstra::visitAdjacencyMap(AdjacencyMap &amap, TreeAction *action, bool useDistance)
+    {
 
         typedef std::deque<HyperGraph::Vertex *> Deque;
         Deque q;
         // scans for the vertices without the parent (whcih are the roots of the trees) and applies the action to them.
-        for (AdjacencyMap::iterator it = amap.begin(); it != amap.end(); ++it) {
+        for (AdjacencyMap::iterator it = amap.begin(); it != amap.end(); ++it)
+        {
             AdjacencyMapEntry &entry(it->second);
-            if (!entry.parent()) {
+            if (!entry.parent())
+            {
                 action->perform(it->first, 0, 0);
                 q.push_back(it->first);
             }
         }
 
-        //std::cerr << "q.size()" << q.size() << endl;
+        // std::cerr << "q.size()" << q.size() << endl;
         int count = 0;
-        while (!q.empty()) {
+        while (!q.empty())
+        {
             HyperGraph::Vertex *parent = q.front();
             q.pop_front();
             ++count;
             AdjacencyMap::iterator parentIt = amap.find(parent);
-            if (parentIt == amap.end()) {
+            if (parentIt == amap.end())
+            {
                 continue;
             }
-            //cerr << "parent= " << parent << " parent id= " << parent->id() << "\t children id =";
+            // cerr << "parent= " << parent << " parent id= " << parent->id() << "\t children id =";
             HyperGraph::VertexSet &childs(parentIt->second.children());
-            for (HyperGraph::VertexSet::iterator childsIt = childs.begin(); childsIt != childs.end(); ++childsIt) {
+            for (HyperGraph::VertexSet::iterator childsIt = childs.begin(); childsIt != childs.end(); ++childsIt)
+            {
                 HyperGraph::Vertex *child = *childsIt;
-                //cerr << child->id();
+                // cerr << child->id();
                 AdjacencyMap::iterator adjacencyIt = amap.find(child);
-                assert (adjacencyIt != amap.end());
+                assert(adjacencyIt != amap.end());
                 HyperGraph::Edge *edge = adjacencyIt->second.edge();
 
                 assert(adjacencyIt->first == child);
                 assert(adjacencyIt->second.child() == child);
                 assert(adjacencyIt->second.parent() == parent);
-                if (!useDistance) {
+                if (!useDistance)
+                {
                     action->perform(child, parent, edge);
-                } else {
+                }
+                else
+                {
                     action->perform(child, parent, edge, adjacencyIt->second.distance());
                 }
                 q.push_back(child);
             }
-            //cerr << endl;
+            // cerr << endl;
         }
-
     }
 
     void HyperDijkstra::connectedSubset(HyperGraph::VertexSet &connected, HyperGraph::VertexSet &visited,
                                         HyperGraph::VertexSet &startingSet,
                                         HyperGraph *g, HyperGraph::Vertex *v,
                                         HyperDijkstra::CostFunction *cost, double distance,
-                                        double comparisonConditioner, double maxEdgeCost) {
+                                        double comparisonConditioner, double maxEdgeCost)
+    {
         typedef std::queue<HyperGraph::Vertex *> VertexDeque;
         visited.clear();
         connected.clear();
@@ -229,16 +256,19 @@ namespace g2o {
         HyperDijkstra dv(g);
         connected.insert(v);
         frontier.push(v);
-        while (!frontier.empty()) {
+        while (!frontier.empty())
+        {
             HyperGraph::Vertex *v0 = frontier.front();
             frontier.pop();
             dv.shortestPaths(v0, cost, distance, comparisonConditioner, false, maxEdgeCost);
-            for (HyperGraph::VertexSet::iterator it = dv.visited().begin(); it != dv.visited().end(); ++it) {
+            for (HyperGraph::VertexSet::iterator it = dv.visited().begin(); it != dv.visited().end(); ++it)
+            {
                 visited.insert(*it);
                 if (startingSet.find(*it) == startingSet.end())
                     continue;
                 std::pair<HyperGraph::VertexSet::iterator, bool> insertOutcome = connected.insert(*it);
-                if (insertOutcome.second) { // the node was not in the connectedSet;
+                if (insertOutcome.second)
+                { // the node was not in the connectedSet;
                     frontier.push(dynamic_cast<HyperGraph::Vertex *>(*it));
                 }
             }
@@ -246,7 +276,8 @@ namespace g2o {
     }
 
     double UniformCostFunction::operator()(HyperGraph::Edge * /*edge*/, HyperGraph::Vertex * /*from*/,
-                                           HyperGraph::Vertex * /*to*/) {
+                                           HyperGraph::Vertex * /*to*/)
+    {
         return 1.;
     }
 
diff --git a/Thirdparty/g2o/g2o/core/hyper_graph.h b/Thirdparty/g2o/g2o/core/hyper_graph.h
index da6bb3d..97d7150 100644
--- a/Thirdparty/g2o/g2o/core/hyper_graph.h
+++ b/Thirdparty/g2o/g2o/core/hyper_graph.h
@@ -34,17 +34,12 @@
 #include <vector>
 #include <limits>
 #include <cstddef>
-
-#ifdef _MSC_VER
 #include <unordered_map>
-#else
-#include <tr1/unordered_map>
-#endif
-
 
 /** @addtogroup graph */
 //@{
-namespace g2o {
+namespace g2o
+{
 
   /**
      Class that models a directed  Hyper-Graph. An hyper graph is a graph where an edge
@@ -53,164 +48,181 @@ namespace g2o {
      that operate transparently on edges or vertices (see HyperGraphAction).
 
      The vertices are uniquely identified by an int id, while the edges are
-     identfied by their pointers. 
+     identfied by their pointers.
    */
-  class  HyperGraph
+  class HyperGraph
   {
-    public:
-
-      /**
-       * \brief enum of all the types we have in our graphs
-       */
-      enum  HyperGraphElementType {
-        HGET_VERTEX,
-        HGET_EDGE,
-        HGET_PARAMETER,
-        HGET_CACHE,
-        HGET_DATA,
-        HGET_NUM_ELEMS // keep as last elem
-      };
-
-      typedef std::bitset<HyperGraph::HGET_NUM_ELEMS> GraphElemBitset;
-
-      class  Vertex;
-      class  Edge;
-      
+  public:
+    /**
+     * \brief enum of all the types we have in our graphs
+     */
+    enum HyperGraphElementType
+    {
+      HGET_VERTEX,
+      HGET_EDGE,
+      HGET_PARAMETER,
+      HGET_CACHE,
+      HGET_DATA,
+      HGET_NUM_ELEMS // keep as last elem
+    };
+
+    typedef std::bitset<HyperGraph::HGET_NUM_ELEMS> GraphElemBitset;
+
+    class Vertex;
+    class Edge;
+
+    /**
+     * base hyper graph element, specialized in vertex and edge
+     */
+    struct HyperGraphElement
+    {
+      virtual ~HyperGraphElement() {}
       /**
-       * base hyper graph element, specialized in vertex and edge
-       */
-      struct  HyperGraphElement {
-        virtual ~HyperGraphElement() {}
-        /**
-         * returns the type of the graph element, see HyperGraphElementType
-         */
-        virtual HyperGraphElementType elementType() const = 0;
-      };
-
-      typedef std::set<Edge*>                           EdgeSet;
-      typedef std::set<Vertex*>                         VertexSet;
-
-      typedef std::tr1::unordered_map<int, Vertex*>     VertexIDMap;
-      typedef std::vector<Vertex*>                      VertexContainer;
-
-      //! abstract Vertex, your types must derive from that one
-      class  Vertex : public HyperGraphElement {
-        public:
-          //! creates a vertex having an ID specified by the argument
-          explicit Vertex(int id=-1);
-          virtual ~Vertex();
-          //! returns the id
-          int id() const {return _id;}
-	  virtual void setId( int newId) { _id=newId; }
-          //! returns the set of hyper-edges that are leaving/entering in this vertex
-          const EdgeSet& edges() const {return _edges;}
-          //! returns the set of hyper-edges that are leaving/entering in this vertex
-          EdgeSet& edges() {return _edges;}
-          virtual HyperGraphElementType elementType() const { return HGET_VERTEX;}
-        protected:
-          int _id;
-          EdgeSet _edges;
-      };
-
-      /** 
-       * Abstract Edge class. Your nice edge classes should inherit from that one.
-       * An hyper-edge has pointers to the vertices it connects and stores them in a vector.
+       * returns the type of the graph element, see HyperGraphElementType
        */
-      class  Edge : public HyperGraphElement {
-        public:
-          //! creates and empty edge with no vertices
-          explicit Edge(int id = -1);
-          virtual ~Edge();
-
-          /**
-           * resizes the number of vertices connected by this edge
-           */
-          virtual void resize(size_t size);
-          /**
-            returns the vector of pointers to the vertices connected by the hyper-edge.
-            */
-          const VertexContainer& vertices() const { return _vertices;}
-          /**
-            returns the vector of pointers to the vertices connected by the hyper-edge.
-            */
-          VertexContainer& vertices() { return _vertices;}
-          /**
-            returns the pointer to the ith vertex connected to the hyper-edge.
-            */
-          const Vertex* vertex(size_t i) const { assert(i < _vertices.size() && "index out of bounds"); return _vertices[i];}
-          /**
-            returns the pointer to the ith vertex connected to the hyper-edge.
-            */
-          Vertex* vertex(size_t i) { assert(i < _vertices.size() && "index out of bounds"); return _vertices[i];}
-          /**
-            set the ith vertex on the hyper-edge to the pointer supplied
-            */
-          void setVertex(size_t i, Vertex* v) { assert(i < _vertices.size() && "index out of bounds"); _vertices[i]=v;}
-
-          int id() const {return _id;}
-          void setId(int id);
-          virtual HyperGraphElementType elementType() const { return HGET_EDGE;}
-        protected:
-          VertexContainer _vertices;
-          int _id; ///< unique id
-      };
+      virtual HyperGraphElementType elementType() const = 0;
+    };
+
+    typedef std::set<Edge *> EdgeSet;
+    typedef std::set<Vertex *> VertexSet;
 
+    typedef std::unordered_map<int, Vertex *> VertexIDMap;
+    typedef std::vector<Vertex *> VertexContainer;
+
+    //! abstract Vertex, your types must derive from that one
+    class Vertex : public HyperGraphElement
+    {
     public:
-      //! constructs an empty hyper graph
-      HyperGraph();
-      //! destroys the hyper-graph and all the vertices of the graph
-      virtual ~HyperGraph();
-
-      //! returns a vertex <i>id</i> in the hyper-graph, or 0 if the vertex id is not present
-      Vertex* vertex(int id);
-      //! returns a vertex <i>id</i> in the hyper-graph, or 0 if the vertex id is not present
-      const Vertex* vertex(int id) const;
-
-      //! removes a vertex from the graph. Returns true on success (vertex was present)
-      virtual bool removeVertex(Vertex* v);
-      //! removes a vertex from the graph. Returns true on success (edge was present)
-      virtual bool removeEdge(Edge* e);
-      //! clears the graph and empties all structures.
-      virtual void clear();
-
-      //! @returns the map <i>id -> vertex</i> where the vertices are stored
-      const VertexIDMap& vertices() const {return _vertices;}
-      //! @returns the map <i>id -> vertex</i> where the vertices are stored
-      VertexIDMap& vertices() {return _vertices;}
-
-      //! @returns the set of edges of the hyper graph
-      const EdgeSet& edges() const {return _edges;}
-      //! @returns the set of edges of the hyper graph
-      EdgeSet& edges() {return _edges;}
+      //! creates a vertex having an ID specified by the argument
+      explicit Vertex(int id = -1);
+      virtual ~Vertex();
+      //! returns the id
+      int id() const { return _id; }
+      virtual void setId(int newId) { _id = newId; }
+      //! returns the set of hyper-edges that are leaving/entering in this vertex
+      const EdgeSet &edges() const { return _edges; }
+      //! returns the set of hyper-edges that are leaving/entering in this vertex
+      EdgeSet &edges() { return _edges; }
+      virtual HyperGraphElementType elementType() const { return HGET_VERTEX; }
 
-      /**
-       * adds a vertex to the graph. The id of the vertex should be set before
-       * invoking this function. the function fails if another vertex
-       * with the same id is already in the graph.
-       * returns true, on success, or false on failure.
-       */
-      virtual bool addVertex(Vertex* v);
+    protected:
+      int _id;
+      EdgeSet _edges;
+    };
+
+    /**
+     * Abstract Edge class. Your nice edge classes should inherit from that one.
+     * An hyper-edge has pointers to the vertices it connects and stores them in a vector.
+     */
+    class Edge : public HyperGraphElement
+    {
+    public:
+      //! creates and empty edge with no vertices
+      explicit Edge(int id = -1);
+      virtual ~Edge();
 
       /**
-       * Adds an edge  to the graph. If the edge is already in the graph, it
-       * does nothing and returns false. Otherwise it returns true.
+       * resizes the number of vertices connected by this edge
        */
-      virtual bool addEdge(Edge* e);
-
+      virtual void resize(size_t size);
       /**
-       * changes the id of a vertex already in the graph, and updates the bookkeeping
-       @ returns false if the vertex is not in the graph;
-       */
-      virtual bool changeId(Vertex* v, int newId);
+        returns the vector of pointers to the vertices connected by the hyper-edge.
+        */
+      const VertexContainer &vertices() const { return _vertices; }
+      /**
+        returns the vector of pointers to the vertices connected by the hyper-edge.
+        */
+      VertexContainer &vertices() { return _vertices; }
+      /**
+        returns the pointer to the ith vertex connected to the hyper-edge.
+        */
+      const Vertex *vertex(size_t i) const
+      {
+        assert(i < _vertices.size() && "index out of bounds");
+        return _vertices[i];
+      }
+      /**
+        returns the pointer to the ith vertex connected to the hyper-edge.
+        */
+      Vertex *vertex(size_t i)
+      {
+        assert(i < _vertices.size() && "index out of bounds");
+        return _vertices[i];
+      }
+      /**
+        set the ith vertex on the hyper-edge to the pointer supplied
+        */
+      void setVertex(size_t i, Vertex *v)
+      {
+        assert(i < _vertices.size() && "index out of bounds");
+        _vertices[i] = v;
+      }
+
+      int id() const { return _id; }
+      void setId(int id);
+      virtual HyperGraphElementType elementType() const { return HGET_EDGE; }
 
     protected:
-      VertexIDMap _vertices;
-      EdgeSet _edges;
-
-    private:
-      // Disable the copy constructor and assignment operator
-      HyperGraph(const HyperGraph&) { }
-      HyperGraph& operator= (const HyperGraph&) { return *this; }
+      VertexContainer _vertices;
+      int _id; ///< unique id
+    };
+
+  public:
+    //! constructs an empty hyper graph
+    HyperGraph();
+    //! destroys the hyper-graph and all the vertices of the graph
+    virtual ~HyperGraph();
+
+    //! returns a vertex <i>id</i> in the hyper-graph, or 0 if the vertex id is not present
+    Vertex *vertex(int id);
+    //! returns a vertex <i>id</i> in the hyper-graph, or 0 if the vertex id is not present
+    const Vertex *vertex(int id) const;
+
+    //! removes a vertex from the graph. Returns true on success (vertex was present)
+    virtual bool removeVertex(Vertex *v);
+    //! removes a vertex from the graph. Returns true on success (edge was present)
+    virtual bool removeEdge(Edge *e);
+    //! clears the graph and empties all structures.
+    virtual void clear();
+
+    //! @returns the map <i>id -> vertex</i> where the vertices are stored
+    const VertexIDMap &vertices() const { return _vertices; }
+    //! @returns the map <i>id -> vertex</i> where the vertices are stored
+    VertexIDMap &vertices() { return _vertices; }
+
+    //! @returns the set of edges of the hyper graph
+    const EdgeSet &edges() const { return _edges; }
+    //! @returns the set of edges of the hyper graph
+    EdgeSet &edges() { return _edges; }
+
+    /**
+     * adds a vertex to the graph. The id of the vertex should be set before
+     * invoking this function. the function fails if another vertex
+     * with the same id is already in the graph.
+     * returns true, on success, or false on failure.
+     */
+    virtual bool addVertex(Vertex *v);
+
+    /**
+     * Adds an edge  to the graph. If the edge is already in the graph, it
+     * does nothing and returns false. Otherwise it returns true.
+     */
+    virtual bool addEdge(Edge *e);
+
+    /**
+     * changes the id of a vertex already in the graph, and updates the bookkeeping
+     @ returns false if the vertex is not in the graph;
+     */
+    virtual bool changeId(Vertex *v, int newId);
+
+  protected:
+    VertexIDMap _vertices;
+    EdgeSet _edges;
+
+  private:
+    // Disable the copy constructor and assignment operator
+    HyperGraph(const HyperGraph &) {}
+    HyperGraph &operator=(const HyperGraph &) { return *this; }
   };
 
 } // end namespace
diff --git a/Thirdparty/g2o/g2o/core/jacobian_workspace.h b/Thirdparty/g2o/g2o/core/jacobian_workspace.h
index abea594..5eed418 100644
--- a/Thirdparty/g2o/g2o/core/jacobian_workspace.h
+++ b/Thirdparty/g2o/g2o/core/jacobian_workspace.h
@@ -27,15 +27,16 @@
 #ifndef JACOBIAN_WORKSPACE_H
 #define JACOBIAN_WORKSPACE_H
 
-#include <eigen3/Eigen/Dense>
-#include <eigen3/Eigen/StdVector>
+#include <Eigen/Dense>
+#include <Eigen/StdVector>
 
 #include <vector>
 #include <cassert>
 
 #include "hyper_graph.h"
 
-namespace g2o {
+namespace g2o
+{
 
   struct OptimizableGraph;
 
@@ -47,48 +48,48 @@ namespace g2o {
    * Before calling linearizeOplus on an edge, the workspace needs to be allocated
    * by calling allocate().
    */
-  class  JacobianWorkspace
+  class JacobianWorkspace
   {
-    public:
-      typedef std::vector<Eigen::VectorXd, Eigen::aligned_allocator<Eigen::VectorXd> >      WorkspaceVector;
-
-    public:
-      JacobianWorkspace();
-      ~JacobianWorkspace();
-
-      /**
-       * allocate the workspace
-       */
-      bool allocate();
-
-      /**
-       * update the maximum required workspace needed by taking into account this edge
-       */
-      void updateSize(const HyperGraph::Edge* e);
-
-      /**
-       * update the required workspace by looking at a full graph
-       */
-      void updateSize(const OptimizableGraph& graph);
-
-      /**
-       * manually update with the given parameters
-       */
-      void updateSize(int numVertices, int dimension);
-
-      /**
-       * return the workspace for a vertex in an edge
-       */
-      double* workspaceForVertex(int vertexIndex)
-      {
-        assert(vertexIndex >= 0 && (size_t)vertexIndex < _workspace.size() && "Index out of bounds");
-        return _workspace[vertexIndex].data();
-      }
-
-    protected:
-      WorkspaceVector _workspace;   ///< the memory pre-allocated for computing the Jacobians
-      int _maxNumVertices;          ///< the maximum number of vertices connected by a hyper-edge
-      int _maxDimension;            ///< the maximum dimension (number of elements) for a Jacobian
+  public:
+    typedef std::vector<Eigen::VectorXd, Eigen::aligned_allocator<Eigen::VectorXd>> WorkspaceVector;
+
+  public:
+    JacobianWorkspace();
+    ~JacobianWorkspace();
+
+    /**
+     * allocate the workspace
+     */
+    bool allocate();
+
+    /**
+     * update the maximum required workspace needed by taking into account this edge
+     */
+    void updateSize(const HyperGraph::Edge *e);
+
+    /**
+     * update the required workspace by looking at a full graph
+     */
+    void updateSize(const OptimizableGraph &graph);
+
+    /**
+     * manually update with the given parameters
+     */
+    void updateSize(int numVertices, int dimension);
+
+    /**
+     * return the workspace for a vertex in an edge
+     */
+    double *workspaceForVertex(int vertexIndex)
+    {
+      assert(vertexIndex >= 0 && (size_t)vertexIndex < _workspace.size() && "Index out of bounds");
+      return _workspace[vertexIndex].data();
+    }
+
+  protected:
+    WorkspaceVector _workspace; ///< the memory pre-allocated for computing the Jacobians
+    int _maxNumVertices;        ///< the maximum number of vertices connected by a hyper-edge
+    int _maxDimension;          ///< the maximum dimension (number of elements) for a Jacobian
   };
 
 } // end namespace
diff --git a/Thirdparty/g2o/g2o/core/marginal_covariance_cholesky.h b/Thirdparty/g2o/g2o/core/marginal_covariance_cholesky.h
index e7dfce8..9d6972f 100644
--- a/Thirdparty/g2o/g2o/core/marginal_covariance_cholesky.h
+++ b/Thirdparty/g2o/g2o/core/marginal_covariance_cholesky.h
@@ -39,63 +39,65 @@
 #include <tr1/unordered_map>
 #endif
 
-
-namespace g2o {
+namespace g2o
+{
 
   /**
    * \brief computing the marginal covariance given a cholesky factor (lower triangle of the factor)
    */
-  class  MarginalCovarianceCholesky {
-    protected:
-      /**
-       * hash struct for storing the matrix elements needed to compute the covariance
-       */
-      typedef std::tr1::unordered_map<int, double>     LookupMap;
-    
-    public:
-      MarginalCovarianceCholesky();
-      ~MarginalCovarianceCholesky();
-
-      /**
-       * compute the marginal cov for the given block indices, write the result to the covBlocks memory (which has to
-       * be provided by the caller).
-       */
-      void computeCovariance(double** covBlocks, const std::vector<int>& blockIndices);
-
-
-      /**
-       * compute the marginal cov for the given block indices, write the result in spinv).
-       */
-      void computeCovariance(SparseBlockMatrix<MatrixXd>& spinv, const std::vector<int>& rowBlockIndices, const std::vector< std::pair<int, int> >& blockIndices);
-
-
-      /**
-       * set the CCS representation of the cholesky factor along with the inverse permutation used to reduce the fill-in.
-       * permInv might be 0, will then not permute the entries.
-       *
-       * The pointers provided by the user need to be still valid when calling computeCovariance(). The pointers
-       * are owned by the caller, MarginalCovarianceCholesky does not free the pointers.
-       */
-      void setCholeskyFactor(int n, int* Lp, int* Li, double* Lx, int* permInv);
-
-    protected:
-      // information about the cholesky factor (lower triangle)
-      int _n;           ///< L is an n X n matrix
-      int* _Ap;         ///< column pointer of the CCS storage
-      int* _Ai;         ///< row indices of the CCS storage
-      double* _Ax;      ///< values of the cholesky factor
-      int* _perm;       ///< permutation of the cholesky factor. Variable re-ordering for better fill-in
-
-      LookupMap _map;             ///< hash look up table for the already computed entries
-      std::vector<double> _diag;  ///< cache 1 / H_ii to avoid recalculations
-
-      //! compute the index used for hashing
-      int computeIndex(int r, int c) const { /*assert(r <= c);*/ return r*_n + c;}
-      /**
-       * compute one entry in the covariance, r and c are values after applying the permutation, and upper triangular.
-       * May issue recursive calls to itself to compute the missing values.
-       */
-      double computeEntry(int r, int c);
+  class MarginalCovarianceCholesky
+  {
+  protected:
+    /**
+     * hash struct for storing the matrix elements needed to compute the covariance
+     */
+    typedef std::unordered_map<int, double> LookupMap;
+
+  public:
+    MarginalCovarianceCholesky();
+    ~MarginalCovarianceCholesky();
+
+    /**
+     * compute the marginal cov for the given block indices, write the result to the covBlocks memory (which has to
+     * be provided by the caller).
+     */
+    void computeCovariance(double **covBlocks, const std::vector<int> &blockIndices);
+
+    /**
+     * compute the marginal cov for the given block indices, write the result in spinv).
+     */
+    void computeCovariance(SparseBlockMatrix<MatrixXd> &spinv, const std::vector<int> &rowBlockIndices, const std::vector<std::pair<int, int>> &blockIndices);
+
+    /**
+     * set the CCS representation of the cholesky factor along with the inverse permutation used to reduce the fill-in.
+     * permInv might be 0, will then not permute the entries.
+     *
+     * The pointers provided by the user need to be still valid when calling computeCovariance(). The pointers
+     * are owned by the caller, MarginalCovarianceCholesky does not free the pointers.
+     */
+    void setCholeskyFactor(int n, int *Lp, int *Li, double *Lx, int *permInv);
+
+  protected:
+    // information about the cholesky factor (lower triangle)
+    int _n;      ///< L is an n X n matrix
+    int *_Ap;    ///< column pointer of the CCS storage
+    int *_Ai;    ///< row indices of the CCS storage
+    double *_Ax; ///< values of the cholesky factor
+    int *_perm;  ///< permutation of the cholesky factor. Variable re-ordering for better fill-in
+
+    LookupMap _map;            ///< hash look up table for the already computed entries
+    std::vector<double> _diag; ///< cache 1 / H_ii to avoid recalculations
+
+    //! compute the index used for hashing
+    int computeIndex(int r, int c) const
+    { /*assert(r <= c);*/
+      return r * _n + c;
+    }
+    /**
+     * compute one entry in the covariance, r and c are values after applying the permutation, and upper triangular.
+     * May issue recursive calls to itself to compute the missing values.
+     */
+    double computeEntry(int r, int c);
   };
 
 }
diff --git a/Thirdparty/g2o/g2o/core/robust_kernel.h b/Thirdparty/g2o/g2o/core/robust_kernel.h
index 06486de..d297fd3 100644
--- a/Thirdparty/g2o/g2o/core/robust_kernel.h
+++ b/Thirdparty/g2o/g2o/core/robust_kernel.h
@@ -32,10 +32,10 @@
 #else
 #include <tr1/memory>
 #endif
-#include <eigen3/Eigen/Core>
+#include <Eigen/Core>
 
-
-namespace g2o {
+namespace g2o
+{
 
   /**
    * \brief base for all robust cost functions
@@ -48,33 +48,33 @@ namespace g2o {
    *
    * chi^2 = sum_{e} rho( e^T Omega e )
    */
-  class  RobustKernel
+  class RobustKernel
   {
-    public:
-      RobustKernel();
-      explicit RobustKernel(double delta);
-      virtual ~RobustKernel() {}
-      /**
-       * compute the scaling factor for a error:
-       * The error is e^T Omega e
-       * The output rho is
-       * rho[0]: The actual scaled error value
-       * rho[1]: First derivative of the scaling function
-       * rho[2]: Second derivative of the scaling function
-       */
-      virtual void robustify(double squaredError, Eigen::Vector3d& rho) const = 0;
+  public:
+    RobustKernel();
+    explicit RobustKernel(double delta);
+    virtual ~RobustKernel() {}
+    /**
+     * compute the scaling factor for a error:
+     * The error is e^T Omega e
+     * The output rho is
+     * rho[0]: The actual scaled error value
+     * rho[1]: First derivative of the scaling function
+     * rho[2]: Second derivative of the scaling function
+     */
+    virtual void robustify(double squaredError, Eigen::Vector3d &rho) const = 0;
 
-      /**
-       * set the window size of the error. A squared error above delta^2 is considered
-       * as outlier in the data.
-       */
-      virtual void setDelta(double delta);
-      double delta() const { return _delta;}
+    /**
+     * set the window size of the error. A squared error above delta^2 is considered
+     * as outlier in the data.
+     */
+    virtual void setDelta(double delta);
+    double delta() const { return _delta; }
 
-    protected:
-      double _delta;
+  protected:
+    double _delta;
   };
-  typedef std::tr1::shared_ptr<RobustKernel> RobustKernelPtr;
+  typedef std::shared_ptr<RobustKernel> RobustKernelPtr;
 
 } // end namespace g2o
 
diff --git a/Thirdparty/g2o/g2o/core/sparse_block_matrix_ccs.h b/Thirdparty/g2o/g2o/core/sparse_block_matrix_ccs.h
index eb9042c..011a37d 100644
--- a/Thirdparty/g2o/g2o/core/sparse_block_matrix_ccs.h
+++ b/Thirdparty/g2o/g2o/core/sparse_block_matrix_ccs.h
@@ -40,7 +40,8 @@
 #include <tr1/unordered_map>
 #endif
 
-namespace g2o {
+namespace g2o
+{
 
   /**
    * \brief Sparse matrix which uses blocks
@@ -52,231 +53,240 @@ namespace g2o {
   template <class MatrixType>
   class SparseBlockMatrixCCS
   {
-    public:
-      //! this is the type of the elementary block, it is an Eigen::Matrix.
-      typedef MatrixType SparseMatrixBlock;
-
-      //! columns of the matrix
-      int cols() const {return _colBlockIndices.size() ? _colBlockIndices.back() : 0;}
-      //! rows of the matrix
-      int rows() const {return _rowBlockIndices.size() ? _rowBlockIndices.back() : 0;}
-
-      /**
-       * \brief A block within a column
-       */
-      struct RowBlock
+  public:
+    //! this is the type of the elementary block, it is an Eigen::Matrix.
+    typedef MatrixType SparseMatrixBlock;
+
+    //! columns of the matrix
+    int cols() const { return _colBlockIndices.size() ? _colBlockIndices.back() : 0; }
+    //! rows of the matrix
+    int rows() const { return _rowBlockIndices.size() ? _rowBlockIndices.back() : 0; }
+
+    /**
+     * \brief A block within a column
+     */
+    struct RowBlock
+    {
+      int row;           ///< row of the block
+      MatrixType *block; ///< matrix pointer for the block
+      RowBlock() : row(-1), block(0) {}
+      RowBlock(int r, MatrixType *b) : row(r), block(b) {}
+      bool operator<(const RowBlock &other) const { return row < other.row; }
+    };
+    typedef std::vector<RowBlock> SparseColumn;
+
+    SparseBlockMatrixCCS(const std::vector<int> &rowIndices, const std::vector<int> &colIndices) : _rowBlockIndices(rowIndices), _colBlockIndices(colIndices)
+    {
+    }
+
+    //! how many rows does the block at block-row r has?
+    int rowsOfBlock(int r) const { return r ? _rowBlockIndices[r] - _rowBlockIndices[r - 1] : _rowBlockIndices[0]; }
+
+    //! how many cols does the block at block-col c has?
+    int colsOfBlock(int c) const { return c ? _colBlockIndices[c] - _colBlockIndices[c - 1] : _colBlockIndices[0]; }
+
+    //! where does the row at block-row r start?
+    int rowBaseOfBlock(int r) const { return r ? _rowBlockIndices[r - 1] : 0; }
+
+    //! where does the col at block-col r start?
+    int colBaseOfBlock(int c) const { return c ? _colBlockIndices[c - 1] : 0; }
+
+    //! the block matrices per block-column
+    const std::vector<SparseColumn> &blockCols() const { return _blockCols; }
+    std::vector<SparseColumn> &blockCols() { return _blockCols; }
+
+    //! indices of the row blocks
+    const std::vector<int> &rowBlockIndices() const { return _rowBlockIndices; }
+
+    //! indices of the column blocks
+    const std::vector<int> &colBlockIndices() const { return _colBlockIndices; }
+
+    void rightMultiply(double *&dest, const double *src) const
+    {
+      int destSize = cols();
+
+      if (!dest)
       {
-        int row;              ///< row of the block
-        MatrixType* block;    ///< matrix pointer for the block
-        RowBlock() : row(-1), block(0) {}
-        RowBlock(int r, MatrixType* b) : row(r), block(b) {}
-        bool operator<(const RowBlock& other) const { return row < other.row;}
-      };
-      typedef std::vector<RowBlock>      SparseColumn;
-
-      SparseBlockMatrixCCS(const std::vector<int>& rowIndices, const std::vector<int>& colIndices) :
-        _rowBlockIndices(rowIndices), _colBlockIndices(colIndices)
-      {}
-
-      //! how many rows does the block at block-row r has?
-      int rowsOfBlock(int r) const { return r ? _rowBlockIndices[r] - _rowBlockIndices[r-1] : _rowBlockIndices[0] ; }
-
-      //! how many cols does the block at block-col c has?
-      int colsOfBlock(int c) const { return c ? _colBlockIndices[c] - _colBlockIndices[c-1] : _colBlockIndices[0]; }
-
-      //! where does the row at block-row r start?
-      int rowBaseOfBlock(int r) const { return r ? _rowBlockIndices[r-1] : 0 ; }
-
-      //! where does the col at block-col r start?
-      int colBaseOfBlock(int c) const { return c ? _colBlockIndices[c-1] : 0 ; }
-
-      //! the block matrices per block-column
-      const std::vector<SparseColumn>& blockCols() const { return _blockCols;}
-      std::vector<SparseColumn>& blockCols() { return _blockCols;}
-
-      //! indices of the row blocks
-      const std::vector<int>& rowBlockIndices() const { return _rowBlockIndices;}
+        dest = new double[destSize];
+        memset(dest, 0, destSize * sizeof(double));
+      }
 
-      //! indices of the column blocks
-      const std::vector<int>& colBlockIndices() const { return _colBlockIndices;}
+      // map the memory by Eigen
+      Eigen::Map<Eigen::VectorXd> destVec(dest, destSize);
+      Eigen::Map<const Eigen::VectorXd> srcVec(src, rows());
 
-      void rightMultiply(double*& dest, const double* src) const
+#ifdef G2O_OPENMP
+#pragma omp parallel for default(shared) schedule(dynamic, 10)
+#endif
+      for (int i = 0; i < static_cast<int>(_blockCols.size()); ++i)
       {
-        int destSize=cols();
-
-        if (! dest){
-          dest=new double [ destSize ];
-          memset(dest,0, destSize*sizeof(double));
-        }
-
-        // map the memory by Eigen
-        Eigen::Map<Eigen::VectorXd> destVec(dest, destSize);
-        Eigen::Map<const Eigen::VectorXd> srcVec(src, rows());
-
-#      ifdef G2O_OPENMP
-#      pragma omp parallel for default (shared) schedule(dynamic, 10)
-#      endif
-        for (int i=0; i < static_cast<int>(_blockCols.size()); ++i){
-          int destOffset = colBaseOfBlock(i);
-          for (typename SparseColumn::const_iterator it = _blockCols[i].begin(); it!=_blockCols[i].end(); ++it) {
-            const SparseMatrixBlock* a = it->block;
-            int srcOffset = rowBaseOfBlock(it->row);
-            // destVec += *a.transpose() * srcVec (according to the sub-vector parts)
-            internal::atxpy(*a, srcVec, srcOffset, destVec, destOffset);
-          }
+        int destOffset = colBaseOfBlock(i);
+        for (typename SparseColumn::const_iterator it = _blockCols[i].begin(); it != _blockCols[i].end(); ++it)
+        {
+          const SparseMatrixBlock *a = it->block;
+          int srcOffset = rowBaseOfBlock(it->row);
+          // destVec += *a.transpose() * srcVec (according to the sub-vector parts)
+          internal::atxpy(*a, srcVec, srcOffset, destVec, destOffset);
         }
       }
-
-      /**
-       * sort the blocks in each column
-       */
-      void sortColumns()
+    }
+
+    /**
+     * sort the blocks in each column
+     */
+    void sortColumns()
+    {
+      for (int i = 0; i < static_cast<int>(_blockCols.size()); ++i)
       {
-        for (int i=0; i < static_cast<int>(_blockCols.size()); ++i){
-          std::sort(_blockCols[i].begin(), _blockCols[i].end());
-        }
+        std::sort(_blockCols[i].begin(), _blockCols[i].end());
       }
-
-      /**
-       * fill the CCS arrays of a matrix, arrays have to be allocated beforehand
-       */
-      int fillCCS(int* Cp, int* Ci, double* Cx, bool upperTriangle = false) const
+    }
+
+    /**
+     * fill the CCS arrays of a matrix, arrays have to be allocated beforehand
+     */
+    int fillCCS(int *Cp, int *Ci, double *Cx, bool upperTriangle = false) const
+    {
+      assert(Cp && Ci && Cx && "Target destination is NULL");
+      int nz = 0;
+      for (size_t i = 0; i < _blockCols.size(); ++i)
       {
-        assert(Cp && Ci && Cx && "Target destination is NULL");
-        int nz=0;
-        for (size_t i=0; i<_blockCols.size(); ++i){
-          int cstart=i ? _colBlockIndices[i-1] : 0;
-          int csize=colsOfBlock(i);
-          for (int c=0; c<csize; ++c) {
-            *Cp=nz;
-            for (typename SparseColumn::const_iterator it = _blockCols[i].begin(); it!=_blockCols[i].end(); ++it) {
-              const SparseMatrixBlock* b=it->block;
-              int rstart=it->row ? _rowBlockIndices[it->row-1] : 0;
-
-              int elemsToCopy = b->rows();
-              if (upperTriangle && rstart == cstart)
-                elemsToCopy = c + 1;
-              for (int r=0; r<elemsToCopy; ++r){
-                *Cx++ = (*b)(r,c);
-                *Ci++ = rstart++;
-                ++nz;
-              }
+        int cstart = i ? _colBlockIndices[i - 1] : 0;
+        int csize = colsOfBlock(i);
+        for (int c = 0; c < csize; ++c)
+        {
+          *Cp = nz;
+          for (typename SparseColumn::const_iterator it = _blockCols[i].begin(); it != _blockCols[i].end(); ++it)
+          {
+            const SparseMatrixBlock *b = it->block;
+            int rstart = it->row ? _rowBlockIndices[it->row - 1] : 0;
+
+            int elemsToCopy = b->rows();
+            if (upperTriangle && rstart == cstart)
+              elemsToCopy = c + 1;
+            for (int r = 0; r < elemsToCopy; ++r)
+            {
+              *Cx++ = (*b)(r, c);
+              *Ci++ = rstart++;
+              ++nz;
             }
-            ++Cp;
           }
+          ++Cp;
         }
-        *Cp=nz;
-        return nz;
       }
-
-      /**
-       * fill the CCS arrays of a matrix, arrays have to be allocated beforehand. This function only writes
-       * the values and assumes that column and row structures have already been written.
-       */
-      int fillCCS(double* Cx, bool upperTriangle = false) const
+      *Cp = nz;
+      return nz;
+    }
+
+    /**
+     * fill the CCS arrays of a matrix, arrays have to be allocated beforehand. This function only writes
+     * the values and assumes that column and row structures have already been written.
+     */
+    int fillCCS(double *Cx, bool upperTriangle = false) const
+    {
+      assert(Cx && "Target destination is NULL");
+      double *CxStart = Cx;
+      int cstart = 0;
+      for (size_t i = 0; i < _blockCols.size(); ++i)
       {
-        assert(Cx && "Target destination is NULL");
-        double* CxStart = Cx;
-        int cstart = 0;
-        for (size_t i=0; i<_blockCols.size(); ++i){
-          int csize = _colBlockIndices[i] - cstart;
-          for (int c=0; c<csize; ++c) {
-            for (typename SparseColumn::const_iterator it = _blockCols[i].begin(); it!=_blockCols[i].end(); ++it) {
-              const SparseMatrixBlock* b = it->block;
-              int rstart = it->row ? _rowBlockIndices[it->row-1] : 0;
-
-              int elemsToCopy = b->rows();
-              if (upperTriangle && rstart == cstart)
-                elemsToCopy = c + 1;
-              memcpy(Cx, b->data() + c*b->rows(), elemsToCopy * sizeof(double));
-              Cx += elemsToCopy;
-
-            }
+        int csize = _colBlockIndices[i] - cstart;
+        for (int c = 0; c < csize; ++c)
+        {
+          for (typename SparseColumn::const_iterator it = _blockCols[i].begin(); it != _blockCols[i].end(); ++it)
+          {
+            const SparseMatrixBlock *b = it->block;
+            int rstart = it->row ? _rowBlockIndices[it->row - 1] : 0;
+
+            int elemsToCopy = b->rows();
+            if (upperTriangle && rstart == cstart)
+              elemsToCopy = c + 1;
+            memcpy(Cx, b->data() + c * b->rows(), elemsToCopy * sizeof(double));
+            Cx += elemsToCopy;
           }
-          cstart = _colBlockIndices[i];
         }
-        return Cx - CxStart;
+        cstart = _colBlockIndices[i];
       }
+      return Cx - CxStart;
+    }
 
-    protected:
-      const std::vector<int>& _rowBlockIndices; ///< vector of the indices of the blocks along the rows.
-      const std::vector<int>& _colBlockIndices; ///< vector of the indices of the blocks along the cols
-      std::vector<SparseColumn> _blockCols;     ///< the matrices stored in CCS order
+  protected:
+    const std::vector<int> &_rowBlockIndices; ///< vector of the indices of the blocks along the rows.
+    const std::vector<int> &_colBlockIndices; ///< vector of the indices of the blocks along the cols
+    std::vector<SparseColumn> _blockCols;     ///< the matrices stored in CCS order
   };
 
-
-
   /**
    * \brief Sparse matrix which uses blocks based on hash structures
    *
-   * This class is used to construct the pattern of a sparse block matrix 
+   * This class is used to construct the pattern of a sparse block matrix
    */
   template <class MatrixType>
   class SparseBlockMatrixHashMap
   {
-    public:
-      //! this is the type of the elementary block, it is an Eigen::Matrix.
-      typedef MatrixType SparseMatrixBlock;
+  public:
+    //! this is the type of the elementary block, it is an Eigen::Matrix.
+    typedef MatrixType SparseMatrixBlock;
 
-      //! columns of the matrix
-      int cols() const {return _colBlockIndices.size() ? _colBlockIndices.back() : 0;}
-      //! rows of the matrix
-      int rows() const {return _rowBlockIndices.size() ? _rowBlockIndices.back() : 0;}
+    //! columns of the matrix
+    int cols() const { return _colBlockIndices.size() ? _colBlockIndices.back() : 0; }
+    //! rows of the matrix
+    int rows() const { return _rowBlockIndices.size() ? _rowBlockIndices.back() : 0; }
 
-      typedef std::tr1::unordered_map<int, MatrixType*> SparseColumn;
+    typedef std::unordered_map<int, MatrixType *> SparseColumn;
 
-      SparseBlockMatrixHashMap(const std::vector<int>& rowIndices, const std::vector<int>& colIndices) :
-        _rowBlockIndices(rowIndices), _colBlockIndices(colIndices)
-      {}
+    SparseBlockMatrixHashMap(const std::vector<int> &rowIndices, const std::vector<int> &colIndices) : _rowBlockIndices(rowIndices), _colBlockIndices(colIndices)
+    {
+    }
 
-      //! how many rows does the block at block-row r has?
-      int rowsOfBlock(int r) const { return r ? _rowBlockIndices[r] - _rowBlockIndices[r-1] : _rowBlockIndices[0] ; }
+    //! how many rows does the block at block-row r has?
+    int rowsOfBlock(int r) const { return r ? _rowBlockIndices[r] - _rowBlockIndices[r - 1] : _rowBlockIndices[0]; }
 
-      //! how many cols does the block at block-col c has?
-      int colsOfBlock(int c) const { return c ? _colBlockIndices[c] - _colBlockIndices[c-1] : _colBlockIndices[0]; }
+    //! how many cols does the block at block-col c has?
+    int colsOfBlock(int c) const { return c ? _colBlockIndices[c] - _colBlockIndices[c - 1] : _colBlockIndices[0]; }
 
-      //! where does the row at block-row r start?
-      int rowBaseOfBlock(int r) const { return r ? _rowBlockIndices[r-1] : 0 ; }
+    //! where does the row at block-row r start?
+    int rowBaseOfBlock(int r) const { return r ? _rowBlockIndices[r - 1] : 0; }
 
-      //! where does the col at block-col r start?
-      int colBaseOfBlock(int c) const { return c ? _colBlockIndices[c-1] : 0 ; }
+    //! where does the col at block-col r start?
+    int colBaseOfBlock(int c) const { return c ? _colBlockIndices[c - 1] : 0; }
 
-      //! the block matrices per block-column
-      const std::vector<SparseColumn>& blockCols() const { return _blockCols;}
-      std::vector<SparseColumn>& blockCols() { return _blockCols;}
+    //! the block matrices per block-column
+    const std::vector<SparseColumn> &blockCols() const { return _blockCols; }
+    std::vector<SparseColumn> &blockCols() { return _blockCols; }
 
-      //! indices of the row blocks
-      const std::vector<int>& rowBlockIndices() const { return _rowBlockIndices;}
+    //! indices of the row blocks
+    const std::vector<int> &rowBlockIndices() const { return _rowBlockIndices; }
 
-      //! indices of the column blocks
-      const std::vector<int>& colBlockIndices() const { return _colBlockIndices;}
+    //! indices of the column blocks
+    const std::vector<int> &colBlockIndices() const { return _colBlockIndices; }
 
-      /**
-       * add a block to the pattern, return a pointer to the added block
-       */
-      MatrixType* addBlock(int r, int c, bool zeroBlock = false)
+    /**
+     * add a block to the pattern, return a pointer to the added block
+     */
+    MatrixType *addBlock(int r, int c, bool zeroBlock = false)
+    {
+      assert(c < (int)_blockCols.size() && "accessing column which is not available");
+      SparseColumn &sparseColumn = _blockCols[c];
+      typename SparseColumn::iterator foundIt = sparseColumn.find(r);
+      if (foundIt == sparseColumn.end())
       {
-        assert(c <(int)_blockCols.size() && "accessing column which is not available");
-        SparseColumn& sparseColumn = _blockCols[c];
-        typename SparseColumn::iterator foundIt = sparseColumn.find(r);
-        if (foundIt == sparseColumn.end()) {
-          int rb = rowsOfBlock(r);
-          int cb = colsOfBlock(c);
-          MatrixType* m = new MatrixType(rb, cb);
-          if (zeroBlock)
-            m->setZero();
-          sparseColumn[r] = m;
-          return m;
-        }
-        return foundIt->second;
+        int rb = rowsOfBlock(r);
+        int cb = colsOfBlock(c);
+        MatrixType *m = new MatrixType(rb, cb);
+        if (zeroBlock)
+          m->setZero();
+        sparseColumn[r] = m;
+        return m;
       }
+      return foundIt->second;
+    }
 
-    protected:
-      const std::vector<int>& _rowBlockIndices; ///< vector of the indices of the blocks along the rows.
-      const std::vector<int>& _colBlockIndices; ///< vector of the indices of the blocks along the cols
-      std::vector<SparseColumn> _blockCols;     ///< the matrices stored in CCS order
+  protected:
+    const std::vector<int> &_rowBlockIndices; ///< vector of the indices of the blocks along the rows.
+    const std::vector<int> &_colBlockIndices; ///< vector of the indices of the blocks along the cols
+    std::vector<SparseColumn> _blockCols;     ///< the matrices stored in CCS order
   };
 
-} //end namespace
+} // end namespace
 
 #endif
diff --git a/Thirdparty/g2o/g2o/stuff/os_specific.h b/Thirdparty/g2o/g2o/stuff/os_specific.h
index 89dd0cc..b0fd1a3 100644
--- a/Thirdparty/g2o/g2o/stuff/os_specific.h
+++ b/Thirdparty/g2o/g2o/stuff/os_specific.h
@@ -32,15 +32,16 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #ifndef _WINDOWS
-#include <sys/time.h>
+#include <sys/timeb.h>
 #endif
-#define drand48() ((double) rand()/(double)RAND_MAX)
+#define drand48() ((double)rand() / (double)RAND_MAX)
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-int vasprintf(char** strp, const char* fmt, va_list ap);
+    int vasprintf(char **strp, const char *fmt, va_list ap);
 
 #ifdef __cplusplus
 }
diff --git a/Thirdparty/g2o/g2o/stuff/string_tools.cpp b/Thirdparty/g2o/g2o/stuff/string_tools.cpp
index 8b5cc03..beb9963 100644
--- a/Thirdparty/g2o/g2o/stuff/string_tools.cpp
+++ b/Thirdparty/g2o/g2o/stuff/string_tools.cpp
@@ -37,14 +37,15 @@
 #include <iostream>
 #include <iterator>
 
-#if (defined (UNIX) || defined(CYGWIN)) && !defined(ANDROID)
+#if (defined(UNIX) || defined(CYGWIN)) && !defined(ANDROID)
 #include <wordexp.h>
 #endif
 
-namespace g2o {
+namespace g2o
+{
 
-
-    std::string trim(const std::string &s) {
+    std::string trim(const std::string &s)
+    {
         if (s.length() == 0)
             return s;
         std::string::size_type b = s.find_first_not_of(" \t\n");
@@ -54,7 +55,8 @@ namespace g2o {
         return std::string(s, b, e - b + 1);
     }
 
-    std::string trimLeft(const std::string &s) {
+    std::string trimLeft(const std::string &s)
+    {
         if (s.length() == 0)
             return s;
         std::string::size_type b = s.find_first_not_of(" \t\n");
@@ -64,7 +66,8 @@ namespace g2o {
         return std::string(s, b, e - b + 1);
     }
 
-    std::string trimRight(const std::string &s) {
+    std::string trimRight(const std::string &s)
+    {
         if (s.length() == 0)
             return s;
         std::string::size_type b = 0;
@@ -74,69 +77,78 @@ namespace g2o {
         return std::string(s, b, e - b + 1);
     }
 
-    std::string strToLower(const std::string &s) {
+    std::string strToLower(const std::string &s)
+    {
         std::string ret;
-        std::transform(s.begin(), s.end(), back_inserter(ret), (int (*)(int)) std::tolower);
+        std::transform(s.begin(), s.end(), back_inserter(ret), (int (*)(int))std::tolower);
         return ret;
     }
 
-    std::string strToUpper(const std::string &s) {
+    std::string strToUpper(const std::string &s)
+    {
         std::string ret;
-        std::transform(s.begin(), s.end(), back_inserter(ret), (int (*)(int)) std::toupper);
+        std::transform(s.begin(), s.end(), back_inserter(ret), (int (*)(int))std::toupper);
         return ret;
     }
 
-    std::string formatString(const char *fmt, ...) {
+    std::string formatString(const char *fmt, ...)
+    {
         char *auxPtr = NULL;
         va_list arg_list;
         va_start(arg_list, fmt);
-        int numChar = vasprintf(&auxPtr, fmt, arg_list);
+        int numChar = _vscprintf(fmt, arg_list);
         va_end(arg_list);
         std::string retString;
         if (numChar != -1)
             retString = auxPtr;
-        else {
-            std::cerr << __PRETTY_FUNCTION__ << ": Error while allocating memory" << std::endl;
+        else
+        {
+            std::cerr <<"formatString" << ": Error while allocating memory" << std::endl;
         }
         free(auxPtr);
         return retString;
     }
 
-    int strPrintf(std::string &str, const char *fmt, ...) {
+    int strPrintf(std::string &str, const char *fmt, ...)
+    {
         char *auxPtr = NULL;
         va_list arg_list;
         va_start(arg_list, fmt);
-        int numChars = vasprintf(&auxPtr, fmt, arg_list);
+        int numChars = _vscprintf(fmt, arg_list);
         va_end(arg_list);
         str = auxPtr;
         free(auxPtr);
         return numChars;
     }
 
-    std::string strExpandFilename(const std::string &filename) {
-#if (defined (UNIX) || defined(CYGWIN)) && !defined(ANDROID)
+    std::string strExpandFilename(const std::string &filename)
+    {
+#if (defined(UNIX) || defined(CYGWIN)) && !defined(ANDROID)
         std::string result = filename;
         wordexp_t p;
 
         wordexp(filename.c_str(), &p, 0);
-        if(p.we_wordc > 0) {
-          result = p.we_wordv[0];
+        if (p.we_wordc > 0)
+        {
+            result = p.we_wordv[0];
         }
         wordfree(&p);
         return result;
 #else
-        (void) filename;
+        (void)filename;
         std::cerr << "WARNING: " << __PRETTY_FUNCTION__ << " not implemented" << std::endl;
         return std::string();
 #endif
     }
 
-    std::vector<std::string> strSplit(const std::string &str, const std::string &delimiters) {
+    std::vector<std::string> strSplit(const std::string &str, const std::string &delimiters)
+    {
         std::vector<std::string> tokens;
         std::string::size_type lastPos = 0;
         std::string::size_type pos = 0;
 
-        do {
+        do
+        {
             pos = str.find_first_of(delimiters, lastPos);
             tokens.push_back(str.substr(lastPos, pos - lastPos));
             lastPos = pos + 1;
@@ -145,19 +157,22 @@ namespace g2o {
         return tokens;
     }
 
-    bool strStartsWith(const std::string &s, const std::string &start) {
+    bool strStartsWith(const std::string &s, const std::string &start)
+    {
         if (s.size() < start.size())
             return false;
         return equal(start.begin(), start.end(), s.begin());
     }
 
-    bool strEndsWith(const std::string &s, const std::string &end) {
+    bool strEndsWith(const std::string &s, const std::string &end)
+    {
         if (s.size() < end.size())
             return false;
         return equal(end.rbegin(), end.rend(), s.rbegin());
     }
 
-    int readLine(std::istream &is, std::stringstream &currentLine) {
+    int readLine(std::istream &is, std::stringstream &currentLine)
+    {
         if (is.eof())
             return -1;
         currentLine.str("");
diff --git a/Thirdparty/g2o/g2o/stuff/timeutil.cpp b/Thirdparty/g2o/g2o/stuff/timeutil.cpp
index ec19051..cbaf2ce 100644
--- a/Thirdparty/g2o/g2o/stuff/timeutil.cpp
+++ b/Thirdparty/g2o/g2o/stuff/timeutil.cpp
@@ -29,6 +29,7 @@
 
 #ifdef _WINDOWS
 #include <time.h>
+#define NOMINMAX
 #include <windows.h>
 #endif
 
@@ -36,89 +37,95 @@
 #include <unistd.h>
 #endif
 
-namespace g2o {
+namespace g2o
+{
 
 #ifdef _WINDOWS
 #if defined(_MSC_VER) || defined(_MSC_EXTENSIONS)
-  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64
+#define DELTA_EPOCH_IN_MICROSECS 11644473600000000Ui64
 #else
-  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL
+#define DELTA_EPOCH_IN_MICROSECS 11644473600000000ULL
 #endif
 
-struct timezone
-{
-  int  tz_minuteswest; /* minutes W of Greenwich */
-  int  tz_dsttime;     /* type of dst correction */
-};
+  struct timezone
+  {
+    int tz_minuteswest; /* minutes W of Greenwich */
+    int tz_dsttime;     /* type of dst correction */
+  };
 
-int gettimeofday(struct timeval *tv, struct timezone *tz)
-{
-// Define a structure to receive the current Windows filetime
-  FILETIME ft;
- 
-// Initialize the present time to 0 and the timezone to UTC
-  unsigned __int64 tmpres = 0;
-  static int tzflag = 0;
- 
-  if (NULL != tv)
+  int gettimeofday(struct timeval *tv, struct timezone *tz)
   {
-    GetSystemTimeAsFileTime(&ft);
- 
-// The GetSystemTimeAsFileTime returns the number of 100 nanosecond 
-// intervals since Jan 1, 1601 in a structure. Copy the high bits to 
-// the 64 bit tmpres, shift it left by 32 then or in the low 32 bits.
-    tmpres |= ft.dwHighDateTime;
-    tmpres <<= 32;
-    tmpres |= ft.dwLowDateTime;
- 
-// Convert to microseconds by dividing by 10
-    tmpres /= 10;
- 
-// The Unix epoch starts on Jan 1 1970.  Need to subtract the difference 
-// in seconds from Jan 1 1601.
-    tmpres -= DELTA_EPOCH_IN_MICROSECS;
- 
-// Finally change microseconds to seconds and place in the seconds value. 
-// The modulus picks up the microseconds.
-    tv->tv_sec = (long)(tmpres / 1000000UL);
-    tv->tv_usec = (long)(tmpres % 1000000UL);
-  }
- 
-  if (NULL != tz) {
-    if (!tzflag) {
-      _tzset();
-      tzflag++;
+    // Define a structure to receive the current Windows filetime
+    FILETIME ft;
+
+    // Initialize the present time to 0 and the timezone to UTC
+    unsigned __int64 tmpres = 0;
+    static int tzflag = 0;
+
+    if (NULL != tv)
+    {
+      GetSystemTimeAsFileTime(&ft);
+
+      // The GetSystemTimeAsFileTime returns the number of 100 nanosecond
+      // intervals since Jan 1, 1601 in a structure. Copy the high bits to
+      // the 64 bit tmpres, shift it left by 32 then or in the low 32 bits.
+      tmpres |= ft.dwHighDateTime;
+      tmpres <<= 32;
+      tmpres |= ft.dwLowDateTime;
+
+      // Convert to microseconds by dividing by 10
+      tmpres /= 10;
+
+      // The Unix epoch starts on Jan 1 1970.  Need to subtract the difference
+      // in seconds from Jan 1 1601.
+      tmpres -= DELTA_EPOCH_IN_MICROSECS;
+
+      // Finally change microseconds to seconds and place in the seconds value.
+      // The modulus picks up the microseconds.
+      tv->tv_sec = (long)(tmpres / 1000000UL);
+      tv->tv_usec = (long)(tmpres % 1000000UL);
     }
 
-    long sec;
-    int hours;
-    _get_timezone(&sec);
-    _get_daylight(&hours);
-  
-// Adjust for the timezone west of Greenwich
-    tz->tz_minuteswest = sec / 60;
-    tz->tz_dsttime = hours;
+    if (NULL != tz)
+    {
+      if (!tzflag)
+      {
+        _tzset();
+        tzflag++;
+      }
+
+      long sec;
+      int hours;
+      _get_timezone(&sec);
+      _get_daylight(&hours);
+
+      // Adjust for the timezone west of Greenwich
+      tz->tz_minuteswest = sec / 60;
+      tz->tz_dsttime = hours;
+    }
+
+    return 0;
   }
- 
-  return 0;
-}
 #endif
 
-ScopeTime::ScopeTime(const char* title) : _title(title), _startTime(get_monotonic_time()) {}
+  ScopeTime::ScopeTime(const char *title) : _title(title), _startTime(get_monotonic_time())
+  {
+  }
 
-ScopeTime::~ScopeTime() {
-  std::cerr << _title<<" took "<<1000*(get_monotonic_time()-_startTime)<<"ms.\n";
-}
+  ScopeTime::~ScopeTime()
+  {
+    std::cerr << _title << " took " << 1000 * (get_monotonic_time() - _startTime) << "ms.\n";
+  }
 
-double get_monotonic_time()
-{
-#if (defined(_POSIX_TIMERS) && (_POSIX_TIMERS+0 >= 0) && defined(_POSIX_MONOTONIC_CLOCK))
-  struct timespec ts;
-  clock_gettime(CLOCK_MONOTONIC, &ts);
-  return ts.tv_sec + ts.tv_nsec*1e-9;
+  double get_monotonic_time()
+  {
+#if (defined(_POSIX_TIMERS) && (_POSIX_TIMERS + 0 >= 0) && defined(_POSIX_MONOTONIC_CLOCK))
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return ts.tv_sec + ts.tv_nsec * 1e-9;
 #else
-  return get_time();
+    return get_time();
 #endif
-}
+  }
 
 } // end namespace
diff --git a/Thirdparty/g2o/g2o/stuff/timeutil.h b/Thirdparty/g2o/g2o/stuff/timeutil.h
index bde8e31..e14fe2f 100644
--- a/Thirdparty/g2o/g2o/stuff/timeutil.h
+++ b/Thirdparty/g2o/g2o/stuff/timeutil.h
@@ -30,12 +30,11 @@
 #ifdef _WINDOWS
 #include <time.h>
 #else
-#include <sys/time.h>
+#include <sys/timeb.h>
 #endif
 
 #include <string>
 
-
 /** @addtogroup utils **/
 // @{
 
@@ -46,18 +45,21 @@
 /// Executes code, only if secs are gone since last exec.
 /// extended version, in which the current time is given, e.g., timestamp of IPC message
 #ifndef DO_EVERY_TS
-#define DO_EVERY_TS(secs, currentTime, code) \
-if (1) {\
-  static double s_lastDone_ = (currentTime); \
-  double s_now_ = (currentTime); \
-  if (s_lastDone_ > s_now_) \
-    s_lastDone_ = s_now_; \
-  if (s_now_ - s_lastDone_ > (secs)) { \
-    code; \
-    s_lastDone_ = s_now_; \
-  }\
-} else \
-  (void)0
+#define DO_EVERY_TS(secs, currentTime, code)   \
+  if (1)                                       \
+  {                                            \
+    static double s_lastDone_ = (currentTime); \
+    double s_now_ = (currentTime);             \
+    if (s_lastDone_ > s_now_)                  \
+      s_lastDone_ = s_now_;                    \
+    if (s_now_ - s_lastDone_ > (secs))         \
+    {                                          \
+      code;                                    \
+      s_lastDone_ = s_now_;                    \
+    }                                          \
+  }                                            \
+  else                                         \
+    (void)0
 #endif
 
 /// Executes code, only if secs are gone since last exec.
@@ -66,59 +68,65 @@ if (1) {\
 #endif
 
 #ifndef MEASURE_TIME
-#define MEASURE_TIME(text, code) \
-  if(1) { \
-    double _start_time_ = g2o::get_time(); \
-    code; \
+#define MEASURE_TIME(text, code)                                               \
+  if (1)                                                                       \
+  {                                                                            \
+    double _start_time_ = g2o::get_time();                                     \
+    code;                                                                      \
     fprintf(stderr, "%s took %f sec\n", text, g2o::get_time() - _start_time_); \
-  } else \
-    (void) 0
-#endif
-
-namespace g2o {
-
-#ifdef _WINDOWS
-typedef struct timeval {
-  long tv_sec;
-  long tv_usec;
-} timeval;
- int gettimeofday(struct timeval *tv, struct timezone *tz);
+  }                                                                            \
+  else                                                                         \
+    (void)0
 #endif
 
-/**
- * return the current time in seconds since 1. Jan 1970
- */
-inline double get_time() 
+namespace g2o
 {
-  struct timeval ts;
-  gettimeofday(&ts,0);
-  return ts.tv_sec + ts.tv_usec*1e-6;
-}
-
-/**
- * return a monotonic increasing time which basically does not need to
- * have a reference point. Consider this for measuring how long some
- * code fragments required to execute.
- *
- * On Linux we call clock_gettime() on other systems we currently
- * call get_time().
- */
- double get_monotonic_time();
 
-/**
- * \brief Class to measure the time spent in a scope
- *
- * To use this class, e.g. to measure the time spent in a function,
- * just create and instance at the beginning of the function.
- */
-class  ScopeTime {
-  public: 
-    ScopeTime(const char* title);
+
+  typedef struct timeval
+  {
+    long tv_sec;
+    long tv_usec;
+  } timeval;
+  int gettimeofday(struct timeval *tv, struct timezone *tz);
+
+
+  /**
+   * return the current time in seconds since 1. Jan 1970
+   */
+  inline double get_time()
+  {
+    struct timeval ts;
+    gettimeofday(&ts, 0);
+    return ts.tv_sec + ts.tv_usec * 1e-6;
+  }
+
+  /**
+   * return a monotonic increasing time which basically does not need to
+   * have a reference point. Consider this for measuring how long some
+   * code fragments required to execute.
+   *
+   * On Linux we call clock_gettime() on other systems we currently
+   * call get_time().
+   */
+  double get_monotonic_time();
+
+  /**
+   * \brief Class to measure the time spent in a scope
+   *
+   * To use this class, e.g. to measure the time spent in a function,
+   * just create and instance at the beginning of the function.
+   */
+  class ScopeTime
+  {
+  public:
+    ScopeTime(const char *title);
     ~ScopeTime();
+
   private:
     std::string _title;
     double _startTime;
-};
+  };
 
 } // end namespace
 
@@ -127,6 +135,5 @@ class  ScopeTime {
   g2o::ScopeTime scopeTime(__PRETTY_FUNCTION__)
 #endif
 
-
 // @}
 #endif
diff --git a/Thirdparty/g2o/g2o/types/se3_ops.h b/Thirdparty/g2o/g2o/types/se3_ops.h
index 019aba0..b5c59d3 100644
--- a/Thirdparty/g2o/g2o/types/se3_ops.h
+++ b/Thirdparty/g2o/g2o/types/se3_ops.h
@@ -27,8 +27,8 @@
 #ifndef G2O_MATH_STUFF
 #define G2O_MATH_STUFF
 
-#include <eigen3/Eigen/Core>
-#include <eigen3/Eigen/Geometry>
+#include <Eigen/Core>
+#include <Eigen/Geometry>
 
 namespace g2o {
   using namespace Eigen;
diff --git a/Thirdparty/g2o/g2o/types/se3quat.h b/Thirdparty/g2o/g2o/types/se3quat.h
index 0ed3856..ac5ec57 100644
--- a/Thirdparty/g2o/g2o/types/se3quat.h
+++ b/Thirdparty/g2o/g2o/types/se3quat.h
@@ -29,8 +29,8 @@
 
 #include "se3_ops.h"
 
-#include <eigen3/Eigen/Core>
-#include <eigen3/Eigen/Geometry>
+#include <Eigen/Core>
+#include <Eigen/Geometry>
 
 namespace g2o {
   using namespace Eigen;
diff --git a/Thirdparty/g2o/g2o/types/sim3.h b/Thirdparty/g2o/g2o/types/sim3.h
index c828433..bd597d7 100644
--- a/Thirdparty/g2o/g2o/types/sim3.h
+++ b/Thirdparty/g2o/g2o/types/sim3.h
@@ -28,7 +28,7 @@
 #define G2O_SIM_3
 
 #include "se3_ops.h"
-#include <eigen3/Eigen/Geometry>
+#include <Eigen/Geometry>
 
 namespace g2o
 {
diff --git a/Thirdparty/g2o/g2o/types/types_sba.h b/Thirdparty/g2o/g2o/types/types_sba.h
index bcde257..bb419df 100644
--- a/Thirdparty/g2o/g2o/types/types_sba.h
+++ b/Thirdparty/g2o/g2o/types/types_sba.h
@@ -29,7 +29,7 @@
 
 #include "../core/base_vertex.h"
 
-#include <eigen3/Eigen/Geometry>
+#include <Eigen/Geometry>
 #include <iostream>
 
 namespace g2o {
diff --git a/Thirdparty/g2o/g2o/types/types_six_dof_expmap.h b/Thirdparty/g2o/g2o/types/types_six_dof_expmap.h
index 60aff5f..be765f1 100644
--- a/Thirdparty/g2o/g2o/types/types_six_dof_expmap.h
+++ b/Thirdparty/g2o/g2o/types/types_six_dof_expmap.h
@@ -40,7 +40,7 @@
 #include "se3_ops.h"
 #include "se3quat.h"
 #include "types_sba.h"
-#include <eigen3/Eigen/Geometry>
+#include <Eigen/Geometry>
 
 namespace g2o {
 namespace types_six_dof_expmap {
diff --git a/Thirdparty/g2o/install-deps-windows.bat b/Thirdparty/g2o/install-deps-windows.bat
new file mode 100644
index 0000000..16ba19b
--- /dev/null
+++ b/Thirdparty/g2o/install-deps-windows.bat
@@ -0,0 +1,28 @@
+@echo off
+
+setlocal
+
+rem ----------------------------------
+rem Locate vcpkg using environment variables falling back to sensible defaults
+rem ----------------------------------
+set "VcPkgDir=%USERPROFILE%\Documents\vcpkg"
+set "VcPkgTriplet=x64-windows"
+if defined VCPKG_ROOT_DIR if /i not "%VCPKG_ROOT_DIR%"=="" set "VcPkgDir=%VCPKG_ROOT_DIR%"
+if defined VCPKG_DEFAULT_TRIPLET if /i not "%VCPKG_DEFAULT_TRIPLET%"=="" set "VcPkgTriplet=%VCPKG_DEFAULT_TRIPLET%"
+    
+pushd %VcPkgDir%
+
+rem ==============================
+rem Upgrade and Install packages.
+rem ==============================
+set "VcPkgLibs=eigen3 suitesparse clapack openblas ceres"
+
+echo vcpkg found at %VcPkgDir%...
+echo installing %VcPkgLibs% for triplet %VcPkgTriplet%...
+
+call %VcPkgDir% upgrade %VcPkgLibs% --no-dry-run --triplet %VcPkgTriplet%
+call %VcPkgDir% install %VcPkgLibs% --triplet %VcPkgTriplet%
+
+popd
+
+endlocal & set "VcPkgDir=%VcPkgDir%" & set "VcPkgTriplet=%VcPkgTriplet%"
diff --git a/config/EuRoC.yaml b/config/EuRoC.yaml
new file mode 100644
index 0000000..a298c8b
--- /dev/null
+++ b/config/EuRoC.yaml
@@ -0,0 +1,56 @@
+%YAML:1.0
+
+#--------------------------------------------------------------------------------------------
+# Camera Parameters. Adjust them!
+#--------------------------------------------------------------------------------------------
+
+# Camera calibration and distortion parameters (OpenCV) 
+Camera.fx: 458.654
+Camera.fy: 457.296
+Camera.cx: 367.215
+Camera.cy: 248.375
+
+Camera.k1: -0.28340811
+Camera.k2: 0.07395907
+Camera.p1: 0.00019359
+Camera.p2: 1.76187114e-05
+
+# Camera frames per second 
+Camera.fps: 20.0
+
+# Color order of the images (0: BGR, 1: RGB. It is ignored if images are grayscale)
+Camera.RGB: 1
+
+#--------------------------------------------------------------------------------------------
+# ORB Parameters
+#--------------------------------------------------------------------------------------------
+
+# ORB Extractor: Number of features per image
+ORBextractor.nFeatures: 2000
+
+# ORB Extractor: Scale factor between levels in the scale pyramid 	
+ORBextractor.scaleFactor: 1.2
+
+# ORB Extractor: Number of levels in the scale pyramid	
+ORBextractor.nLevels: 8
+
+# ORB Extractor: Fast threshold
+# Image is divided in a grid. At each cell FAST are extracted imposing a minimum response.
+# Firstly we impose iniThFAST. If no corners are detected we impose a lower value minThFAST
+# You can lower these values if your images have low contrast			
+ORBextractor.iniThFAST: 10
+ORBextractor.minThFAST: 5
+
+#--------------------------------------------------------------------------------------------
+# Viewer Parameters
+#---------------------------------------------------------------------------------------------
+Viewer.KeyFrameSize: 0.05
+Viewer.KeyFrameLineWidth: 1
+Viewer.GraphLineWidth: 0.9
+Viewer.PointSize:2
+Viewer.CameraSize: 0.08
+Viewer.CameraLineWidth: 3
+Viewer.ViewpointX: 0
+Viewer.ViewpointY: -0.7
+Viewer.ViewpointZ: -1.8
+Viewer.ViewpointF: 500
diff --git a/config/KITTI00-02.yaml b/config/KITTI00-02.yaml
new file mode 100644
index 0000000..7981d4d
--- /dev/null
+++ b/config/KITTI00-02.yaml
@@ -0,0 +1,57 @@
+%YAML:1.0
+
+#--------------------------------------------------------------------------------------------
+# Camera Parameters. Adjust them!
+#--------------------------------------------------------------------------------------------
+
+# Camera calibration and distortion parameters (OpenCV) 
+Camera.fx: 718.856
+Camera.fy: 718.856
+Camera.cx: 607.1928
+Camera.cy: 185.2157
+
+Camera.k1: 0.0
+Camera.k2: 0.0
+Camera.p1: 0.0
+Camera.p2: 0.0
+
+# Camera frames per second 
+Camera.fps: 30.0
+
+# Color order of the images (0: BGR, 1: RGB. It is ignored if images are grayscale)
+Camera.RGB: 1
+
+#--------------------------------------------------------------------------------------------
+# ORB Parameters
+#--------------------------------------------------------------------------------------------
+
+# ORB Extractor: Number of features per image
+ORBextractor.nFeatures: 3000
+
+# ORB Extractor: Scale factor between levels in the scale pyramid 	
+ORBextractor.scaleFactor: 1.2
+
+# ORB Extractor: Number of levels in the scale pyramid	
+ORBextractor.nLevels: 8
+
+# ORB Extractor: Fast threshold
+# Image is divided in a grid. At each cell FAST are extracted imposing a minimum response.
+# Firstly we impose iniThFAST. If no corners are detected we impose a lower value minThFAST
+# You can lower these values if your images have low contrast			
+ORBextractor.iniThFAST: 10
+ORBextractor.minThFAST: 5
+
+#--------------------------------------------------------------------------------------------
+# Viewer Parameters
+#--------------------------------------------------------------------------------------------
+Viewer.KeyFrameSize: 0.1
+Viewer.KeyFrameLineWidth: 1
+Viewer.GraphLineWidth: 1
+Viewer.PointSize:2
+Viewer.CameraSize: 0.15
+Viewer.CameraLineWidth: 2
+Viewer.ViewpointX: 0
+Viewer.ViewpointY: -10
+Viewer.ViewpointZ: -0.1
+Viewer.ViewpointF: 2000
+
diff --git a/config/KITTI03.yaml b/config/KITTI03.yaml
new file mode 100644
index 0000000..b081bd0
--- /dev/null
+++ b/config/KITTI03.yaml
@@ -0,0 +1,57 @@
+%YAML:1.0
+
+#--------------------------------------------------------------------------------------------
+# Camera Parameters. Adjust them!
+#--------------------------------------------------------------------------------------------
+
+# Camera calibration and distortion parameters (OpenCV) 
+Camera.fx: 721.5377
+Camera.fy: 721.5377
+Camera.cx: 609.5593
+Camera.cy: 172.854
+
+Camera.k1: 0.0
+Camera.k2: 0.0
+Camera.p1: 0.0
+Camera.p2: 0.0
+
+# Camera frames per second 
+Camera.fps: 10.0
+
+# Color order of the images (0: BGR, 1: RGB. It is ignored if images are grayscale)
+Camera.RGB: 1
+
+#--------------------------------------------------------------------------------------------
+# ORB Parameters
+#--------------------------------------------------------------------------------------------
+
+# ORB Extractor: Number of features per image
+ORBextractor.nFeatures: 2000
+
+# ORB Extractor: Scale factor between levels in the scale pyramid 	
+ORBextractor.scaleFactor: 1.2
+
+# ORB Extractor: Number of levels in the scale pyramid	
+ORBextractor.nLevels: 8
+
+# ORB Extractor: Fast threshold
+# Image is divided in a grid. At each cell FAST are extracted imposing a minimum response.
+# Firstly we impose iniThFAST. If no corners are detected we impose a lower value minThFAST
+# You can lower these values if your images have low contrast			
+ORBextractor.iniThFAST: 20
+ORBextractor.minThFAST: 7
+
+#--------------------------------------------------------------------------------------------
+# Viewer Parameters
+#--------------------------------------------------------------------------------------------
+Viewer.KeyFrameSize: 0.1
+Viewer.KeyFrameLineWidth: 1
+Viewer.GraphLineWidth: 1
+Viewer.PointSize:2
+Viewer.CameraSize: 0.15
+Viewer.CameraLineWidth: 2
+Viewer.ViewpointX: 0
+Viewer.ViewpointY: -10
+Viewer.ViewpointZ: -0.1
+Viewer.ViewpointF: 2000
+
diff --git a/config/KITTI04-12.yaml b/config/KITTI04-12.yaml
new file mode 100644
index 0000000..e2e5aa8
--- /dev/null
+++ b/config/KITTI04-12.yaml
@@ -0,0 +1,57 @@
+%YAML:1.0
+
+#--------------------------------------------------------------------------------------------
+# Camera Parameters. Adjust them!
+#--------------------------------------------------------------------------------------------
+
+# Camera calibration and distortion parameters (OpenCV) 
+Camera.fx: 707.0912
+Camera.fy: 707.0912
+Camera.cx: 601.8873
+Camera.cy: 183.1104
+
+Camera.k1: 0.0
+Camera.k2: 0.0
+Camera.p1: 0.0
+Camera.p2: 0.0
+
+# Camera frames per second 
+Camera.fps: 10.0
+
+# Color order of the images (0: BGR, 1: RGB. It is ignored if images are grayscale)
+Camera.RGB: 1
+
+#--------------------------------------------------------------------------------------------
+# ORB Parameters
+#--------------------------------------------------------------------------------------------
+
+# ORB Extractor: Number of features per image
+ORBextractor.nFeatures: 10000
+
+# ORB Extractor: Scale factor between levels in the scale pyramid 	
+ORBextractor.scaleFactor: 1.2
+
+# ORB Extractor: Number of levels in the scale pyramid	
+ORBextractor.nLevels: 8
+
+# ORB Extractor: Fast threshold
+# Image is divided in a grid. At each cell FAST are extracted imposing a minimum response.
+# Firstly we impose iniThFAST. If no corners are detected we impose a lower value minThFAST
+# You can lower these values if your images have low contrast			
+ORBextractor.iniThFAST: 20
+ORBextractor.minThFAST: 7
+
+#--------------------------------------------------------------------------------------------
+# Viewer Parameters
+#--------------------------------------------------------------------------------------------
+Viewer.KeyFrameSize: 0.1
+Viewer.KeyFrameLineWidth: 1
+Viewer.GraphLineWidth: 1
+Viewer.PointSize:2
+Viewer.CameraSize: 0.15
+Viewer.CameraLineWidth: 2
+Viewer.ViewpointX: 0
+Viewer.ViewpointY: -10
+Viewer.ViewpointZ: -0.1
+Viewer.ViewpointF: 2000
+
diff --git a/exe/CMakeLists.txt b/exe/CMakeLists.txt
new file mode 100644
index 0000000..6c83d87
--- /dev/null
+++ b/exe/CMakeLists.txt
@@ -0,0 +1,11 @@
+cmake_minimum_required(VERSION 3.0)
+add_executable(runSimulator runSimulator.cpp)
+target_link_libraries(runSimulator simulator)
+add_executable(testOnMonocularKittiDataset testOnMonocularKittiDataset.cpp)
+target_link_libraries(testOnMonocularKittiDataset ${PROJECT_NAME})
+add_executable(testOnMonocularEurocDataset testOnMonocularEurocDataset.cpp)
+target_link_libraries(testOnMonocularEurocDataset ${PROJECT_NAME})
+add_executable(testOnStereoKittiDataset testOnStereoKittiDataset.cpp)
+target_link_libraries(testOnStereoKittiDataset ${PROJECT_NAME})
+add_executable(runOnVideo runOnVideo.cpp)
+target_link_libraries(runOnVideo ORB_SLAM2)
\ No newline at end of file
diff --git a/exe/cameraCalibretion.cpp b/exe/cameraCalibretion.cpp
deleted file mode 100644
index 3dd9ce9..0000000
--- a/exe/cameraCalibretion.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d/calib3d.hpp>
-#include <opencv2/highgui/highgui.hpp>
-#include <opencv2/imgproc/imgproc.hpp>
-#include <stdio.h>
-#include <iostream>
-#include <nlohmann/json.hpp>
-#include <ctello.h>
-#include "include/Auxiliary.h"
-
-// Defining the dimensions of checkerboard
-int CHECKERBOARD[2]{6, 9};
-std::shared_ptr<cv::VideoCapture> capture;
-std::shared_ptr<cv::Mat> frame;
-std::shared_ptr<bool> stop;
-void videoDroneThread(std::string &videoPath){
-    capture = std::make_shared<cv::VideoCapture>(videoPath);
-    stop = std::make_shared<bool>(false);
-    frame = std::make_shared<cv::Mat>();
-    while(!*stop){
-        capture->read(*frame);
-    }
-    capture->release();
-}
-int main() {
-    // Creating vector to store vectors of 3D points for each checkerboard image
-    std::vector<std::vector<cv::Point3f> > objpoints;
-
-    // Creating vector to store vectors of 2D points for each checkerboard image
-    std::vector<std::vector<cv::Point2f> > imgpoints;
-
-    // Defining the world coordinates for 3D points
-    std::vector<cv::Point3f> objp;
-    for (int i{0}; i < CHECKERBOARD[1]; i++) {
-        for (int j{0}; j < CHECKERBOARD[0]; j++)
-            objp.push_back(cv::Point3f(j*6, i*6, 0));
-    }
-
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-    sleep(10);
-    ctello::Tello tello;
-    tello.SendCommandWithResponse("streamon");
-    std::string videoPath = data["onlineVideoPath"];
-    std::thread t = std::thread(videoDroneThread,std::ref(videoPath));
-    sleep(5);
-
-    cv::Mat  gray;
-    // vector to store the pixel coordinates of detected checker board corners
-    std::vector<cv::Point2f> corner_pts;
-    bool success;
-    int waitKey = 0;
-    std::cout << "frame size" << *frame->size << std::endl;
-    // Looping over all the images in the directory
-    for (int i{0}; i < 100; i++) {
-        cv::Mat frameCopy = *frame;
-        if (frameCopy.empty()){
-            i--;
-            continue;
-        }
-        //cv::resize(frame, frame, cv::Size(640, 480));
-        cv::cvtColor(frameCopy, gray, cv::COLOR_BGR2GRAY);
-        // Finding checker board corners
-        // If desired number of corners are found in the image then success = true
-        success = cv::findChessboardCorners(gray, cv::Size(CHECKERBOARD[0], CHECKERBOARD[1]), corner_pts,
-                                            cv::CALIB_CB_ADAPTIVE_THRESH | cv::CALIB_CB_FAST_CHECK |
-                                            cv::CALIB_CB_NORMALIZE_IMAGE);
-
-        if (success) {
-            cv::TermCriteria criteria(cv::TermCriteria::EPS | cv::TermCriteria::MAX_ITER, 30, 0.001);
-
-            // refining pixel coordinates for given 2d points.
-            cv::cornerSubPix(gray, corner_pts, cv::Size(11, 11), cv::Size(-1, -1), criteria);
-
-            // Displaying the detected corner points on the checker board
-            cv::drawChessboardCorners(frameCopy, cv::Size(CHECKERBOARD[0], CHECKERBOARD[1]), corner_pts, success);
-
-            objpoints.push_back(objp);
-            imgpoints.push_back(corner_pts);
-        } else {
-            i--;
-        }
-        cv::imshow("Image", frameCopy);
-        cv::waitKey(1);
-        sleep(1);
-    }
-    *stop = true;
-    cv::destroyAllWindows();
-
-    cv::Mat cameraMatrix, distCoeffs, R, T;
-
-    /*
-     * Performing camera calibration by
-     * passing the value of known 3D points (objpoints)
-     * and corresponding pixel coordinates of the
-     * detected corners (imgpoints)
-    */
-    std::cout << "calibrate dont shut down" << std::endl;
-
-    cv::calibrateCamera(objpoints, imgpoints, cv::Size(gray.rows, gray.cols), cameraMatrix, distCoeffs, R, T);
-
-    std::cout << "cameraMatrix : " << cameraMatrix << std::endl;
-    std::cout << "distCoeffs : " << distCoeffs << std::endl;
-
-    return 0;
-}
\ No newline at end of file
diff --git a/exe/check_matches.cc b/exe/check_matches.cc
deleted file mode 100644
index 6c6a541..0000000
--- a/exe/check_matches.cc
+++ /dev/null
@@ -1,148 +0,0 @@
-#include <iostream>
-#include <vector>
-#include <string>
-#include <filesystem>
-#include <opencv2/core/core.hpp>
-#include <opencv2/imgcodecs.hpp>
-#include <opencv2/features2d.hpp>
-#include "System.h"
-#include "ORBextractor.h"
-#include "ORBmatcher.h"
-
-#include "include/Auxiliary.h"
-
-int main(int argc, char **argv)
-{
-  std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-  std::ifstream programData(settingPath);
-  nlohmann::json data;
-  programData >> data;
-  programData.close();
-
-  std::string vocPath = data["VocabularyPath"];
-  std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-  std::string map_input_dir = data["mapInputDir"];
-  std::string frames_folder = data["framesFolder"];
-
-  // Load ORB_SLAM2 map and extract its descriptors
-  ORB_SLAM2::System system(vocPath, droneYamlPathSlam, ORB_SLAM2::System::MONOCULAR, true, true, map_input_dir + "simulatorMap.bin", true, false);
-  std::vector<cv::Mat> orb_slam_kf_descriptors_vector;
-  std::vector<std::vector<cv::KeyPoint>> orb_slam_kf_keypoints_vector;
-  std::vector<cv::Mat> orb_slam_kf_image_vector;
-  for (auto& KF : system.GetMap()->GetAllKeyFrames()) {
-      if (KF->image.empty())
-          continue;
-      orb_slam_kf_image_vector.emplace_back(KF->image);
-      orb_slam_kf_descriptors_vector.emplace_back(KF->mDescriptors);
-      orb_slam_kf_keypoints_vector.emplace_back(KF->mvKeys);
-  }
-
-  cv::FileStorage fSettings(droneYamlPathSlam, cv::FileStorage::READ);
-  int nFeatures = fSettings["ORBextractor.nFeatures"];
-  float fScaleFactor = fSettings["ORBextractor.scaleFactor"];
-  int nLevels = fSettings["ORBextractor.nLevels"];
-  int fIniThFAST = fSettings["ORBextractor.iniThFAST"];
-  int fMinThFAST = fSettings["ORBextractor.minThFAST"];
-
-  ORB_SLAM2::ORBextractor* mpORBextractorLeft = new ORB_SLAM2::ORBextractor(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);
-
-  // Set up ORB feature detector and matcher
-  // cv::Ptr<cv::ORB> orb = cv::ORB::create(1000, 1.2, 8);
-  cv::BFMatcher matcher(cv::NORM_HAMMING, false);
-
-  // Process images in the input folder and find the one that matches the most
-  std::string input_folder_path = frames_folder;
-    std::vector<std::string> image_paths;
-    std::vector<cv::Mat> images;
-  std::vector<std::vector<cv::KeyPoint>> keypoints_images;
-  std::vector<cv::Mat> descriptors_images;
-    std::vector<std::vector<std::vector<cv::DMatch>>> scores;
-    std::vector<std::vector<std::vector<std::vector<cv::DMatch>>>> all_matches;
-  std::vector<std::string> textures;
-  for (const auto& entry : std::filesystem::directory_iterator(input_folder_path)) {
-      textures.emplace_back(entry.path().string());
-  }
-  for (int i = 0; i < textures.size(); i++) {
-    // Load image
-    std::cout << textures[i] << std::endl;
-    cv::Mat img = cv::imread(textures[i], cv::IMREAD_GRAYSCALE);
-
-    // Extract ORB keypoints and descriptors from the image
-    std::vector<cv::KeyPoint> keypoints;
-    cv::Mat descriptors;
-    (*mpORBextractorLeft)(img,cv::Mat(),keypoints, descriptors);
-    // orb->detectAndCompute(img, cv::Mat(), keypoints, descriptors);
-
-    keypoints_images.emplace_back(keypoints);
-    image_paths.push_back(textures[i]);
-    images.push_back(img);
-    descriptors_images.push_back(descriptors);
-
-    scores.emplace_back();
-    all_matches.emplace_back();
-    for (int j = 0; j < orb_slam_kf_descriptors_vector.size(); j++)
-    {
-        // Match descriptors with the map
-        std::vector<std::vector<cv::DMatch>> matches;
-        matcher.knnMatch(descriptors, orb_slam_kf_descriptors_vector[i], matches, 2);
-
-        // Find good matches
-        std::vector<cv::DMatch> good_matches;
-        for (auto& match: matches) {
-            if (match[0].distance < 0.7 * match[1].distance) {
-                good_matches.push_back(match[0]);
-            }
-        }
-
-        all_matches[i].emplace_back(std::vector<std::vector<cv::DMatch>>{good_matches});
-
-        // Save the image path and descriptors
-        scores[i].push_back(good_matches);
-    }
-  }
-
-  // Find the image with the highest similarity score
-  int best_index_i = 0;
-  int best_index_j = 0;
-  int best_score = 0;
-  for (int i = 0; i < image_paths.size(); ++i) {
-      for (int j = 0; j < orb_slam_kf_descriptors_vector.size(); j++)
-      {
-          if (scores[i][j].size() > best_score) {
-              best_index_i = i;
-              best_index_j = j;
-              best_score = scores[i][j].size();
-          }
-      }
-  }
-
-  std::cout << "Best Image: " << image_paths[best_index_i] << " with keyframe:" << best_index_j << ", Score: " << best_score << std::endl;
-
-  std::cout << "image_paths size: " << image_paths.size() << std::endl;
-  std::cout << "keypoints_images size: " << keypoints_images.size() << std::endl;
-  std::cout << "orb_slam_kf_image_vector size: " << orb_slam_kf_image_vector.size() << std::endl;
-  std::cout << "orb_slam_kf_keypoints_vector size: " << orb_slam_kf_keypoints_vector.size() << std::endl;
-  std::cout << "all_matches size: " << all_matches.size() << std::endl;
-  std::cout << "all_matches[best_index_i] size: " << all_matches[best_index_i].size() << std::endl;
-  std::cout << "all_matches[best_index_i][best_index_j] size: " << all_matches[best_index_i][best_index_j].size() << std::endl;
-
-  if (image_paths.empty() || keypoints_images.empty() || orb_slam_kf_image_vector.empty() || orb_slam_kf_keypoints_vector.empty() || all_matches.empty() || all_matches[best_index_i].empty() || all_matches[best_index_i][best_index_j].empty()) {
-      std::cerr << "Error: empty vectors" << std::endl;
-      return -1;
-  }
-
-  cv::Mat final_image;
-  cv::drawMatches(images[best_index_i], keypoints_images[best_index_i], orb_slam_kf_image_vector[best_index_j], orb_slam_kf_keypoints_vector[best_index_j], all_matches[best_index_i][best_index_j], final_image);
-  cv::imwrite("/home/liam/Downloads/a/best_matching_texture" + std::to_string(best_index_i) + "_frame" + std::to_string(best_index_j) + ".png", final_image);
-
-  for (int i = 0; i < images.size(); i++)
-  {
-      for (int j=0; j < orb_slam_kf_image_vector.size(); j++)
-      {
-          cv::drawMatches(images[i], keypoints_images[i], orb_slam_kf_image_vector[j], orb_slam_kf_keypoints_vector[j], all_matches[i][j], final_image);
-          cv::imwrite("/home/liam/Downloads/a/matching_texture" + std::to_string(i) + "_frame" + std::to_string(j) + ".png", final_image);
-      }
-  }
-
-  return 0;
-}
diff --git a/exe/check_matches_one_by_one.cc b/exe/check_matches_one_by_one.cc
deleted file mode 100644
index bf20b39..0000000
--- a/exe/check_matches_one_by_one.cc
+++ /dev/null
@@ -1,68 +0,0 @@
-#include <iostream>
-#include <vector>
-#include <string>
-#include <filesystem>
-#include <opencv2/core/core.hpp>
-#include <opencv2/imgcodecs.hpp>
-#include <opencv2/features2d.hpp>
-#include "System.h"
-#include "ORBextractor.h"
-#include "ORBmatcher.h"
-
-#include "include/Auxiliary.h"
-
-int main(int argc, char **argv)
-{
-  std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-  std::ifstream programData(settingPath);
-  nlohmann::json data;
-  programData >> data;
-  programData.close();
-
-  std::string map_input_dir = data["mapInputDir"];
-  std::string frames_folder = data["framesFolder"];
-
-  // Set up ORB feature detector and matcher
-  cv::Ptr<cv::ORB> orb = cv::ORB::create(1000, 1.2, 8);
-  cv::BFMatcher matcher(cv::NORM_HAMMING, false);
-
-  // Process images in the input folder and find the one that matches the most
-  std::string first_image_path = frames_folder + "wall2_1.png";
-  std::string second_image_path = map_input_dir + "frame_719.png";
-
-  // Load First Image
-  cv::Mat first_image = cv::imread(first_image_path, cv::IMREAD_GRAYSCALE);
-
-  // Load First Image
-  cv::Mat second_image = cv::imread(second_image_path, cv::IMREAD_GRAYSCALE);
-
-  // Extract ORB keypoints and descriptors from the images
-  std::vector<cv::KeyPoint> key_points_first_image;
-  std::vector<cv::KeyPoint> key_points_second_image;
-  cv::Mat descriptors_first_image;
-  cv::Mat descriptors_second_image;
-  orb->detectAndCompute(first_image, cv::Mat(), key_points_first_image, descriptors_first_image);
-  orb->detectAndCompute(second_image, cv::Mat(), key_points_second_image, descriptors_second_image);
-
-  std::vector<std::vector<cv::DMatch>> matches;
-  matcher.knnMatch(descriptors_first_image, descriptors_second_image, matches, 2);
-
-  // Find good matches
-  std::vector<cv::DMatch> good_matches;
-  for (auto& match: matches) {
-      if (match[0].distance < 0.7 * match[1].distance) {
-          good_matches.push_back(match[0]);
-      }
-  }
-
-  cv::Mat final_image;
-  cv::drawMatches(first_image, key_points_first_image, second_image, key_points_second_image, good_matches, final_image);
-
-  cv::resize(final_image, final_image, cv::Size(1920, 1080), cv::INTER_LINEAR);
-  cv::imwrite("/home/liam/matching_texture.png", final_image);
-
-  cv::imshow("Matches", final_image);
-  cv::waitKey(0);
-
-  return 0;
-}
diff --git a/exe/check_matches_opencv.cc b/exe/check_matches_opencv.cc
deleted file mode 100644
index 33bd5d9..0000000
--- a/exe/check_matches_opencv.cc
+++ /dev/null
@@ -1,115 +0,0 @@
-#include <iostream>
-#include <vector>
-#include <string>
-#include <filesystem>
-#include <opencv2/core/core.hpp>
-#include <opencv2/imgcodecs.hpp>
-#include <opencv2/features2d.hpp>
-#include <opencv2/opencv.hpp>
-#include "System.h"
-#include "ORBmatcher.h"
-
-#include "include/Auxiliary.h"
-
-struct MatCompare {
-    bool operator()(const cv::Mat& a, const cv::Mat& b) const {
-        if (a.rows != b.rows || a.cols != b.cols || a.type() != b.type()) {
-            return false;
-        }
-        for (int i = 0; i < a.rows; i++) {
-            const void* a_row = a.ptr(i);
-            const void* b_row = b.ptr(i);
-            if (memcmp(a_row, b_row, a.cols*a.elemSize()) != 0) {
-                return false;
-            }
-        }
-        return true;
-    }
-};
-
-int main(int argc, char **argv)
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string vocPath = data["VocabularyPath"];
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-    std::string map_input_dir = data["mapInputDir"];
-    std::string frames_folder = data["framesFolder"];
-
-    std::set<cv::Mat, MatCompare> orbFramesDescriptorsSet;
-    cv::Ptr<cv::ORB> orb = cv::ORB::create(1000, 1.2, 8);
-    cv::BFMatcher matcher(cv::NORM_HAMMING, false);
-
-    // Process images in the input folder and find the one that matches the most
-    std::string input_folder_path = frames_folder;
-    std::vector<std::string> image_paths;
-    std::vector<cv::Mat> descriptors_images;
-    std::vector<int> scores;
-    for (const auto& orb_frame_entry : std::filesystem::directory_iterator(map_input_dir)) {
-        const std::string filename = orb_frame_entry.path().filename().string();
-        const int n = std::sscanf(filename.c_str(), "frame_%d.png", &n);
-        if (n == 0)
-        {
-            continue;
-        }
-        // Load image
-        cv::Mat orb_frame_img = cv::imread(orb_frame_entry.path().string(), cv::IMREAD_GRAYSCALE);
-
-        // Extract ORB keypoints and descriptors from the image
-        std::vector<cv::KeyPoint> orb_frame_keypoints;
-        cv::Mat orb_frame_descriptors;
-        orb->detectAndCompute(orb_frame_img, cv::Mat(), orb_frame_keypoints, orb_frame_descriptors);
-        orbFramesDescriptorsSet.insert(orb_frame_descriptors);
-    }
-    cv::Mat descriptorsFrames;
-    std::vector<cv::Mat> descriptorsVec;
-    for (auto desc : orbFramesDescriptorsSet)
-        descriptorsVec.emplace_back(desc);
-    cv::vconcat(descriptorsVec, descriptorsFrames);
-    for (const auto& entry : std::filesystem::directory_iterator(input_folder_path)) {
-        // Load image
-        cv::Mat img = cv::imread(entry.path().string(), cv::IMREAD_GRAYSCALE);
-
-        // Extract ORB keypoints and descriptors from the image
-        std::vector<cv::KeyPoint> keypoints;
-        cv::Mat descriptors;
-        orb->detectAndCompute(img, cv::Mat(), keypoints, descriptors);
-        // Match descriptors with the map
-        std::vector<std::vector<cv::DMatch>> matches;
-        matcher.knnMatch(descriptors, descriptorsFrames, matches, 2);
-
-        // Find good matches
-        std::vector<cv::DMatch> good_matches;
-        for (auto& match: matches) {
-            if (match[0].distance < 0.7 * match[1].distance) {
-                good_matches.push_back(match[0]);
-            }
-        }
-
-        // Save the image path and descriptors
-        image_paths.push_back(entry.path().string());
-        descriptors_images.push_back(descriptors);
-        scores.push_back((int)good_matches.size());
-
-        // Print the score
-        std::cout << "Image: " << entry.path().string() << ", Score: " << good_matches.size() << std::endl;
-    }
-
-    // Find the image with the highest similarity score
-    int best_index = 0;
-    double best_score = 0;
-    for (int i = 0; i < image_paths.size(); ++i) {
-        if (scores[i] > best_score) {
-            best_index = i;
-            best_score = scores[i];
-        }
-    }
-
-    std::cout << "Best Image: " << image_paths[best_index] << ", Score: " << best_score << std::endl;
-
-    return 0;
-}
diff --git a/exe/combine_frames.py b/exe/combine_frames.py
deleted file mode 100644
index f6cbb11..0000000
--- a/exe/combine_frames.py
+++ /dev/null
@@ -1,29 +0,0 @@
-import os
-import glob
-import json
-import numpy as np
-
-# Define function to load data from CSV file
-def load_data(filename):
-    data = np.loadtxt(filename, delimiter=',')
-    return data
-
-# Read the path to the CSV files from the JSON file
-with open(os.path.expanduser('../generalSettings.json'), 'r') as f:
-    settings = json.load(f)
-path_to_csv_files = os.path.expanduser(settings['framesOutput'])
-
-# Get a list of all CSV files in the directory
-files = glob.glob(os.path.join(path_to_csv_files, 'frame_*_orbs.csv'))
-
-# Initialize an empty array to store the combined data
-combined_data = np.empty((0, 3), float)
-
-# Loop through all CSV files and append the data to the combined_data array
-for filename in files:
-    data = load_data(filename)
-    combined_data = np.vstack((combined_data, data))
-
-# Save the combined data to a single CSV file
-output_file = os.path.join(path_to_csv_files, '/home/liam/combined.csv')
-np.savetxt(output_file, combined_data, delimiter=',')
diff --git a/exe/csv_to_xyz.cc b/exe/csv_to_xyz.cc
deleted file mode 100644
index a65bf41..0000000
--- a/exe/csv_to_xyz.cc
+++ /dev/null
@@ -1,65 +0,0 @@
-#include <opencv2/opencv.hpp>
-
-#include <pcl/point_types.h>
-#include <pcl/point_cloud.h>
-#include <pcl/registration/gicp.h>
-#include <pcl/io/pcd_io.h>
-
-#include "include/Auxiliary.h"
-
-// Function to read CSV file into a vector of cv::Point3d
-std::vector<cv::Point3d> readPointsFromCSV(const std::string& filePath) {
-    std::vector<cv::Point3d> points;
-    std::ifstream file(filePath);
-    std::string line;
-    double x, y, z;
-
-    while (std::getline(file, line)) {
-        std::stringstream lineStream(line);
-        std::string cell;
-
-        std::getline(lineStream, cell, ',');
-        x = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        y = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        z = std::stod(cell);
-
-        points.emplace_back(x, y, z);
-    }
-
-    return points;
-}
-
-void savePointsToXYZ(const std::string& filePath, const std::vector<cv::Point3d>& points) {
-    std::ofstream file(filePath);
-    if (!file.is_open()) {
-        std::cerr << "Cannot open file: " << filePath << std::endl;
-        return;
-    }
-
-    for (const auto& point : points) {
-        file << point.x << " " << point.y << " " << point.z << "\n";
-    }
-
-    file.close();
-}
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string orbs_csv_dir = data["framesOutput"];
-
-    std::vector<cv::Point3d> points = readPointsFromCSV(orbs_csv_dir + "cloud0.csv");
-    
-    savePointsToXYZ(orbs_csv_dir + "cloud0.xyz", points);
-
-    return 0;
- }
diff --git a/exe/get_point_data.cc b/exe/get_point_data.cc
deleted file mode 100644
index 29a9f44..0000000
--- a/exe/get_point_data.cc
+++ /dev/null
@@ -1,98 +0,0 @@
-#include <string>
-#include <iostream>
-#include <nlohmann/json.hpp>
-
-#include "include/Point.h"
-#include "include/Auxiliary.h"
-
-#define X1 (0.0649042)
-#define Y1 (-0.180186)
-#define Z1 (0.51533)
-
-#define X2 (0.118669)
-#define Y2 (-0.158835)
-#define Z2 (0.513098)
-
-void getFramesWithPoints(std::vector<std::string> row, std::map<int, Point2D>* framesWithPoint) {
-    for(int i=3; i<row.size(); i+=3) {
-        Point2D currentPoint(std::stod(row[i+1]), std::stod(row[i+2]));
-        (*framesWithPoint).insert(std::make_pair(std::stoi(row[i]), currentPoint))  ;
-    }
-}
-
-bool searchPoint(std::string csvPath, Point point, std::map<int, Point2D>* framesWithPoint) {
-    std::fstream pointData;
-    pointData.open(csvPath, std::ios::in);
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    while (!pointData.eof()) {
-        Point pointToCompare;
-
-        row.clear();
-        
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-        
-        pointToCompare = Point(std::stod(row[0]), std::stod(row[1]), std::stod(row[2]));
-        if (point.compare(pointToCompare)) {
-            getFramesWithPoints(row, framesWithPoint);
-            pointData.close();
-            return true;
-        }
-    }
-    pointData.close();
-    return false;
-}
-
-void searchAllPoints(std::string csvPath, std::vector<Point> points, std::vector<std::map<int, Point2D>>* framesWithPoints) {
-    for (auto point : points) {
-        std::map<int, Point2D> framesWithPoint;
-        if (!searchPoint(csvPath, point, &framesWithPoint)) {
-            std::cout << "Point (" << point.x << ", " << point.y << ", " << point.z << ") is not in the cloud points!" << std::endl;
-        }
-        (*framesWithPoints).push_back(framesWithPoint);
-    }
-}
-
-void printFrames(std::vector<Point> points, std::vector<std::map<int, Point2D>> framesWithPoints) {
-    for (int i=0; i < framesWithPoints.size(); i++) {
-        std::cout << "Point (" << points[i].x << ", " << points[i].y << ", " << points[i].z << ")" << std::endl;
-        for(const auto &myPair : framesWithPoints[i])
-        {
-            std::cout << "\t" << myPair.first << ": (" << myPair.second.x << ", " << myPair.second.y << ")" << std::endl;
-        }
-    }
-}
-
-int main() {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string csvPath = data["getPointDataCsv"];
-    std::vector<std::map<int, Point2D>> framesWithPoints;
-    std::vector<Point> points;
-
-    points.push_back(Point(X1, Y1, Z1));
-    points.push_back(Point(X2, Y2, Z2));
-
-    searchAllPoints(csvPath, points, &framesWithPoints);
-
-    printFrames(points, framesWithPoints);
-
-    return 0;
-}
-
diff --git a/exe/get_points_from_frame_orb_slam.cc b/exe/get_points_from_frame_orb_slam.cc
deleted file mode 100644
index 33952fd..0000000
--- a/exe/get_points_from_frame_orb_slam.cc
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <string>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "System.h"
-#include "include/Auxiliary.h"
-
-using namespace ORB_SLAM2;
-
-int main(int argc, char **argv)
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string vocPath = data["VocabularyPath"];
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-    std::string map_input_dir = data["mapInputDir"];
-    // Load the ORB-SLAM2 system
-    System system(vocPath, droneYamlPathSlam, System::MONOCULAR, true, true, map_input_dir + "simulatorMap.bin", true, false);
-
-    // Track the monocular camera and get the current camera pose
-    int frame_to_check = data["frameToCheck"];
-    cv::Mat image = cv::imread(map_input_dir + "frame_" + std::to_string(frame_to_check) + ".png");
-    cv::Mat pose = system.TrackMonocular(image, 0);
-
-     // Get the current Frame
-    Frame currentFrame = system.GetTracker()->mCurrentFrame;
-
-    std::vector<MapPoint*> frame_points = currentFrame.mvpMapPoints;
-
-    int counter = 0;
-
-    for (auto point : frame_points)
-    {
-        if (point)
-        {
-            cv::Mat currPoint = point->GetWorldPos();
-            std::cout << "(" << currPoint.at<float>(0) << ", " << currPoint.at<float>(1) << ", " << currPoint.at<float>(2) << ")" << std::endl;
-            counter++;
-        }
-    }
-
-    std::cout << "total: " << frame_points.size() << std::endl;
-    std::cout << "Valid: " << counter << std::endl;
-
-    return 0;
-}
diff --git a/exe/get_pos_from_frame_orb_slam.cc b/exe/get_pos_from_frame_orb_slam.cc
deleted file mode 100644
index b838e50..0000000
--- a/exe/get_pos_from_frame_orb_slam.cc
+++ /dev/null
@@ -1,49 +0,0 @@
-#include <string>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "System.h"
-#include "include/Auxiliary.h"
-
-using namespace ORB_SLAM2;
-
-int main(int argc, char **argv)
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string vocPath = data["VocabularyPath"];
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-    std::string map_input_dir = data["mapInputDir"];
-    // Load the ORB-SLAM2 system
-    System system(vocPath, droneYamlPathSlam, System::MONOCULAR, true, true, map_input_dir + "simulatorMap.bin", true, false);
-
-    // Track the monocular camera and get the current camera pose
-    int frame_to_check = data["frameToCheck"];
-    cv::Mat image = cv::imread(map_input_dir + "frame_" + std::to_string(frame_to_check) + ".png");
-    cv::Mat pose = system.TrackMonocular(image, 0);
-
-    std::cout << "Pose: " << pose << std::endl;
-
-    if (!pose.empty()) {
-        // Extract position from pose matrix
-        double x = pose.at<float>(0,3);
-        double y = pose.at<float>(1,3);
-        double z = pose.at<float>(2,3);
-
-        cv::Point3d camera_position(x, y, z);
-
-        // Extract orientation from pose matrix
-        double yaw, pitch, roll;
-        yaw = atan2(pose.at<float>(1,0), pose.at<float>(0,0));
-        pitch = atan2(-pose.at<float>(2,0), sqrt(pose.at<float>(2,1)*pose.at<float>(2,1) + pose.at<float>(2,2)*pose.at<float>(2,2)));
-        roll = atan2(pose.at<float>(2,1), pose.at<float>(2,2));
-
-        std::cout << "camera position: " << camera_position << std::endl << "yaw: " << yaw << ", pitch: " << pitch << ", roll: " << roll << std::endl;
-    }
-
-    return 0;
-}
diff --git a/exe/icp_model_orb_slam.py b/exe/icp_model_orb_slam.py
deleted file mode 100644
index d274ae0..0000000
--- a/exe/icp_model_orb_slam.py
+++ /dev/null
@@ -1,160 +0,0 @@
-import os
-import json
-import glob
-import numpy as np
-from sklearn.neighbors import NearestNeighbors
-
-from numpy.linalg import norm
-
-
-def best_fit_transform(A, B):
-    '''
-    Calculates the least-squares best-fit transform that maps corresponding points A to B in m spatial dimensions
-    Input:
-      A: Nxm numpy array of corresponding points
-      B: Nxm numpy array of corresponding points
-    Returns:
-      T: (m+1)x(m+1) homogeneous transformation matrix that maps A on to B
-      R: mxm rotation matrix
-      t: mx1 translation vector
-    '''
-
-    assert A.shape == B.shape
-
-    # get number of dimensions
-    m = A.shape[1]
-
-    # translate points to their centroids
-    centroid_A = np.mean(A, axis=0)
-    centroid_B = np.mean(B, axis=0)
-    AA = A - centroid_A
-    BB = B - centroid_B
-
-    # rotation matrix
-    H = np.dot(AA.T, BB)
-    U, S, Vt = np.linalg.svd(H)
-    R = np.dot(Vt.T, U.T)
-
-    # special reflection case
-    if np.linalg.det(R) < 0:
-       Vt[m-1,:] *= -1
-       R = np.dot(Vt.T, U.T)
-
-    # translation
-    t = centroid_B.T - np.dot(R,centroid_A.T)
-
-    # homogeneous transformation
-    T = np.identity(m+1)
-    T[:m, :m] = R
-    T[:m, m] = t
-
-    return T, R, t
-
-
-def nearest_neighbor(src, dst):
-    '''
-    Find the nearest (Euclidean) neighbor in dst for each point in src
-    Input:
-        src: Nxm array of points
-        dst: Nxm array of points
-    Output:
-        distances: Euclidean distances of the nearest neighbor
-        indices: dst indices of the nearest neighbor
-    '''
-
-    # assert src.shape == dst.shape
-
-    neigh = NearestNeighbors(n_neighbors=1)
-    neigh.fit(dst)
-    distances, indices = neigh.kneighbors(src, return_distance=True)
-    return distances.ravel(), indices.ravel()
-
-
-def icp_NN(A, B, init_pose=None, max_iterations=20, tolerance=0.001):
-    '''
-    The Iterative Closest Point method: finds best-fit transform that maps points A on to points B
-    Input:
-        A: Nxm numpy array of source mD points
-        B: Nxm numpy array of destination mD point
-        init_pose: (m+1)x(m+1) homogeneous transformation
-        max_iterations: exit algorithm after max_iterations
-        tolerance: convergence criteria
-    Output:
-        T: final homogeneous transformation that maps A on to B
-        distances: Euclidean distances (errors) of the nearest neighbor
-        i: number of iterations to converge
-    '''
-
-    # assert A.shape == B.shape
-
-    # get number of dimensions
-    m = A.shape[1]
-
-    # make points homogeneous, copy them to maintain the originals
-    src = np.ones((m+1,A.shape[0]))
-    dst = np.ones((m+1,B.shape[0]))
-    src[:m,:] = np.copy(A.T)
-    dst[:m,:] = np.copy(B.T)
-
-    # apply the initial pose estimation
-    if init_pose is not None:
-        src = np.dot(init_pose, src)
-
-    prev_error = 0
-
-    for i in range(max_iterations):
-        # find the nearest neighbors between the current source and destination points
-        distances, indices = nearest_neighbor(src[:m,:].T, dst[:m,:].T)
-
-        # compute the transformation between the current source and nearest destination points
-        T,_,_ = best_fit_transform(src[:m,:].T, dst[:m,indices].T)
-
-        # update the current source
-        src = np.dot(T, src)
-        # check error
-        mean_error = np.mean(distances)
-        if np.abs(prev_error - mean_error) < tolerance:
-            break
-        prev_error = mean_error
-
-    # calculate final transformation
-    T, R, t = best_fit_transform(A, src[:m,:].T)
-
-    return T, distances, i, R, t
-
-
-def main():
-    # Read the path to the CSV files from the JSON file
-    with open(os.path.expanduser('../generalSettings.json'), 'r') as f:
-        settings = json.load(f)
-    path_to_csv_files = os.path.expanduser(settings['framesOutput'])
-    path_to_cloud_points_orb_slam = os.path.expanduser(settings['mapInputDir'])
-    path_to_cloud_points_orb_slam += "cloud1.csv"
-
-    # Get a list of all CSV files in the directory
-    files = glob.glob(os.path.join(path_to_csv_files, 'frame_*_orbs.csv'))
-
-    # Initialize an empty list to store the point clouds
-    point_clouds = []
-
-    # Loop through all CSV files and plot the points
-    for filename in files:
-        point_cloud = np.genfromtxt(filename, delimiter=',', usecols=(0, 1, 2))
-        point_clouds.append(point_cloud)
-
-    # Load point clouds from CSV files
-    point_cloud_A = np.vstack(point_clouds)
-    point_cloud_B = np.genfromtxt(path_to_cloud_points_orb_slam, delimiter=',', usecols=(0, 1, 2))
-
-    # Run the ICP algorithm
-    transformation_mat, distances, iterations, rotation_mat, translation_vector = icp_NN(point_cloud_A, point_cloud_B)
-
-    # Save the transformation matrix to a CSV file
-    np.savetxt(path_to_csv_files + 'frames_lab_transformation_matrix.csv', transformation_mat, delimiter=',', fmt='%.6f')
-
-    # Print a confirmation message
-    print(f"Transformation matrix saved to '{path_to_csv_files + 'frames_lab_transformation_matrix.csv'}'")
-
-
-if __name__ == "__main__":
-    main()
diff --git a/exe/icp_model_orbs_slam.cc b/exe/icp_model_orbs_slam.cc
deleted file mode 100644
index 0b31784..0000000
--- a/exe/icp_model_orbs_slam.cc
+++ /dev/null
@@ -1,220 +0,0 @@
-#include <opencv2/opencv.hpp>
-#include <vector>
-
-#include <pcl/point_types.h>
-#include <pcl/point_cloud.h>
-#include <pcl/registration/gicp.h>
-#include <pcl/common/transforms.h>
-#include <pcl/io/pcd_io.h>
-
-#include "include/Auxiliary.h"
-
-// Function to read CSV file into a vector of cv::Point3d
-std::vector<cv::Point3d> readPointsFromCSV(const std::string& filePath) {
-    std::vector<cv::Point3d> points;
-    std::ifstream file(filePath);
-    std::string line;
-    double x, y, z;
-
-    while (std::getline(file, line)) {
-        std::stringstream lineStream(line);
-        std::string cell;
-
-        std::getline(lineStream, cell, ',');
-        x = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        y = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        z = std::stod(cell);
-
-        points.emplace_back(x, y, z);
-    }
-
-    return points;
-}
-
-// Function to read XYZ file into a vector of cv::Point3d
-std::vector<cv::Point3d> readPointsFromXYZ(const std::string& filePath) {
-    std::vector<cv::Point3d> points;
-    std::ifstream file(filePath);
-    std::string line;
-    double x, y, z;
-
-    while (std::getline(file, line)) {
-        std::stringstream lineStream(line);
-        std::string cell;
-
-        std::getline(lineStream, cell, ' ');
-        x = std::stod(cell);
-
-        std::getline(lineStream, cell, ' ');
-        y = std::stod(cell);
-
-        std::getline(lineStream, cell, ' ');
-        z = std::stod(cell);
-
-        points.emplace_back(x, y, z);
-    }
-
-    return points;
-}
-
-// Function to convert std::vector<cv::Point3d> to pcl::PointCloud<pcl::PointXYZ>
-pcl::PointCloud<pcl::PointXYZ>::Ptr toPointCloud(const std::vector<cv::Point3d>& points) {
-    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
-    for (const auto& point : points) {
-        cloud->push_back(pcl::PointXYZ((float)point.x, (float)point.y, (float)point.z));
-    }
-    return cloud;
-}
-
-void saveMatrixToFile(const Eigen::Matrix4f &matrix, const std::string &filename) {
-    std::ofstream outfile(filename);
-
-    if (outfile.is_open()) {
-        for (int row = 0; row < matrix.rows(); ++row) {
-            for (int col = 0; col < matrix.cols(); ++col) {
-                outfile << matrix(row, col);
-                if (col != matrix.cols() - 1) {
-                    outfile << ",";
-                }
-            }
-            outfile << "\n";
-        }
-        outfile.close();
-    } else {
-        std::cerr << "Cannot open file: " << filename << std::endl;
-    }
-}
-
-void savePointsToXYZ(const std::string& filePath, const pcl::PointCloud<pcl::PointXYZ>& cloud) {
-    std::ofstream file(filePath);
-    if (!file.is_open()) {
-        std::cerr << "Cannot open file: " << filePath << std::endl;
-        return;
-    }
-
-    for (const auto& point : cloud) {
-        file << point.x << " " << point.y << " " << point.z << "\n";
-    }
-
-    file.close();
-}
-
-// Compute scale using centroids and standard deviations
-float compute_scale (const pcl::PointCloud<pcl::PointXYZ>::Ptr src, const pcl::PointCloud<pcl::PointXYZ>::Ptr tgt)
-{
-    Eigen::Vector4f src_centroid, tgt_centroid;
-    pcl::compute3DCentroid(*src, src_centroid);
-    pcl::compute3DCentroid(*tgt, tgt_centroid);
-
-    float src_avg_dist = 0.0, tgt_avg_dist = 0.0;
-    for (const auto& point : *src)
-    {
-        src_avg_dist += sqrt(pow(point.x - src_centroid[0], 2) +
-                             pow(point.y - src_centroid[1], 2) +
-                             pow(point.z - src_centroid[2], 2));
-    }
-    src_avg_dist /= src->size();
-
-    for (const auto& point : *tgt)
-    {
-        tgt_avg_dist += sqrt(pow(point.x - tgt_centroid[0], 2) +
-                             pow(point.y - tgt_centroid[1], 2) +
-                             pow(point.z - tgt_centroid[2], 2));
-    }
-    tgt_avg_dist /= tgt->size();
-
-    float scale = tgt_avg_dist / src_avg_dist;
-
-    return scale;
-}
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Load the image
-    std::string orbs_csv_dir = data["framesOutput"];
-
-    std::vector<cv::Point3d> cloudPoints1;
-    std::vector<cv::Point3d> cloudPoints2;
-
-    std::string cloud_points_combined_frames_filename = orbs_csv_dir + "b1_combined_frames_points_without_outliers.xyz";
-    std::string cloud_points_orb_slam_filename = orbs_csv_dir + "b2_orb_slam_map_points_without_outliers.xyz";
-
-    // Read points from the single XYZ file
-    cloudPoints1 = readPointsFromXYZ(cloud_points_orb_slam_filename);
-    cloudPoints2 = readPointsFromXYZ(cloud_points_combined_frames_filename);
-
-    // Convert std::vector<cv::Point3d> to pcl::PointCloud<pcl::PointXYZ>
-    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud1 = toPointCloud(cloudPoints1);
-    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud2 = toPointCloud(cloudPoints2);
-
-    // Compute scale
-    bool is_predefined_scale = (bool)data["usePredefinedScale"];
-    float scale = 0;
-    if (is_predefined_scale) {
-        scale = (float)data["predefinedScale"];
-        std::cout << "Using predefined scale: " << scale << std::endl;
-    }
-    else {
-        scale = compute_scale(cloud1, cloud2);
-        std::cout << "Computed scale: " << scale << std::endl;
-    }
-
-    // Scale the source point cloud
-    for (size_t i = 0; i < cloud1->points.size(); ++i)
-    {
-        cloud1->points[i].x *= scale;
-        cloud1->points[i].y *= scale;
-        cloud1->points[i].z *= scale;
-    }
-
-    savePointsToXYZ(orbs_csv_dir + "c2_orb_slam_map_points_without_outliers.xyz", *cloud1);
-    savePointsToXYZ(orbs_csv_dir + "c1_combined_frames_points_without_outliers.xyz", *cloud2);
-
-    pcl::PCDWriter().write(orbs_csv_dir + "d2_orb_slam_map_points_without_outliers.pcd", *cloud1);
-    pcl::PCDWriter().write(orbs_csv_dir + "d1_combined_frames_points_without_outliers.pcd", *cloud2);
-
-    // Create GICP instance
-    pcl::GeneralizedIterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> gicp;
-    gicp.setInputSource(cloud1);
-    gicp.setInputTarget(cloud2);
-
-    // Perform GICP
-    pcl::PointCloud<pcl::PointXYZ> Final;
-    gicp.align(Final);
-
-    // Check convergence and obtain transformation matrix
-    if (gicp.hasConverged()) {
-        std::cout << "ICP has converged with score: " << gicp.getFitnessScore() << std::endl;
-
-        Eigen::Matrix4f transformation = gicp.getFinalTransformation();
-
-        std::cout << "Estimated scale factor: " << scale << std::endl;
-        std::cout << "ICP Transformation Matrix with scale:\n" << transformation << std::endl;
-
-        // Apply the updated transformation to the input cloud
-        pcl::PointCloud<pcl::PointXYZ> transformed_cloud;
-        pcl::transformPointCloud(*cloud1, transformed_cloud, transformation);
-
-        std::string transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_transformation_matrix.csv";
-        saveMatrixToFile(transformation, transformation_matrix_csv_path);
-
-        std::string transformed_points_csv_path = std::string(data["framesOutput"]) + "transformed_points.xyz";
-        savePointsToXYZ(transformed_points_csv_path, transformed_cloud);
-
-
-    } else {
-        std::cout << "ICP did not converge." << std::endl;
-    }
-
-    return 0;
- }
diff --git a/exe/mapping.cc b/exe/mapping.cc
deleted file mode 100644
index 28ba812..0000000
--- a/exe/mapping.cc
+++ /dev/null
@@ -1,98 +0,0 @@
-#include <System.h>
-#include <unistd.h>
-
-#include <ctime>
-#include <filesystem>
-#include <fstream>
-#include <iostream>
-#include <opencv2/core/core.hpp>
-#include <boost/algorithm/string/replace.hpp>
-
-#include "include/Auxiliary.h"
-
-
-std::string create_new_directory_named_current_time() {
-    // current date/time based on current system
-    time_t now = time(0);
-
-    std::string tmp = std::string("./mapping-");
-    std::string directory_named_time = tmp + std::string(ctime(&now));
-    directory_named_time = boost::replace_all_copy(directory_named_time, " ", "-");
-
-    std::filesystem::create_directories(directory_named_time);
-    return directory_named_time;
-}
-
-/**
- * @brief This Program tries to create a map for the executable program
- * tello_main
- *
- * this program is just orbslam with a drone, every movement is manual.
- * This function create the a folder with the files Slam_latest_Map.bin
- * ,pointData.xyz, pointData.csv, drone_destinations.txt
- * @param argc  argv[0]=file name , argv[1]=ORBvoc.txt
- * ,argv[2]=tello_9F5EC2_640.yaml
- * @param argv
- * @return int return 0 if didn't crush , if crushed do map again
- */
-int main(int argc, char **argv) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    bool bReuse = data["continue"];
-    std::string directory_named_time =
-        create_new_directory_named_current_time();
-    std::string Slam_lastest_Map_location =
-        !bReuse ? directory_named_time + "/Slam_latest_Map.bin"
-                : "Slam_latest_Map.bin";
-    ORB_SLAM2::System SLAM(data["VocabularyPath"], data["DroneYamlPathSlam"], ORB_SLAM2::System::MONOCULAR, true,
-                           bReuse, Slam_lastest_Map_location, bReuse);
-    bool use_drone = true;
-    if (data["webcam"])
-        use_drone = false;
-    cv::VideoCapture cap;
-    cv::VideoWriter writer;
-    writer.open("./" + directory_named_time + "/mapping.avi", cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 30.0, cv::Size(640, 480), true);
-    if (use_drone) {
-        //  drone.tello_stream_on();
-    } else {
-        cap.open(0);
-    }
-
-    int frame_cnt = 0;
-    while (true) {
-        if (SLAM.shutdown_requested) {
-            break;
-        }
-
-        frame_cnt++;
-
-        cv::Mat frame;
-        if (use_drone) {
-            // frame = drone.get_frame();
-        }
-        else {
-            cap >> frame;
-        }
-        if (frame.empty()) {
-            usleep(20000);
-            continue;
-        }
-
-        cv::resize(frame, frame, cv::Size(640, 480));
-        writer.write(frame);
-
-        cv::Mat pose = SLAM.TrackMonocular(frame, frame_cnt);
-    }
-
-    std::cout << "Finished..." << std::endl;
-
-    SLAM.Shutdown();
-    SLAM.SaveMap(Slam_lastest_Map_location);
-    cvDestroyAllWindows();
-
-    return 0;
-}
diff --git a/exe/pcd_to_xyz.cc b/exe/pcd_to_xyz.cc
deleted file mode 100644
index ec44041..0000000
--- a/exe/pcd_to_xyz.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-#include <opencv2/opencv.hpp>
-
-#include <pcl/point_types.h>
-#include <pcl/point_cloud.h>
-#include <pcl/registration/gicp.h>
-#include <pcl/io/pcd_io.h>
-
-#include "include/Auxiliary.h"
-
-void savePointsToXYZ(const std::string& filePath, const pcl::PointCloud<pcl::PointXYZ>& cloud) {
-    std::ofstream file(filePath);
-    if (!file.is_open()) {
-        std::cerr << "Cannot open file: " << filePath << std::endl;
-        return;
-    }
-
-    for (const auto& point : cloud) {
-        file << point.x << " " << point.y << " " << point.z << "\n";
-    }
-
-    file.close();
-}
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string orbs_csv_dir = data["framesOutput"];
-
-    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud1(new pcl::PointCloud<pcl::PointXYZ>);
-
-    std::string cloud_points_combined_frames_filename = orbs_csv_dir + "e1_combined_frames_points_without_outliers.pcd";
-
-    pcl::io::loadPCDFile<pcl::PointXYZ>(cloud_points_combined_frames_filename, *cloud1);
-    savePointsToXYZ(orbs_csv_dir + "f1_combined_frames_points_without_outliers.xyz", *cloud1);
-
-    return 0;
- }
diff --git a/exe/plot.py b/exe/plot.py
deleted file mode 100644
index 2f93f53..0000000
--- a/exe/plot.py
+++ /dev/null
@@ -1,34 +0,0 @@
-import os
-import glob
-import json
-import matplotlib.pyplot as plt
-import numpy as np
-from mpl_toolkits.mplot3d import Axes3D
-
-# Define function to load data from CSV file
-def load_data(filename):
-    data = np.loadtxt(filename, delimiter=',', usecols=[0,1,2])
-    x = data[:, 0]
-    y = data[:, 1]
-    z = data[:, 2]
-    return x, y, z
-
-# Create a 3D axes object
-fig = plt.figure()
-ax = fig.add_subplot(111, projection='3d')
-
-# Loop through all CSV files and plot the points
-x, y, z = load_data("/home/liam/Documents/slamMaps/example_mapping11/cloud1.csv")
-ax.scatter(x, y, z, s=1)
-
-# Set the axis labels and limits
-ax.set_xlabel('X')
-ax.set_ylabel('Y')
-ax.set_zlabel('Z')
-ax.set_xlim(-10, 10)
-ax.set_ylim(-10, 10)
-ax.set_zlim(-10, 10)
-
-# Add a legend and show the plot
-ax.legend()
-plt.show()
diff --git a/exe/plot_orbs.py b/exe/plot_orbs.py
deleted file mode 100644
index 15be5fa..0000000
--- a/exe/plot_orbs.py
+++ /dev/null
@@ -1,43 +0,0 @@
-import os
-import glob
-import json
-import matplotlib.pyplot as plt
-import numpy as np
-from mpl_toolkits.mplot3d import Axes3D
-
-# Define function to load data from CSV file
-def load_data(filename):
-    data = np.loadtxt(filename, delimiter=',')
-    x = data[:, 0]
-    y = data[:, 1]
-    z = data[:, 2]
-    return x, y, z
-
-# Read the path to the CSV files from the JSON file
-with open(os.path.expanduser('../generalSettings.json'), 'r') as f:
-    settings = json.load(f)
-path_to_csv_files = os.path.expanduser(settings['framesOutput'])
-
-# Create a 3D axes object
-fig = plt.figure()
-ax = fig.add_subplot(111, projection='3d')
-
-# Get a list of all CSV files in the directory
-files = glob.glob(os.path.join(path_to_csv_files, 'frame_*_orbs.csv'))
-
-# Loop through all CSV files and plot the points
-for filename in files:
-    x, y, z = load_data(filename)
-    ax.scatter(x, y, z, s=1)
-
-# Set the axis labels and limits
-ax.set_xlabel('X')
-ax.set_ylabel('Y')
-ax.set_zlabel('Z')
-ax.set_xlim(-10, 10)
-ax.set_ylim(-10, 10)
-ax.set_zlim(-10, 10)
-
-# Add a legend and show the plot
-ax.legend()
-plt.show()
diff --git a/exe/points_seen_by_frame_data.cc b/exe/points_seen_by_frame_data.cc
deleted file mode 100644
index fdc8cb8..0000000
--- a/exe/points_seen_by_frame_data.cc
+++ /dev/null
@@ -1,59 +0,0 @@
-#include <math.h>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    int frame_to_check = data["frameToCheck"];
-    std::string map_input_dir = data["mapInputDir"];
-
-    std::ifstream pointData;
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    pointData.open(map_input_dir + "frameData" + std::to_string(frame_to_check) + ".csv");
-    
-    std::getline(pointData, line);
-
-    std::stringstream words(line);
-
-    while (std::getline(words, word, ',')) {
-        row.push_back(word);
-    }
-
-    pointData.close();
-    
-    // Extract the camera position
-    double x = stod(row[1]);
-    double y = stod(row[2]);
-    double z = stod(row[3]);
-
-    cv::Point3d camera_position(x, y, z);
-
-    double yaw = stod(row[4]);
-    double pitch = stod(row[5]);
-    double roll = stod(row[6]);
-
-    const std::string cloud_points = map_input_dir + "cloud1.csv";
-
-    cv::Mat Twc;
-
-    std::vector<cv::Point3d> seen_points = Auxiliary::getPointsFromPos(cloud_points, camera_position, yaw, pitch, roll, Twc);
-    
-    for(cv::Point3d point: seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-    std::cout << "total: " << seen_points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/points_seen_by_frames.cc b/exe/points_seen_by_frames.cc
deleted file mode 100644
index b54966f..0000000
--- a/exe/points_seen_by_frames.cc
+++ /dev/null
@@ -1,69 +0,0 @@
-#include <math.h>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    double amount = data["amount"];
-    std::string map_input_dir = data["mapInputDir"];
-    const std::string cloud_points = map_input_dir + "cloud1.csv";
-
-    std::ifstream pointData;
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    std::vector<cv::Point3d> seen_points;
-
-    std::vector<std::string> frames_datas = Auxiliary::GetFrameDatas(amount);
-
-    for(std::string frame : frames_datas)
-    {
-        row.clear();
-
-        pointData.open(frame);
-    
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-
-        pointData.close();
-        
-        // Extract the camera position
-        double x = stod(row[1]);
-        double y = stod(row[2]);
-        double z = stod(row[3]);
-
-        cv::Point3d camera_position(x, y, z);
-
-        double yaw = stod(row[4]);
-        double pitch = stod(row[5]);
-        double roll = stod(row[6]);
-
-        cv::Mat Twc;
-
-        std::vector<cv::Point3d> new_points = Auxiliary::getPointsFromPos(cloud_points, camera_position, yaw, pitch, roll, Twc);
-
-        Auxiliary::add_unique_points(seen_points, new_points);
-    }
-    
-    for(cv::Point3d point: seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-    std::cout << "total: " << seen_points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/points_seen_by_pos.cc b/exe/points_seen_by_pos.cc
deleted file mode 100644
index dde8ca5..0000000
--- a/exe/points_seen_by_pos.cc
+++ /dev/null
@@ -1,165 +0,0 @@
-#include <math.h>
-#include <eigen3/Eigen/Core>
-#include <eigen3/Eigen/Geometry>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-     std::ifstream pointData;
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-    
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-
-    // Check settings file
-    cv::FileStorage fsSettings(droneYamlPathSlam, cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << droneYamlPathSlam << std::endl;
-       exit(-1);
-    }
-
-    std::string map_input_dir = data["mapInputDir"];
-    std::string vocPath = data["VocabularyPath"];
-    
-    // Extract the camera position
-    double x = data["startingCameraPosX"];
-    double y = data["startingCameraPosY"];
-    double z = data["startingCameraPosZ"];
-
-    cv::Point3d camera_position(x, y, z);
-
-    double yaw_rad = data["yawRad"];
-    double pitch_rad = data["pitchRad"];
-    double roll_rad = data["rollRad"];
-
-    double fx = fsSettings["Camera.fx"];
-    double fy = fsSettings["Camera.fy"];
-    double cx = fsSettings["Camera.cx"];
-    double cy = fsSettings["Camera.cy"];
-    int width = fsSettings["Camera.width"];
-    int height = fsSettings["Camera.height"];
-
-    double minX = 3.7;
-    double maxX = width;
-    double minY = 3.7;
-    double maxY = height;
-
-    Eigen::Matrix4d Tcw_eigen = Eigen::Matrix4d::Identity();
-    Tcw_eigen.block<3, 3>(0, 0) = (Eigen::AngleAxisd(yaw_rad, Eigen::Vector3d::UnitZ()) * 
-                             Eigen::AngleAxisd(pitch_rad, Eigen::Vector3d::UnitY()) *
-                             Eigen::AngleAxisd(roll_rad, Eigen::Vector3d::UnitX())).toRotationMatrix();
-    Tcw_eigen.block<3, 1>(0, 3) << camera_position.x, camera_position.y, camera_position.z;
-
-    cv::Mat Tcw = cv::Mat::eye(4, 4, CV_64FC1);
-    for(int i=0;i<4;i++){
-        for(int j=0;j<4;j++){
-            Tcw.at<double>(i,j) = Tcw_eigen(i,j);
-        }
-    }
-
-    cv::Mat Rcw = Tcw.rowRange(0,3).colRange(0,3);
-    cv::Mat Rwc = Rcw.t();
-    cv::Mat tcw = Tcw.rowRange(0,3).col(3);
-    cv::Mat mOw = -Rcw.t()*tcw;
-
-    std::vector<cv::Vec<double, 8>> points;
-
-    pointData.open(map_input_dir + "cloud1.csv", std::ios::in);
-
-    while (!pointData.eof()) {
-        row.clear();
-        
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            try 
-            {
-                std::stod(word);
-            } 
-            catch(std::out_of_range)
-            {
-                word = "0";
-            }
-            row.push_back(word);
-        }
-        points.push_back(cv::Vec<double, 8>(std::stod(row[0]), std::stod(row[1]), std::stod(row[2]), std::stod(row[3]), std::stod(row[4]), std::stod(row[5]), std::stod(row[6]), std::stod(row[7])));
-    }
-    pointData.close();
-
-    std::vector<cv::Point3d> seen_points;
-
-    for(cv::Vec<double, 8>  point : points)
-    {
-        cv::Mat worldPos = cv::Mat::zeros(3, 1, CV_64F);
-        worldPos.at<double>(0) = point[0];
-        worldPos.at<double>(1) = point[1];
-        worldPos.at<double>(2) = point[2];
-
-        const cv::Mat Pc = Rcw*worldPos+tcw;
-        const double &PcX = Pc.at<double>(0);
-        const double &PcY= Pc.at<double>(1);
-        const double &PcZ = Pc.at<double>(2);
-
-        // Check positive depth
-        if(PcZ<0.0f)
-            continue;
-
-        // Project in image and check it is not outside
-        const double invz = 1.0f/PcZ;
-        const double u=fx*PcX*invz+cx;
-        const double v=fy*PcY*invz+cy;
-
-        if(u<minX || u>maxX)
-            continue;
-        if(v<minY || v>maxY)
-            continue;
-
-        // Check distance is in the scale invariance region of the MapPoint
-        const double minDistance = point[3];
-        const double maxDistance = point[4];
-        const cv::Mat PO = worldPos-mOw;
-        const double dist = cv::norm(PO);
-
-        if(dist<minDistance || dist>maxDistance)
-            continue;
-
-        // Check viewing angle
-        cv::Mat Pn = cv::Mat(3, 1, CV_64F);
-        Pn.at<double>(0) = point[5];
-        Pn.at<double>(1) = point[6];
-        Pn.at<double>(2) = point[7];
-
-        const double viewCos = PO.dot(Pn)/dist;
-
-        if(viewCos<0.5)
-            continue;
-
-        seen_points.push_back(cv::Point3d(worldPos.at<double>(0), worldPos.at<double>(1), worldPos.at<double>(2)));
-    }
-    
-    for(cv::Point3d point: seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-    std::cout << "total: " << seen_points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/remove_outliers.cc b/exe/remove_outliers.cc
deleted file mode 100644
index 632c78f..0000000
--- a/exe/remove_outliers.cc
+++ /dev/null
@@ -1,110 +0,0 @@
-#include "include/Auxiliary.h"
-
-// Function to read XYZ file into a vector of cv::Point3d
-std::vector<cv::Point3d> readPointsFromXYZ(const std::string& filePath) {
-    std::vector<cv::Point3d> points;
-    std::ifstream file(filePath);
-    std::string line;
-    double x, y, z;
-
-    while (std::getline(file, line)) {
-        std::stringstream lineStream(line);
-        std::string cell;
-
-        std::getline(lineStream, cell, ' ');
-        x = std::stod(cell);
-
-        std::getline(lineStream, cell, ' ');
-        y = std::stod(cell);
-
-        std::getline(lineStream, cell, ' ');
-        z = std::stod(cell);
-
-        points.emplace_back(x, y, z);
-    }
-
-    return points;
-}
-
-void savePointsToXYZ(const std::string& filePath, std::vector<cv::Point3d> cloud) {
-    std::ofstream file(filePath);
-    if (!file.is_open()) {
-        std::cerr << "Cannot open file: " << filePath << std::endl;
-        return;
-    }
-
-    for (const auto& point : cloud) {
-        file << point.x << " " << point.y << " " << point.z << "\n";
-    }
-
-    file.close();
-}
-
-cv::Point3d computeCentroid(std::vector<cv::Point3d>& points) {
-    // Compute the centroid
-    cv::Point3d centroid(0, 0, 0);
-    for (const cv::Point3d& p : points) {
-        centroid += p;
-    }
-    centroid.x /= points.size();
-    centroid.y /= points.size();
-    centroid.z /= points.size();
-
-    return centroid;
-}
-
-void removeFarthestPoints(std::vector<cv::Point3d>& points, double percent_to_remove) {
-    // Compute the centroid
-    cv::Point3d centroid = computeCentroid(points);
-
-    // Calculate distance of each point from centroid and store it along with the point
-    std::vector<std::pair<double, cv::Point3d>> distanceAndPoints;
-    for (const cv::Point3d& p : points) {
-        double distance = cv::norm(p - centroid);
-        distanceAndPoints.push_back({distance, p});
-    }
-
-    // Sort the points based on distance
-    std::sort(distanceAndPoints.begin(), distanceAndPoints.end(),
-              [](const std::pair<double, cv::Point3d>& a, const std::pair<double, cv::Point3d>& b) {
-                  return a.first < b.first; // ascending order
-              });
-
-    // Remove the farthest points based on percent_to_remove
-    int removeCount = static_cast<int>(points.size() * percent_to_remove / 100.0);
-    distanceAndPoints.resize(distanceAndPoints.size() - removeCount);
-
-    // Update original points vector
-    points.clear();
-    for (const auto& pair : distanceAndPoints) {
-        points.push_back(pair.second);
-    }
-}
-
-int main() {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string orbs_csv_dir = data["framesOutput"];
-
-    std::vector <cv::Point3d> cloudPoints1;
-    std::vector <cv::Point3d> cloudPoints2;
-
-    std::string cloud_points_combined_frames_filename = orbs_csv_dir + "a1_combined_frames_points.xyz";
-    std::string cloud_points_orb_slam_filename = orbs_csv_dir + "a2_orb_slam_map_points.xyz";
-
-    // Read points from the single XYZ file
-    cloudPoints1 = readPointsFromXYZ(cloud_points_combined_frames_filename);
-    cloudPoints2 = readPointsFromXYZ(cloud_points_orb_slam_filename);
-
-    // Remove outliers
-    removeFarthestPoints(cloudPoints1, 1.0);
-    removeFarthestPoints(cloudPoints2, 5.0);
-
-    // Save the updated points
-    savePointsToXYZ(orbs_csv_dir + "b1_combined_frames_points_without_outliers.xyz", cloudPoints1);
-    savePointsToXYZ(orbs_csv_dir + "b2_orb_slam_map_points_without_outliers.xyz", cloudPoints2);
-}
diff --git a/exe/offline_orb_slam.cc b/exe/runOnVideo.cpp
similarity index 86%
rename from exe/offline_orb_slam.cc
rename to exe/runOnVideo.cpp
index 728b38c..151faa9 100644
--- a/exe/offline_orb_slam.cc
+++ b/exe/runOnVideo.cpp
@@ -2,7 +2,6 @@
 #include <string>
 #include <thread>
 #include <iostream>
-#include <unistd.h>
 #include <unordered_set>
 #include <nlohmann/json.hpp>
 #include <opencv2/videoio.hpp>
@@ -12,8 +11,6 @@
 #include "Converter.h"
 #include "include/Point.h"
 #include "include/Auxiliary.h"
-
-/************* SIGNAL *************/
 std::unique_ptr<ORB_SLAM2::System> SLAM;
 std::string simulatorOutputDir;
 
@@ -72,7 +69,7 @@ void saveMap(int mapNumber) {
             pointData << worldPos.at<double>(0) << "," << worldPos.at<double>(1) << "," << worldPos.at<double>(2);
             pointData << "," << p->GetMinDistanceInvariance() << "," << p->GetMaxDistanceInvariance() << "," << Pn.at<double>(0) << "," << Pn.at<double>(1) << "," << Pn.at<double>(2);
             std::map<ORB_SLAM2::KeyFrame*, size_t> observations = p->GetObservations();
-            for (auto obs : observations) {
+            for (auto &obs : observations) {
                 ORB_SLAM2::KeyFrame *currentFrame = obs.first;
                 if (!currentFrame->image.empty())
                 {
@@ -107,18 +104,15 @@ void stopProgramHandler(int s) {
     exit(1);
 }
 
-int main() {
-    signal(SIGINT, stopProgramHandler);
-    signal(SIGTERM, stopProgramHandler);
-    signal(SIGABRT, stopProgramHandler);
-    signal(SIGSEGV, stopProgramHandler);
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
+int main(int argc, char** argv) {
+    // signal(SIGINT, stopProgramHandler);
+    // signal(SIGTERM, stopProgramHandler);
+    // signal(SIGABRT, stopProgramHandler);
+    // signal(SIGSEGV, stopProgramHandler);
+    std::ifstream programData("C:/Users/tzuk9/Documents/simulatorMapping/generalSettings.json");
     nlohmann::json data;
     programData >> data;
     programData.close();
-    char currentDirPath[256];
-    getcwd(currentDirPath, 256);
 
     char time_buf[21];
     time_t now;
@@ -126,19 +120,20 @@ int main() {
     std::strftime(time_buf, 21, "%Y-%m-%d_%H:%S:%MZ", gmtime(&now));
     std::string currentTime(time_buf);
     std::string vocPath = data["VocabularyPath"];
+
     std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
+
     std::string videoPath = data["offlineVideoTestPath"];
+
     bool loadMap = data["loadMap"];
+
     bool isSavingMap = data["saveMap"];
+
     std::string loadMapPath = data["loadMapPath"];
+
     std::string simulatorOutputDirPath = data["simulatorOutputDir"];
-    simulatorOutputDir = simulatorOutputDirPath + currentTime + "/";
-    std::filesystem::create_directory(simulatorOutputDir);
-    SLAM = std::make_unique<ORB_SLAM2::System>(vocPath, droneYamlPathSlam, ORB_SLAM2::System::MONOCULAR, true, loadMap,
-                                               loadMapPath,
-                                               true);
-    int amountOfAttepmpts = 0;
-    while (amountOfAttepmpts++ < 1) {
+    SLAM = std::make_unique<ORB_SLAM2::System>(vocPath, droneYamlPathSlam, ORB_SLAM2::System::MONOCULAR, true);
+        std::cout << "here4" <<std::endl;
         cv::VideoCapture capture(videoPath);
         if (!capture.isOpened()) {
             std::cout << "Error opening video stream or file" << std::endl;
@@ -149,11 +144,8 @@ int main() {
 
         cv::Mat frame;
         std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
-        for (int i = 0; i < 170; ++i) {
-            capture >> frame;
-        }
         int amount_of_frames = 1;
-
+        capture >> frame;
         for (;;) {
             SLAM->TrackMonocular(frame, capture.get(CV_CAP_PROP_POS_MSEC));
 
@@ -163,14 +155,14 @@ int main() {
                 break;
             }
         }
-        saveMap(amountOfAttepmpts);
+        saveMap(0);
         std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
 
         std::cout << "Time difference = " << std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count()
                   << std::endl;
         std::cout << amount_of_frames << std::endl;
         capture.release();
-    }
+    
 
     if (isSavingMap) {
         SLAM->SaveMap(simulatorOutputDir + "simulatorMap.bin");
@@ -181,4 +173,3 @@ int main() {
 
     return 0;
 }
-
diff --git a/exe/runSimulator.cpp b/exe/runSimulator.cpp
index d43997b..425c3b6 100644
--- a/exe/runSimulator.cpp
+++ b/exe/runSimulator.cpp
@@ -4,8 +4,9 @@
 #include "simulator.h"
 #include "include/Auxiliary.h"
 
-int main(int argc, char **argv) {
-    std::ifstream programData(argv[1]);
+int main(int argc, char **argv)
+{
+    std::ifstream programData("C:\\Users\\tzuk9\\Documents\\simulatorMapping\\generalSettings.json");
     nlohmann::json data;
     programData >> data;
     programData.close();
@@ -13,37 +14,41 @@ int main(int argc, char **argv) {
     std::string configPath = data["DroneYamlPathSlam"];
     std::string modelTextureNameToAlignTo = data["modelTextureNameToAlignTo"];
     std::string model_path = data["modelPath"];
+    std::string vocabulary_path = data["VocabularyPath"];
+    std::string simulatorOutputDir = data["simulatorOutputDir"];
+    double movementFactor = data["movementFactor"];
     bool trackImages = data["trackImages"];
 
-    Simulator simulator(configPath, model_path, modelTextureNameToAlignTo, trackImages);
-    auto simulatorThread = simulator.run();
-    while (!simulator.isReady()) { // wait for the 3D model to load
-        usleep(1000);
+    Simulator simulator(configPath, model_path, modelTextureNameToAlignTo, trackImages, false, simulatorOutputDir, false, "", movementFactor, vocabulary_path);
+    //auto simulatorThread = simulator.run();
+   simulator.simulatorRunThread();
+    while (!simulator.isReady())
+    { // wait for the 3D model to load
+        Sleep(1);
     }
     std::cout << "to stop press k" << std::endl;
     std::cout << "to stop tracking press t" << std::endl;
     std::cout << "to save map point press m" << std::endl;
-    std::cout << "waiting for key press to start scanning " << std::endl << std::endl;
+    std::cout << "waiting for key press to start scanning " << std::endl
+              << std::endl;
     std::cin.get();
     simulator.setTrack(true);
     int currentYaw = 0;
     int angle = 10;
     cv::Mat currentLocation;
-    for (int i = 0; i < std::ceil(360 / angle); i++) {
+    for (int i = 0; i < std::ceil(360 / angle); i++)
+    {
         std::string c = "forward 0.5";
         simulator.command(c);
-        usleep(500000);
         currentLocation = simulator.getCurrentLocation();
         c = "back 0.5";
         simulator.command(c);
-        usleep(500000);
         currentLocation = simulator.getCurrentLocation();
         c = "cw " + std::to_string(angle);
         simulator.command(c);
-        sleep(1);
         currentLocation = simulator.getCurrentLocation();
     }
     auto scanMap = simulator.getCurrentMap();
 
-    simulatorThread.join();
+    //simulatorThread.join();
 }
\ No newline at end of file
diff --git a/exe/run_model.cc b/exe/run_model.cc
deleted file mode 100644
index ca283a5..0000000
--- a/exe/run_model.cc
+++ /dev/null
@@ -1,268 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include "ORBextractor.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#define NEAR_PLANE 0.1
-#define FAR_PLANE 20
-
-void drawPoints(std::vector<cv::Point3d> seen_points, std::vector<cv::Point3d> new_points_seen) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    const int point_size = data["pointSize"];
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(0.0, 0.0, 0.0);
-
-    for (auto point: seen_points) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(1.0, 0.0, 0.0);
-
-    for (auto point: new_points_seen) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    std::cout << new_points_seen.size() << std::endl;
-
-    glEnd();
-}
-
-cv::Point3f convert2Dto3D(cv::Point2f keypoint, const cv::Mat& K, const cv::Mat& depth, const pangolin::OpenGlRenderState& cam_state) {
-    GLint viewport[4];
-    GLdouble modelview[16];
-    GLdouble projection[16];
-
-    glGetIntegerv(GL_VIEWPORT, viewport);
-    for (int i = 0; i < 16; ++i) {
-        modelview[i] = cam_state.GetModelViewMatrix().m[i];
-        projection[i] = cam_state.GetProjectionMatrix().m[i];
-    }
-
-    GLdouble x, y, z;
-    GLdouble worldX, worldY, worldZ;
-
-    x = keypoint.x;
-    y = (float)viewport[3] - keypoint.y; // OpenGL has the origin in the lower-left corner, so we need to flip the y-coordinate
-    z = depth.at<float>(static_cast<int>(y), static_cast<int>(x)); // Get depth value at the keypoint position
-
-    gluUnProject(x, y, z, modelview, projection, viewport, &worldX, &worldY, &worldZ);
-
-    return cv::Point3f((float)worldX, (float)worldY, (float)worldZ);
-}
-
-void saveKeypointsToCSV(const std::vector<cv::Point3d>& keypoints, const std::string& filename) {
-    std::ofstream csv_file(filename);
-
-    for (const auto& keypoint : keypoints) {
-        csv_file << keypoint.x << "," << keypoint.y << "," << keypoint.z << std::endl;
-    }
-
-    csv_file.close();
-}
-
-int main(int argc, char **argv) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-    float viewpointX = fSettings["RunModel.ViewpointX"];
-    float viewpointY = fSettings["RunModel.ViewpointY"];
-    float viewpointZ = fSettings["RunModel.ViewpointZ"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    cv::Mat K_cv = (cv::Mat_<float>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
-    Eigen::Vector2i viewport_desired_size(640, 480);
-
-    cv::Mat img;
-
-    int nFeatures = fSettings["ORBextractor.nFeatures"];
-    float fScaleFactor = fSettings["ORBextractor.scaleFactor"];
-    int nLevels = fSettings["ORBextractor.nLevels"];
-    int fIniThFAST = fSettings["ORBextractor.iniThFAST"];
-    int fMinThFAST = fSettings["ORBextractor.minThFAST"];
-
-    ORB_SLAM2::ORBextractor* orbExtractor = new ORB_SLAM2::ORBextractor(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);
-
-    // Options
-    bool show_bounds = false;
-    bool show_axis = false;
-    bool show_x0 = false;
-    bool show_y0 = false;
-    bool show_z0 = false;
-    bool cull_backfaces = false;
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_desired_size[0], viewport_desired_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    pangolin::OpenGlRenderState s_cam(
-            pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE),
-            pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)
-    );
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float)-viewport_desired_size[0] / (float)viewport_desired_size[1]))
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    auto aabb = pangolin::GetAxisAlignedBox(geom_to_load);
-    Eigen::AlignedBox3f total_aabb;
-    total_aabb.extend(aabb);
-    const auto mvm = pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY);
-    const auto proj = pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE);
-    s_cam.SetModelViewMatrix(mvm);
-    s_cam.SetProjectionMatrix(proj);
-    const pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-
-    // Show axis and axis planes
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-
-    while (!pangolin::ShouldQuit()) {
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            if (cull_backfaces) {
-                glEnable(GL_CULL_FACE);
-                glCullFace(GL_BACK);
-            }
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw",  s_cam.GetProjectionMatrix() *  s_cam.GetModelViewMatrix());
-            pangolin::GlDraw( default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            int viewport_size[4];
-            glGetIntegerv(GL_VIEWPORT, viewport_size);
-
-            pangolin::Image<unsigned char> buffer;
-            pangolin::VideoPixelFormat fmt = pangolin::VideoFormatFromString("RGBA32");
-            buffer.Alloc(viewport_size[2], viewport_size[3], viewport_size[2] * fmt.bpp/8 );
-            glReadBuffer(GL_BACK);
-            glPixelStorei(GL_PACK_ALIGNMENT, 1);
-            glReadPixels(0, 0, viewport_size[2], viewport_size[3], GL_RGBA, GL_UNSIGNED_BYTE, buffer.ptr);
-
-            cv::Mat  imgBuffer = cv::Mat(viewport_size[3], viewport_size[2], CV_8UC4, buffer.ptr);
-            cv::cvtColor(imgBuffer, img,  cv::COLOR_RGBA2GRAY);
-            img.convertTo(img, CV_8UC1);
-            cv::flip(img, img, 0);
-
-            cv::imshow("image", img);
-            cv::waitKey(2); // You can replace 2 with 0 if you want the window to wait indefinitely for a key press
-
-            // Detect keypoints
-            std::vector<cv::KeyPoint> keypoints;
-            cv::Mat descriptors;
-            (*orbExtractor)(img, cv::Mat(), keypoints, descriptors);
-
-            // Draw keypoints on the image
-            cv::Mat image_keypoints;
-            cv::drawKeypoints(img, keypoints, image_keypoints);
-
-            cv::imshow("image_keypoints", image_keypoints);
-            cv::waitKey(2); // You can replace 2 with 0 if you want the window to wait indefinitely for a key press
-
-            // Save the x and y values of the keypoints to a vector
-            std::vector<cv::Point2f> keypoint_positions;
-            for (const auto& keypoint : keypoints)
-            {
-                cv::Point2f position = cv::Point2f((float)keypoint.pt.x, (float)(keypoint.pt.y));
-                keypoint_positions.push_back(position);
-            }
-
-            cv::Mat depth(viewport_size[3], viewport_size[2], CV_32FC1);
-            glReadPixels(0, 0, viewport_size[2], viewport_size[3], GL_DEPTH_COMPONENT, GL_FLOAT, depth.data);
-            
-            // Convert keypoints pixels to keypoints 3d points
-            std::vector<cv::Point3d> keypoint_points;
-            for (const auto& keypoint : keypoint_positions)
-            {
-                cv::Point3f point_float = convert2Dto3D(keypoint, K_cv, depth, s_cam);
-                cv::Point3d point = cv::Point3d(point_float.x, point_float.y, point_float.z);
-                keypoint_points.push_back(point);
-            }
-
-            int frame_to_check = data["frameNumber"];
-            std::string keypoints_csv_path = std::string(data["framesOutput"]) + "frame_" + std::to_string(frame_to_check) + "_orbs.csv";
-
-            saveKeypointsToCSV(keypoint_points, keypoints_csv_path);
-
-            s_cam.Apply();
-
-            glDisable(GL_CULL_FACE);
-
-            drawPoints(std::vector<cv::Point3d>(), keypoint_points);
-        }
-
-        pangolin::FinishFrame();
-    }
-
-    return 0;
-}
diff --git a/exe/run_model_on_orb_slam.cc b/exe/run_model_on_orb_slam.cc
deleted file mode 100644
index f642cd7..0000000
--- a/exe/run_model_on_orb_slam.cc
+++ /dev/null
@@ -1,559 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include "ORBextractor.h"
-#include "System.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-#include <unordered_set>
-
-#define NEAR_PLANE 0.1
-#define FAR_PLANE 20
-
-void applyForwardToModelCam(std::shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value);
-
-void applyRightToModelCam(shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value);
-
-void applyYawRotationToModelCam(std::shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value);
-
-void applyUpModelCam(std::shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value);
-
-void applyPitchRotationToModelCam(std::shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value);
-
-void drawPoints(std::vector<cv::Point3d> &seen_points, std::vector<cv::Point3d> &new_points_seen) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    const int point_size = data["pointSize"];
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(0.0, 0.0, 0.0);
-
-    for (auto &point: seen_points) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(1.0, 0.0, 0.0);
-
-    for (auto &point: new_points_seen) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-}
-
-cv::Point3f convert2Dto3D(cv::Point2f &keypoint, const cv::Mat &K, const cv::Mat &depth,
-                          const pangolin::OpenGlRenderState &cam_state) {
-    GLint viewport[4];
-    GLdouble modelview[16];
-    GLdouble projection[16];
-
-    glGetIntegerv(GL_VIEWPORT, viewport);
-    for (int i = 0; i < 16; ++i) {
-        modelview[i] = cam_state.GetModelViewMatrix().m[i];
-        projection[i] = cam_state.GetProjectionMatrix().m[i];
-    }
-
-    GLdouble x, y, z;
-    GLdouble worldX, worldY, worldZ;
-
-    x = keypoint.x;
-    y = (float) viewport[3] -
-        keypoint.y;                           // OpenGL has the origin in the lower-left corner, so we need to flip the y-coordinate
-    z = depth.at<float>(static_cast<int>(y), static_cast<int>(x)); // Get depth value at the keypoint position
-
-    gluUnProject(x, y, z, modelview, projection, viewport, &worldX, &worldY, &worldZ);
-
-    return cv::Point3f((float) worldX, (float) worldY, (float) worldZ);
-}
-
-void saveMap(int mapNumber, std::string &simulatorOutputDir, ORB_SLAM2::System *SLAM) {
-    std::ofstream pointData;
-    std::unordered_set<int> seen_frames;
-
-    pointData.open(simulatorOutputDir + "cloud" + std::to_string(mapNumber) + ".csv");
-    for (auto &p: SLAM->GetMap()->GetAllMapPoints()) {
-        if (p != nullptr && !p->isBad()) {
-            auto point = p->GetWorldPos();
-            Eigen::Matrix<double, 3, 1> vector = ORB_SLAM2::Converter::toVector3d(point);
-            cv::Mat worldPos = cv::Mat::zeros(3, 1, CV_64F);
-            worldPos.at<double>(0) = vector.x();
-            worldPos.at<double>(1) = vector.y();
-            worldPos.at<double>(2) = vector.z();
-            p->UpdateNormalAndDepth();
-            cv::Mat Pn = p->GetNormal();
-            Pn.convertTo(Pn, CV_64F);
-            pointData << worldPos.at<double>(0) << "," << worldPos.at<double>(1) << "," << worldPos.at<double>(2);
-            pointData << "," << p->GetMinDistanceInvariance() << "," << p->GetMaxDistanceInvariance() << ","
-                      << Pn.at<double>(0) << "," << Pn.at<double>(1) << "," << Pn.at<double>(2);
-            std::map<ORB_SLAM2::KeyFrame *, size_t> observations = p->GetObservations();
-            for (auto obs: observations) {
-                ORB_SLAM2::KeyFrame *currentFrame = obs.first;
-                if (!currentFrame->image.empty()) {
-                    size_t pointIndex = obs.second;
-                    cv::KeyPoint keyPoint = currentFrame->mvKeysUn[pointIndex];
-                    cv::Point2f featurePoint = keyPoint.pt;
-                    pointData << "," << currentFrame->mnId << "," << featurePoint.x << "," << featurePoint.y;
-                    // cv::Mat image = cv::imread(simulatorOutputDir + "frame_" + std::to_string(currentFrame->mnId) + ".png");
-                    // cv::arrowedLine(image, featurePoint, cv::Point2f(featurePoint.x, featurePoint.y - 100), cv::Scalar(0, 0, 255), 2, 8, 0, 0.1);
-                    // cv::imshow("image", image);
-                    // cv::waitKey(0);
-                }
-            }
-            pointData << std::endl;
-        }
-    }
-    pointData.close();
-    std::cout << "saved map" << std::endl;
-
-}
-
-void saveKeypointsToCSV(const std::vector<cv::Point3d> &keypoints, const std::string &filename) {
-    std::ofstream csv_file(filename);
-
-    for (const auto &keypoint: keypoints) {
-        csv_file << keypoint.x << "," << keypoint.y << "," << keypoint.z << std::endl;
-    }
-
-    csv_file.close();
-}
-
-void HandleKeyboardInput(unsigned char key, int x, int y) {
-    // Handle WASD key events
-    // Update camera position based on key inputs
-}
-
-void runModelAndOrbSlam(std::string &settingPath, bool *stopFlag, std::shared_ptr<pangolin::OpenGlRenderState> &s_cam,
-                        bool *ready) {
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    cv::Mat K_cv = (cv::Mat_<float>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
-    Eigen::Vector2i viewport_desired_size(640, 480);
-
-    cv::Mat img;
-
-    int nFeatures = fSettings["ORBextractor.nFeatures"];
-    float fScaleFactor = fSettings["ORBextractor.scaleFactor"];
-    int nLevels = fSettings["ORBextractor.nLevels"];
-    int fIniThFAST = fSettings["ORBextractor.iniThFAST"];
-    int fMinThFAST = fSettings["ORBextractor.minThFAST"];
-
-    ORB_SLAM2::ORBextractor *orbExtractor = new ORB_SLAM2::ORBextractor(nFeatures, fScaleFactor, nLevels, fIniThFAST,
-                                                                        fMinThFAST);
-
-    // Options
-    bool show_bounds = false;
-    bool show_axis = false;
-    bool show_x0 = false;
-    bool show_y0 = false;
-    bool show_z0 = false;
-    bool cull_backfaces = false;
-
-    char currentDirPath[256];
-    getcwd(currentDirPath, 256);
-
-    char time_buf[21];
-    time_t now;
-    std::time(&now);
-    std::strftime(time_buf, 21, "%Y-%m-%d_%H:%S:%MZ", gmtime(&now));
-    std::string currentTime(time_buf);
-    std::string vocPath = data["VocabularyPath"];
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-    std::string modelTextureNameToAlignTo = data["modelTextureNameToAlignTo"];
-    std::string videoPath = data["offlineVideoTestPath"];
-    bool loadMap = data["loadMap"];
-    double movementFactor = data["movementFactor"];
-    bool isSavingMap = data["saveMap"];
-    std::string loadMapPath = data["loadMapPath"];
-    std::string simulatorOutputDirPath = data["simulatorOutputDir"];
-    std::string simulatorOutputDir = simulatorOutputDirPath + currentTime + "/";
-    std::filesystem::create_directory(simulatorOutputDir);
-    ORB_SLAM2::System SLAM = ORB_SLAM2::System(vocPath, droneYamlPathSlam, ORB_SLAM2::System::MONOCULAR, true, loadMap,
-                                               loadMapPath,
-                                               true);
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_desired_size[0], viewport_desired_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    s_cam = std::make_shared<pangolin::OpenGlRenderState>(
-            pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2),
-                                       K(1, 2), NEAR_PLANE, FAR_PLANE),
-            pangolin::ModelViewLookAt(0.1, -0.1, 0.3, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)); // the first 3 value are meaningless because we change them later
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(*s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float) -viewport_desired_size[0] / (float) viewport_desired_size[1]))
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    std::vector<Eigen::Vector3<unsigned int>> floorIndices;
-    for (auto &o: geom_to_load.objects) {
-        if (o.first == modelTextureNameToAlignTo) {
-            const auto &it_vert = o.second.attributes.find("vertex_indices");
-            if (it_vert != o.second.attributes.end()) {
-                const auto &vs = std::get<pangolin::Image<unsigned int>>(it_vert->second);
-                for (size_t i = 0; i < vs.h; ++i) {
-                    const Eigen::Map<const Eigen::Vector3<unsigned int>> v(vs.RowPtr(i));
-                    floorIndices.emplace_back(v);
-                }
-            }
-        }
-    }
-    Eigen::MatrixXf floor(floorIndices.size() * 3, 3);
-    int currentIndex = 0;
-    for (const auto &b: geom_to_load.buffers) {
-        const auto &it_vert = b.second.attributes.find("vertex");
-        if (it_vert != b.second.attributes.end()) {
-            const auto &vs = std::get<pangolin::Image<float>>(it_vert->second);
-            for (auto &row: floorIndices) {
-                for (auto &i: row) {
-                    const Eigen::Map<const Eigen::Vector3f> v(vs.RowPtr(i));
-                    floor.row(currentIndex++) = v;
-                }
-            }
-        }
-    }
-    Eigen::JacobiSVD<Eigen::MatrixXf> svd(floor, Eigen::ComputeThinU | Eigen::ComputeThinV);
-    svd.computeV();
-    Eigen::Vector3f v = svd.matrixV().col(2);
-    const auto mvm = pangolin::ModelViewLookAt(v.x(), v.y(), v.z(), 0, 0, 0, 0.0,
-                                               -1.0,
-                                               pangolin::AxisY);
-    const auto proj = pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1),
-                                                 K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE);
-    s_cam->SetModelViewMatrix(mvm);
-    s_cam->SetProjectionMatrix(proj);
-    applyPitchRotationToModelCam(s_cam, -90);
-    pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    for (auto &buffer: geomToRender.buffers) {
-        buffer.second.attributes.erase("normal");
-    }
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-
-    // Show axis and axis planes
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('k', [&]() { *stopFlag = !*stopFlag; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-    pangolin::RegisterKeyPressCallback('w', [&]() { applyForwardToModelCam(s_cam, movementFactor); });
-    pangolin::RegisterKeyPressCallback('a', [&]() { applyRightToModelCam(s_cam, movementFactor); });
-    pangolin::RegisterKeyPressCallback('s', [&]() { applyForwardToModelCam(s_cam, -movementFactor); });
-    pangolin::RegisterKeyPressCallback('d', [&]() { applyRightToModelCam(s_cam, -movementFactor); });
-    pangolin::RegisterKeyPressCallback('e', [&]() { applyYawRotationToModelCam(s_cam, 1); });
-    pangolin::RegisterKeyPressCallback('q', [&]() { applyYawRotationToModelCam(s_cam, -1); });
-    pangolin::RegisterKeyPressCallback('r', [&]() {
-        applyUpModelCam(s_cam, -movementFactor);
-    });// ORBSLAM y axis is reversed
-    pangolin::RegisterKeyPressCallback('f', [&]() { applyUpModelCam(s_cam, movementFactor); });
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-
-    cv::VideoWriter writer;
-    writer.open(simulatorOutputDir + "/scan.avi", cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 30.0, cv::Size(viewport_desired_size[0], viewport_desired_size[1]), true);
-
-    std::vector<cv::Point3d> seenPoints{};
-    while (!pangolin::ShouldQuit() && !*stopFlag) {
-        *ready = true;
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            if (cull_backfaces) {
-                glEnable(GL_CULL_FACE);
-                glCullFace(GL_BACK);
-            }
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw", s_cam->GetProjectionMatrix() * s_cam->GetModelViewMatrix());
-            pangolin::GlDraw(default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            int viewport_size[4];
-            glGetIntegerv(GL_VIEWPORT, viewport_size);
-
-            pangolin::Image<unsigned char> buffer;
-            pangolin::VideoPixelFormat fmt = pangolin::VideoFormatFromString("RGB24");
-            buffer.Alloc(viewport_size[2], viewport_size[3], viewport_size[2] * fmt.bpp / 8);
-            glReadBuffer(GL_BACK);
-            glPixelStorei(GL_PACK_ALIGNMENT, 1);
-            glReadPixels(0, 0, viewport_size[2], viewport_size[3], GL_RGB, GL_UNSIGNED_BYTE, buffer.ptr);
-
-            cv::Mat imgBuffer = cv::Mat(viewport_size[3], viewport_size[2], CV_8UC3, buffer.ptr);
-            cv::cvtColor(imgBuffer, img, cv::COLOR_RGB2GRAY);
-            img.convertTo(img, CV_8UC1);
-            cv::flip(img, img, 0);
-            cv::flip(imgBuffer, imgBuffer, 0);
-
-            writer.write(imgBuffer);
-
-            auto now = std::chrono::system_clock::now();
-            auto now_ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);
-            auto value = now_ms.time_since_epoch();
-            double timestamp = value.count() / 1000.0;
-
-            SLAM.TrackMonocular(img, timestamp);
-//            // Detect keypoints
-//            std::vector<cv::KeyPoint> keypoints;
-//            cv::Mat descriptors;
-//            (*orbExtractor)(img, cv::Mat(), keypoints, descriptors);
-//
-//            // Save the x and y values of the keypoints to a vector
-//            std::vector<cv::Point2f> keypoint_positions;
-//            for (const auto &keypoint: keypoints) {
-//                cv::Point2f position = cv::Point2f((float) keypoint.pt.x, (float) (keypoint.pt.y));
-//                keypoint_positions.push_back(position);
-//            }
-//
-//            cv::Mat depth(viewport_size[3], viewport_size[2], CV_32FC1);
-//            glReadPixels(0, 0, viewport_size[2], viewport_size[3], GL_DEPTH_COMPONENT, GL_FLOAT, depth.data);
-//
-//            // Convert keypoints pixels to keypoints 3d points
-//            std::vector<cv::Point3d> keypoint_points;
-//            for (auto &keypoint: keypoint_positions) {
-//                cv::Point3f point_float = convert2Dto3D(keypoint, K_cv, depth, *s_cam);
-//                cv::Point3d point = cv::Point3d(point_float.x, point_float.y, point_float.z);
-//                keypoint_points.push_back(point);
-//            }
-//
-//             int frame_to_check = data["frameNumber"];
-//             std::string keypoints_csv_path = std::string(data["framesOutput"]) + "frame_" + std::to_string(frame_to_check) + "_orbs.csv";
-//
-//             saveKeypointsToCSV(keypoint_points, keypoints_csv_path);
-
-            s_cam->Apply();
-
-            glDisable(GL_CULL_FACE);
-
-//             drawPoints(seenPoints, keypoint_points);
-        }
-
-        pangolin::FinishFrame();
-    }
-    writer.release();
-    saveMap(0, simulatorOutputDir, &SLAM);
-    SLAM.SaveMap(simulatorOutputDir + "/simulatorCloudPoint.bin");
-    SLAM.Shutdown();
-}
-
-
-void applyUpModelCam(shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value) {
-    auto camMatrix = pangolin::ToEigen<double>(s_cam->GetModelViewMatrix());
-    camMatrix(1, 3) += value;
-    s_cam->SetModelViewMatrix(camMatrix);
-}
-
-void applyForwardToModelCam(shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value) {
-    auto camMatrix = pangolin::ToEigen<double>(s_cam->GetModelViewMatrix());
-    camMatrix(2, 3) += value;
-    s_cam->SetModelViewMatrix(camMatrix);
-}
-
-void applyRightToModelCam(shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value) {
-    auto camMatrix = pangolin::ToEigen<double>(s_cam->GetModelViewMatrix());
-    camMatrix(0, 3) += value;
-    s_cam->SetModelViewMatrix(camMatrix);
-}
-
-void applyYawRotationToModelCam(shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value) {
-    double rand = double(value) * (M_PI / 180);
-    double c = std::cos(rand);
-    double s = std::sin(rand);
-
-    Eigen::Matrix3d R;
-    R << c, 0, s,
-            0, 1, 0,
-            -s, 0, c;
-
-    Eigen::Matrix4d pangolinR = Eigen::Matrix4d::Identity();
-    pangolinR.block<3, 3>(0, 0) = R;
-
-    auto camMatrix = pangolin::ToEigen<double>(s_cam->GetModelViewMatrix());
-
-    // Left-multiply the rotation
-    camMatrix = pangolinR * camMatrix;
-
-    // Convert back to pangolin matrix and set
-    pangolin::OpenGlMatrix newModelView;
-    for (int i = 0; i < 4; ++i) {
-        for (int j = 0; j < 4; ++j) {
-            newModelView.m[j * 4 + i] = camMatrix(i, j);
-        }
-    }
-
-    s_cam->SetModelViewMatrix(newModelView);
-}
-
-void applyPitchRotationToModelCam(shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value) {
-    double rand = double(value) * (M_PI / 180);
-    double c = std::cos(rand);
-    double s = std::sin(rand);
-
-    Eigen::Matrix3d R;
-    R << 1, 0, 0,
-            0, c, -s,
-            0, s, c;
-
-    Eigen::Matrix4d pangolinR = Eigen::Matrix4d::Identity();;
-    pangolinR.block<3, 3>(0, 0) = R;
-
-    auto camMatrix = pangolin::ToEigen<double>(s_cam->GetModelViewMatrix());
-
-    // Left-multiply the rotation
-    camMatrix = pangolinR * camMatrix;
-
-    // Convert back to pangolin matrix and set
-    pangolin::OpenGlMatrix newModelView;
-    for (int i = 0; i < 4; ++i) {
-        for (int j = 0; j < 4; ++j) {
-            newModelView.m[j * 4 + i] = camMatrix(i, j);
-        }
-    }
-
-    s_cam->SetModelViewMatrix(newModelView);
-}
-
-
-void intervalOverCommand(const std::function<void(std::shared_ptr<pangolin::OpenGlRenderState> &, double &)> &func,
-                         std::shared_ptr<pangolin::OpenGlRenderState> &s_cam, double value, int intervalUsleep,
-                         double fps,
-                         int totalCommandTimeInSeconds) {
-    double intervalValue = value / fps * totalCommandTimeInSeconds;
-    int intervalIndex = 0;
-    while (intervalIndex <= fps * totalCommandTimeInSeconds) {
-        usleep(intervalUsleep);
-        func(s_cam, intervalValue);
-        intervalIndex += 1;
-    }
-}
-
-void
-applyCommand(std::shared_ptr<pangolin::OpenGlRenderState> &s_cam, std::string &command, double value,
-             int intervalUsleep,
-             double fps,
-             int totalCommandTimeInSeconds) {
-
-    if (command == "cw") {
-        intervalOverCommand(&applyYawRotationToModelCam, s_cam, value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else if (command == "ccw") {
-        intervalOverCommand(&applyYawRotationToModelCam, s_cam, -1 * value, intervalUsleep, fps,
-                            totalCommandTimeInSeconds);
-    } else if (command == "forward") {
-        intervalOverCommand(&applyForwardToModelCam, s_cam, value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else if (command == "back") {
-        intervalOverCommand(&applyForwardToModelCam, s_cam, -1 * value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else if (command == "right") {
-        intervalOverCommand(&applyRightToModelCam, s_cam, -1 * value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else if (command == "left") {
-        intervalOverCommand(&applyRightToModelCam, s_cam, value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else if (command == "up") {
-        intervalOverCommand(&applyUpModelCam, s_cam, -1 * value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else if (command == "down") {
-        intervalOverCommand(&applyUpModelCam, s_cam, value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    }
-
-}
-
-int main(int argc, char **argv) {
-
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    bool stopFlag = false;
-    bool ready = false;
-    std::shared_ptr<pangolin::OpenGlRenderState> s_cam = std::make_shared<pangolin::OpenGlRenderState>();
-    std::thread t(runModelAndOrbSlam, std::ref(settingPath), &stopFlag, std::ref(s_cam), &ready);
-//    int startSleepTime = 3;
-//    std::cout << "wating " << startSleepTime << " to init commands " << std::endl;
-    while (!ready) {
-        usleep(500);
-    }
-//    applyPitchRotationToModelCam(s_cam, -20);
-//    applyUpModelCam(s_cam, -0.5);
-//    sleep(startSleepTime);
-//    int intervalUsleep = 50000;
-//    std::vector<std::string> commnads = {"cw 25", "forward 30", "back 30", "cw 30"};
-//    int currentYaw = 0;
-//    int angle = 10;
-//    for (int i = 0; i < std::ceil(360 / angle); i++) {
-//        std::string c = "forward";
-//        double value = 0.50;
-//        applyCommand(s_cam, c, value, intervalUsleep, 30.0, 1);
-//        usleep(500000);
-//        c = "back";
-//        value = 0.50;
-//        applyCommand(s_cam, c, value, intervalUsleep, 30.0, 1);
-//        usleep(500000);
-//        c = "cw";
-//        value = angle;
-//        applyCommand(s_cam, c, value, intervalUsleep, 30.0, 1);
-//        sleep(1);
-//
-//    }
-//    stopFlag = true;
-    t.join();
-
-    //    if (isSavingMap) {
-    //        SLAM->SaveMap(simulatorOutputDir + "simulatorMap.bin");
-    //    }
-    //
-    //    SLAM->Shutdown();
-
-    return 0;
-}
diff --git a/exe/run_model_with_icp.cc b/exe/run_model_with_icp.cc
deleted file mode 100644
index 89d1284..0000000
--- a/exe/run_model_with_icp.cc
+++ /dev/null
@@ -1,290 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#define NEAR_PLANE 0.1
-#define FAR_PLANE 20
-
-void drawPoints(std::vector<cv::Point3d> seen_points, std::vector<cv::Point3d> new_points_seen) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    const int point_size = data["pointSize"];
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(0.0, 0.0, 0.0);
-
-    for (auto point: seen_points) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(1.0, 0.0, 0.0);
-
-    for (auto point: new_points_seen) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    std::cout << new_points_seen.size() << std::endl;
-
-    glEnd();
-}
-
-Eigen::Matrix4f loadMatrixFromFile(const std::string &filename) {
-    Eigen::Matrix4f matrix;
-    std::ifstream infile(filename);
-
-    if (infile.is_open()) {
-        int row = 0;
-        std::string line;
-        while (std::getline(infile, line)) {
-            std::istringstream ss(line);
-            std::string value;
-            int col = 0;
-            while (std::getline(ss, value, ',')) {
-                matrix(row, col) = std::stof(value);
-                col++;
-            }
-            row++;
-        }
-        infile.close();
-    } else {
-        std::cerr << "Cannot open file: " << filename << std::endl;
-    }
-
-    return matrix;
-}
-
-Eigen::Matrix4f openGlMatrixToEigen(const pangolin::OpenGlMatrix &m) {
-    Eigen::Matrix4f eigen_matrix;
-    for (int row = 0; row < 4; ++row) {
-        for (int col = 0; col < 4; ++col) {
-            eigen_matrix(row, col) = m(row, col);
-        }
-    }
-    return eigen_matrix;
-}
-
-Eigen::Vector4f inverseTransformPoint(const Eigen::Vector4f &point, const Eigen::Matrix4f &transformation) {
-    Eigen::Matrix4f inverse_transformation = transformation.inverse();
-    return inverse_transformation * point;
-}
-
-std::vector<cv::Point3d> convert_points(std::vector<cv::Point3d>& points, Eigen::Matrix4f& transformation_mat) {
-    std::vector<cv::Point3d> transformed_points;
-    for (auto& point : points) {
-        Eigen::Vector4f transformed_point = transformation_mat * Eigen::Vector4f((float)point.x, (float)point.y, (float)point.z, 1.0f);
-        transformed_points.emplace_back(cv::Point3d((double)transformed_point[0], (double)transformed_point[1], (double)transformed_point[2]));
-    }
-    return transformed_points;
-}
-
-int main(int argc, char **argv) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-    float viewpointX = fSettings["RunModel.ViewpointX"];
-    float viewpointY = fSettings["RunModel.ViewpointY"];
-    float viewpointZ = fSettings["RunModel.ViewpointZ"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    cv::Mat K_cv = (cv::Mat_<float>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
-    Eigen::Vector2i viewport_desired_size(640, 480);
-
-    cv::Mat img;
-
-    // Options
-    bool show_bounds = false;
-    bool show_axis = false;
-    bool show_x0 = false;
-    bool show_y0 = false;
-    bool show_z0 = false;
-    bool cull_backfaces = false;
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_desired_size[0], viewport_desired_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    pangolin::OpenGlRenderState s_cam(
-            pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE),
-            pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)
-    );
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float)-viewport_desired_size[0] / (float)viewport_desired_size[1]))
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    auto aabb = pangolin::GetAxisAlignedBox(geom_to_load);
-    Eigen::AlignedBox3f total_aabb;
-    total_aabb.extend(aabb);
-    const auto mvm = pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY);
-    const auto proj = pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE);
-    s_cam.SetModelViewMatrix(mvm);
-    s_cam.SetProjectionMatrix(proj);
-    const pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-
-    // Show axis and axis planes
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-
-    cv::Mat Twc;
-    bool use_lab_icp = bool(data["useLabICP"]);
-    std::cout << use_lab_icp << std::endl;
-
-    std::string transformation_matrix_csv_path;
-    if (use_lab_icp)
-    {
-        transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_lab_transformation_matrix.csv";
-    }
-    else
-    {
-        transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_transformation_matrix.csv";
-    }
-    Eigen::Matrix4f transformation = loadMatrixFromFile(transformation_matrix_csv_path);
-    std::cout << transformation << std::endl;
-
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-
-    while (!pangolin::ShouldQuit()) {
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            if (cull_backfaces) {
-                glEnable(GL_CULL_FACE);
-                glCullFace(GL_BACK);
-            }
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw",  s_cam.GetProjectionMatrix() *  s_cam.GetModelViewMatrix());
-            pangolin::GlDraw( default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            std::cout << "Transformation Matrix " << transformation_matrix_csv_path << ": " << transformation << std::endl;
-
-            pangolin::OpenGlMatrix mv_mat = s_cam.GetModelViewMatrix();
-            std::cout << "Original Point: " << mv_mat(0, 3) << ", " <<  mv_mat(1, 3) << ", " <<  mv_mat(2, 3) << std::endl;
-
-            Eigen::Matrix4f mv_mat_eigen = openGlMatrixToEigen(mv_mat);
-            Eigen::Vector4f pos_before_transform = Eigen::Vector4f(mv_mat_eigen(0, 3), mv_mat_eigen(1, 3), mv_mat_eigen(2, 3), 1.0);
-            Eigen::Vector4f transformed_point = inverseTransformPoint(pos_before_transform, transformation);
-            Eigen::Vector3f pos_after_transform = Eigen::Vector3f(pos_before_transform(0)- 0.6691778, pos_before_transform(1)+1.22925615, pos_before_transform[2]+2.24406284);
-            Eigen::Matrix3f rot_mat;
-            rot_mat << 0.97972727, -0.03784983, -0.19672792, -0.069904, -0.98485774, -0.15864633, -0.18774428,  0.1691822, -0.96753784;
-            pos_after_transform = rot_mat.inverse() * pos_after_transform;
-            pos_after_transform *= (1/6.2854950175989694);
-            Eigen::Vector3f position(transformed_point(0), transformed_point(1), transformed_point(2));
-
-            std::cout << "Transformed Point1: " << position(0) << ", " << position(1) << ", " << position(2) << std::endl;
-            std::cout << "Transformed Point2: " << pos_after_transform << std::endl;
-
-            // Extract rotation part of the transformed matrix
-            Eigen::Matrix3f rotation_matrix = mv_mat_eigen.block<3, 3>(0, 0);
-
-            // Convert the rotation matrix to Euler angles (yaw, pitch, roll)
-            Eigen::Vector3f euler_angles = rotation_matrix.eulerAngles(2, 1, 0); // yaw, pitch, roll
-
-            // Extract transformed yaw, pitch, and roll
-            float yaw = euler_angles(0);
-            float pitch = euler_angles(1);
-            float roll = euler_angles(2);
-
-            // Construct the original rotation matrix from the yaw, pitch, and roll angles
-            Eigen::AngleAxisf yaw_rotation(yaw, Eigen::Vector3f::UnitZ());
-            Eigen::AngleAxisf pitch_rotation(pitch, Eigen::Vector3f::UnitY());
-            Eigen::AngleAxisf roll_rotation(roll, Eigen::Vector3f::UnitX());
-            Eigen::Matrix3f original_rotation_matrix = (yaw_rotation * pitch_rotation * roll_rotation).toRotationMatrix();
-
-            // Convert the original rotation matrix to Matrix4f for multiplication
-            Eigen::Matrix4f original_rotation_matrix_4f = Eigen::Matrix4f::Identity();
-            original_rotation_matrix_4f.block<3, 3>(0, 0) = original_rotation_matrix;
-
-            // Apply the transformation matrix to obtain the resulting rotation matrix
-            Eigen::Matrix4f transformed_rotation_matrix = transformation.inverse() * original_rotation_matrix_4f;
-
-            // Extract the yaw, pitch, and roll angles from the resulting rotation matrix
-            Eigen::Matrix3f transformed_rotation_matrix_3f = transformed_rotation_matrix.block<3, 3>(0, 0);
-            Eigen::Vector3f transformed_euler_angles = transformed_rotation_matrix_3f.eulerAngles(2, 1, 0);
-            float transformed_yaw = transformed_euler_angles(0);
-            float transformed_pitch = transformed_euler_angles(1);
-            float transformed_roll = transformed_euler_angles(2);
-
-            // Run GetPointsFromPos
-            std::string map_input_dir = data["mapInputDir"];
-            const std::string cloud_points = map_input_dir + "cloud1.csv";
-            std::vector<cv::Point3d> seen_points = Auxiliary::getPointsFromPos(cloud_points, cv::Point3d(position[0], position[1], position[2]), transformed_yaw, transformed_pitch, transformed_roll, Twc);
-            std::vector<cv::Point3d> points_to_draw = convert_points(seen_points, transformation);
-
-            s_cam.Apply();
-
-            glDisable(GL_CULL_FACE);
-
-            drawPoints(std::vector<cv::Point3d>(), points_to_draw);
-        }
-
-        pangolin::FinishFrame();
-    }
-
-    return 0;
-}
diff --git a/exe/run_model_with_orb_slam_points.cc b/exe/run_model_with_orb_slam_points.cc
deleted file mode 100644
index 13532a8..0000000
--- a/exe/run_model_with_orb_slam_points.cc
+++ /dev/null
@@ -1,270 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#define NEAR_PLANE 0.1
-#define FAR_PLANE 20
-
-void drawPoints(std::vector<cv::Point3d> seen_points, std::vector<cv::Point3d> new_points_seen) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    const int point_size = data["pointSize"];
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(0.0, 0.0, 0.0);
-
-    for (auto point: seen_points) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(1.0, 0.0, 0.0);
-
-    for (auto point: new_points_seen) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    std::cout << new_points_seen.size() << std::endl;
-
-    glEnd();
-}
-
-Eigen::Matrix4f loadMatrixFromFile(const std::string &filename) {
-    Eigen::Matrix4f matrix;
-    std::ifstream infile(filename);
-
-    if (infile.is_open()) {
-        int row = 0;
-        std::string line;
-        while (std::getline(infile, line)) {
-            std::istringstream ss(line);
-            std::string value;
-            int col = 0;
-            while (std::getline(ss, value, ',')) {
-                matrix(row, col) = std::stof(value);
-                col++;
-            }
-            row++;
-        }
-        infile.close();
-    } else {
-        std::cerr << "Cannot open file: " << filename << std::endl;
-    }
-
-    return matrix;
-}
-
-cv::Point3d transformPoint(const cv::Point3d &point, const Eigen::Matrix4f &transformation) {
-    Eigen::Vector4f eigenPoint = Eigen::Vector4f((float)point.x, (float)point.y, (float)point.z, 1.0f);
-    Eigen::Vector4f transformedPoint = transformation * eigenPoint;
-    return cv::Point3d((double)transformedPoint(0), (double)transformedPoint(1), (double)transformedPoint(2));
-}
-
-std::vector<cv::Point3d> loadPoints() {
-    std::ifstream pointData;
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string cloud_points = std::string(data["mapInputDir"]) + "cloud1.csv";
-
-    std::vector<cv::Point3d> points;
-
-    pointData.open(cloud_points, std::ios::in);
-
-    while (!pointData.eof()) {
-        row.clear();
-
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            try
-            {
-                std::stod(word);
-            }
-            catch(std::out_of_range)
-            {
-                word = "0";
-            }
-            row.push_back(word);
-        }
-        points.push_back(cv::Point3d(std::stod(row[0]), std::stod(row[1]), std::stod(row[2])));
-    }
-    pointData.close();
-
-    return points;
-}
-
-int main(int argc, char **argv) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-    float viewpointX = fSettings["RunModel.ViewpointX"];
-    float viewpointY = fSettings["RunModel.ViewpointY"];
-    float viewpointZ = fSettings["RunModel.ViewpointZ"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    cv::Mat K_cv = (cv::Mat_<float>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
-    Eigen::Vector2i viewport_desired_size(640, 480);
-
-    cv::Mat img;
-
-    // Options
-    bool show_bounds = false;
-    bool show_axis = false;
-    bool show_x0 = false;
-    bool show_y0 = false;
-    bool show_z0 = false;
-    bool cull_backfaces = false;
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_desired_size[0], viewport_desired_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    pangolin::OpenGlRenderState s_cam(
-            pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE),
-            pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)
-    );
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float)-viewport_desired_size[0] / (float)viewport_desired_size[1]))
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    auto aabb = pangolin::GetAxisAlignedBox(geom_to_load);
-    Eigen::AlignedBox3f total_aabb;
-    total_aabb.extend(aabb);
-    const auto mvm = pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY);
-    const auto proj = pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE);
-    s_cam.SetModelViewMatrix(mvm);
-    s_cam.SetProjectionMatrix(proj);
-    const pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-
-    // Show axis and axis planes
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-
-    cv::Mat Twc;
-    bool use_lab_icp = bool(data["useLabICP"]);
-    std::cout << use_lab_icp << std::endl;
-
-    std::string transformation_matrix_csv_path;
-    if (use_lab_icp)
-    {
-        transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_lab_transformation_matrix.csv";
-    }
-    else
-    {
-        transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_transformation_matrix.csv";
-    }
-    Eigen::Matrix4f transformation = loadMatrixFromFile(transformation_matrix_csv_path);
-    std::cout << transformation << std::endl;
-
-    std::vector<cv::Point3d> points_to_draw;
-    std::vector<cv::Point3d> points = loadPoints();
-
-    for (auto point : points) {
-        points_to_draw.push_back(transformPoint(point, transformation));
-    }
-
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-
-    while (!pangolin::ShouldQuit()) {
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            if (cull_backfaces) {
-                glEnable(GL_CULL_FACE);
-                glCullFace(GL_BACK);
-            }
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw",  s_cam.GetProjectionMatrix() *  s_cam.GetModelViewMatrix());
-            pangolin::GlDraw( default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            s_cam.Apply();
-
-            glDisable(GL_CULL_FACE);
-
-            drawPoints(std::vector<cv::Point3d>(), points_to_draw);
-        }
-
-        pangolin::FinishFrame();
-    }
-
-    return 0;
-}
diff --git a/exe/run_model_with_orbs_and_orb_slam_map.cc b/exe/run_model_with_orbs_and_orb_slam_map.cc
deleted file mode 100644
index fe24484..0000000
--- a/exe/run_model_with_orbs_and_orb_slam_map.cc
+++ /dev/null
@@ -1,326 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#define NEAR_PLANE 0.1
-#define FAR_PLANE 20
-
-void drawPoints(std::vector<cv::Point3d> seen_points, std::vector<cv::Point3d> new_points_seen) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    const int point_size = data["pointSize"];
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(0.0, 0.0, 0.0);
-
-    for (auto point: seen_points) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(1.0, 0.0, 0.0);
-
-    for (auto point: new_points_seen) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    std::cout << new_points_seen.size() << std::endl;
-
-    glEnd();
-}
-
-Eigen::Matrix4f loadMatrixFromFile(const std::string &filename) {
-    Eigen::Matrix4f matrix;
-    std::ifstream infile(filename);
-
-    if (infile.is_open()) {
-        int row = 0;
-        std::string line;
-        while (std::getline(infile, line)) {
-            std::istringstream ss(line);
-            std::string value;
-            int col = 0;
-            while (std::getline(ss, value, ',')) {
-                matrix(row, col) = std::stof(value);
-                col++;
-            }
-            row++;
-        }
-        infile.close();
-    } else {
-        std::cerr << "Cannot open file: " << filename << std::endl;
-    }
-
-    return matrix;
-}
-
-cv::Point3d transformPoint(const cv::Point3d &point, const Eigen::Matrix4f &transformation) {
-    Eigen::Vector4f eigenPoint = Eigen::Vector4f((float)point.x, (float)point.y, (float)point.z, 1.0f);
-    Eigen::Vector4f transformedPoint = transformation * eigenPoint;
-    return cv::Point3d((double)transformedPoint(0), (double)transformedPoint(1), (double)transformedPoint(2));
-}
-
-std::vector<cv::Point3d> loadPoints() {
-    std::ifstream pointData;
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string cloud_points = std::string(data["mapInputDir"]) + "cloud1.csv";
-
-    std::vector<cv::Point3d> points;
-
-    pointData.open(cloud_points, std::ios::in);
-
-    while (!pointData.eof()) {
-        row.clear();
-
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            try
-            {
-                std::stod(word);
-            }
-            catch(std::out_of_range)
-            {
-                word = "0";
-            }
-            row.push_back(word);
-        }
-        points.push_back(cv::Point3d(std::stod(row[0]), std::stod(row[1]), std::stod(row[2])));
-    }
-    pointData.close();
-
-    return points;
-}
-
-// Function to read CSV file into a vector of cv::Point3d
-std::vector<cv::Point3d> readPointsFromCSV(const std::string& filePath) {
-    std::vector<cv::Point3d> points;
-    std::ifstream file(filePath);
-    std::string line;
-    double x, y, z;
-
-    while (std::getline(file, line)) {
-        std::stringstream lineStream(line);
-        std::string cell;
-
-        std::getline(lineStream, cell, ',');
-        x = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        y = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        z = std::stod(cell);
-
-        points.emplace_back(x, y, z);
-    }
-
-    return points;
-}
-
-int main(int argc, char **argv) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-    float viewpointX = fSettings["RunModel.ViewpointX"];
-    float viewpointY = fSettings["RunModel.ViewpointY"];
-    float viewpointZ = fSettings["RunModel.ViewpointZ"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    cv::Mat K_cv = (cv::Mat_<float>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
-    Eigen::Vector2i viewport_desired_size(640, 480);
-
-    cv::Mat img;
-
-    // Options
-    bool show_bounds = false;
-    bool show_axis = false;
-    bool show_x0 = false;
-    bool show_y0 = false;
-    bool show_z0 = false;
-    bool cull_backfaces = false;
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_desired_size[0], viewport_desired_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    pangolin::OpenGlRenderState s_cam(
-            pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE),
-            pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)
-    );
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float)-viewport_desired_size[0] / (float)viewport_desired_size[1]))
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    auto aabb = pangolin::GetAxisAlignedBox(geom_to_load);
-    Eigen::AlignedBox3f total_aabb;
-    total_aabb.extend(aabb);
-    const auto mvm = pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY);
-    const auto proj = pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE);
-    s_cam.SetModelViewMatrix(mvm);
-    s_cam.SetProjectionMatrix(proj);
-    const pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-
-    // Show axis and axis planes
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-
-    cv::Mat Twc;
-    bool use_lab_icp = bool(data["useLabICP"]);
-    std::cout << use_lab_icp << std::endl;
-
-    std::string transformation_matrix_csv_path;
-    if (use_lab_icp)
-    {
-        transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_lab_transformation_matrix.csv";
-    }
-    else
-    {
-        transformation_matrix_csv_path = std::string(data["framesOutput"]) + "frames_transformation_matrix.csv";
-    }
-    Eigen::Matrix4f transformation = loadMatrixFromFile(transformation_matrix_csv_path);
-    std::cout << transformation << std::endl;
-
-    std::vector<cv::Point3d> points_to_draw;
-    std::vector<cv::Point3d> points = loadPoints();
-
-    for (auto point : points) {
-        points_to_draw.push_back(transformPoint(point, transformation));
-    }
-
-    // Read points from multiple CSV files in the directory
-    std::vector<cv::Point3d> cloudPoints1;
-    std::string orbs_csv_dir = data["orbFrames"];
-    for (const auto& entry : std::filesystem::directory_iterator(orbs_csv_dir)) {
-        if (entry.path().extension() == ".csv") {
-            std::vector<cv::Point3d> points = readPointsFromCSV(entry.path());
-            cloudPoints1.insert(cloudPoints1.end(), points.begin(), points.end());
-        }
-    }
-
-    cv::VideoWriter writer;
-    writer.open("./data.avi", cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 30.0, cv::Size(viewport_desired_size[0], viewport_desired_size[1]), true);
-
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-
-    while (!pangolin::ShouldQuit()) {
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            if (cull_backfaces) {
-                glEnable(GL_CULL_FACE);
-                glCullFace(GL_BACK);
-            }
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw",  s_cam.GetProjectionMatrix() *  s_cam.GetModelViewMatrix());
-            pangolin::GlDraw( default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            s_cam.Apply();
-
-            glDisable(GL_CULL_FACE);
-
-            drawPoints(cloudPoints1, points_to_draw);
-
-            int viewport_size[4];
-            glGetIntegerv(GL_VIEWPORT, viewport_size);
-
-            pangolin::Image<unsigned char> buffer;
-            pangolin::VideoPixelFormat fmt = pangolin::VideoFormatFromString("RGB24");
-            buffer.Alloc(viewport_size[2], viewport_size[3], viewport_size[2] * fmt.bpp / 8);
-            glReadBuffer(GL_BACK);
-            glPixelStorei(GL_PACK_ALIGNMENT, 1);
-            glReadPixels(0, 0, viewport_size[2], viewport_size[3], GL_RGB, GL_UNSIGNED_BYTE, buffer.ptr);
-
-            cv::Mat imgBuffer = cv::Mat(viewport_size[3], viewport_size[2], CV_8UC3, buffer.ptr);
-            cv::flip(imgBuffer, imgBuffer, 0);
-
-            writer.write(imgBuffer);
-        }
-
-        pangolin::FinishFrame();
-    }
-
-    writer.release();
-
-    return 0;
-}
diff --git a/exe/run_model_with_printed_orbs.cc b/exe/run_model_with_printed_orbs.cc
deleted file mode 100644
index b8d877e..0000000
--- a/exe/run_model_with_printed_orbs.cc
+++ /dev/null
@@ -1,185 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#define NEAR_PLANE 0.1
-#define FAR_PLANE 20
-
-void drawPoints(std::vector<cv::Point3d> seen_points, std::vector<cv::Point3d> new_points_seen) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    const int point_size = data["pointSize"];
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(0.0, 0.0, 0.0);
-
-    for (auto point: seen_points) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    glEnd();
-
-    glPointSize(point_size);
-    glBegin(GL_POINTS);
-    glColor3f(1.0, 0.0, 0.0);
-
-    for (auto point: new_points_seen) {
-        glVertex3f((float) (point.x), (float) (point.y), (float) (point.z));
-    }
-    std::cout << new_points_seen.size() << std::endl;
-
-    glEnd();
-
-}
-
-// Function to read CSV file into a vector of cv::Point3d
-std::vector<cv::Point3d> readPointsFromCSV(const std::string& filePath) {
-    std::vector<cv::Point3d> points;
-    std::ifstream file(filePath);
-    std::string line;
-    double x, y, z;
-
-    while (std::getline(file, line)) {
-        std::stringstream lineStream(line);
-        std::string cell;
-
-        std::getline(lineStream, cell, ',');
-        x = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        y = std::stod(cell);
-
-        std::getline(lineStream, cell, ',');
-        z = std::stod(cell);
-
-        points.emplace_back(x, y, z);
-    }
-
-    return points;
-}
-
-int main(int argc, char **argv) {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-    float viewpointX = fSettings["RunModel.ViewpointX"];
-    float viewpointY = fSettings["RunModel.ViewpointY"];
-    float viewpointZ = fSettings["RunModel.ViewpointZ"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    cv::Mat K_cv = (cv::Mat_<float>(3, 3) << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0);
-    Eigen::Vector2i viewport_desired_size(640, 480);
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_desired_size[0], viewport_desired_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    pangolin::OpenGlRenderState s_cam(
-            pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE),
-            pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)
-    );
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float)-viewport_desired_size[0] / (float)viewport_desired_size[1]))
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    auto aabb = pangolin::GetAxisAlignedBox(geom_to_load);
-    Eigen::AlignedBox3f total_aabb;
-    total_aabb.extend(aabb);
-    const auto mvm = pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY);
-    const auto proj = pangolin::ProjectionMatrix(viewport_desired_size(0), viewport_desired_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), NEAR_PLANE, FAR_PLANE);
-    s_cam.SetModelViewMatrix(mvm);
-    s_cam.SetProjectionMatrix(proj);
-    const pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-
-    // Read points from multiple CSV files in the directory
-    std::vector<cv::Point3d> cloudPoints1;
-    std::string orbs_csv_dir = data["framesOutput"];
-    for (const auto& entry : std::filesystem::directory_iterator(orbs_csv_dir)) {
-        if (entry.path().extension() == ".csv") {
-            std::vector<cv::Point3d> points = readPointsFromCSV(entry.path());
-            cloudPoints1.insert(cloudPoints1.end(), points.begin(), points.end());
-        }
-    }
-
-    while (!pangolin::ShouldQuit()) {
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw",  s_cam.GetProjectionMatrix() *  s_cam.GetModelViewMatrix());
-            pangolin::GlDraw( default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            s_cam.Apply();
-
-            glDisable(GL_CULL_FACE);
-
-            drawPoints(std::vector<cv::Point3d>(), cloudPoints1);
-        }
-
-        pangolin::FinishFrame();
-    }
-
-    return 0;
-}
diff --git a/exe/run_orb_slam_matching.cc b/exe/run_orb_slam_matching.cc
deleted file mode 100644
index b701b46..0000000
--- a/exe/run_orb_slam_matching.cc
+++ /dev/null
@@ -1,160 +0,0 @@
-#include <memory>
-#include <string>
-#include <thread>
-#include <iostream>
-#include <unistd.h>
-#include <unordered_set>
-#include <nlohmann/json.hpp>
-#include <opencv2/videoio.hpp>
-#include <opencv2/highgui.hpp>
-
-#include "System.h"
-#include "Converter.h"
-#include "include/Point.h"
-#include "include/Auxiliary.h"
-
-/************* SIGNAL *************/
-std::unique_ptr<ORB_SLAM2::System> SLAM;
-std::string simulatorOutputDir;
-
-struct MatCompare {
-    bool operator()(const cv::Mat& a, const cv::Mat& b) const {
-        if (a.rows != b.rows || a.cols != b.cols || a.type() != b.type()) {
-            return false;
-        }
-        for (int i = 0; i < a.rows; i++) {
-            const void* a_row = a.ptr(i);
-            const void* b_row = b.ptr(i);
-            if (memcmp(a_row, b_row, a.cols*a.elemSize()) != 0) {
-                return false;
-            }
-        }
-        return true;
-    }
-};
-
-void stopProgramHandler(int s) {
-    SLAM->Shutdown();
-    cvDestroyAllWindows();
-    std::cout << "stoped program" << std::endl;
-    exit(1);
-}
-
-int main() {
-    signal(SIGINT, stopProgramHandler);
-    signal(SIGTERM, stopProgramHandler);
-    signal(SIGABRT, stopProgramHandler);
-    signal(SIGSEGV, stopProgramHandler);
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string vocPath = data["VocabularyPath"];
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-    std::string videoPath = data["offlineVideoTestPath"];
-    std::string loadMapPath = data["loadMapPath"];
-    SLAM = std::make_unique<ORB_SLAM2::System>(vocPath, droneYamlPathSlam, ORB_SLAM2::System::MONOCULAR, true, false,
-                                               loadMapPath,
-                                               true);
-    std::set<cv::Mat, MatCompare> descriptorsSet;
-    int amountOfAttepmpts = 0;
-    while (amountOfAttepmpts++ < 1) {
-        cv::VideoCapture capture(videoPath);
-        if (!capture.isOpened()) {
-            std::cout << "Error opening video stream or file" << std::endl;
-            return 0;
-        } else {
-            std::cout << "Success opening video stream or file" << std::endl;
-        }
-
-        cv::Mat frame;
-        std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
-        for (int i = 0; i < 170; ++i) {
-            capture >> frame;
-        }
-        int amount_of_frames = 1;
-
-        for (;;) {
-            SLAM->TrackMonocular(frame, capture.get(CV_CAP_PROP_POS_MSEC));
-
-            capture >> frame;
-
-            if (frame.empty()) {
-                break;
-            }
-
-            ORB_SLAM2::Frame& currentFrame = SLAM->GetTracker()->mCurrentFrame;
-            cv::Mat descriptorsFrame = currentFrame.mDescriptors;
-            descriptorsSet.insert(descriptorsFrame);
-        }
-        std::cout << amount_of_frames << std::endl;
-        capture.release();
-    }
-
-    SLAM->Shutdown();
-    cvDestroyAllWindows();
-
-    // Concatenate all the descriptors in descriptors_map
-
-    cv::Mat descriptorsOrbSlam;
-    std::vector<cv::Mat> descriptorsVec;
-    for (auto desc : descriptorsSet)
-        descriptorsVec.emplace_back(desc);
-    cv::vconcat(descriptorsVec, descriptorsOrbSlam);
-
-    // Set up ORB feature detector and matcher
-    cv::Ptr<cv::ORB> orb = cv::ORB::create(1000, 1.2, 8);
-    cv::BFMatcher matcher(cv::NORM_HAMMING, false);
-
-    // Process images in the input folder and find the one that matches the most
-    std::string frames_folder = data["framesFolder"];
-    std::string input_folder_path = frames_folder;
-    std::vector<std::string> image_paths;
-    std::vector<cv::Mat> descriptors_images;
-    std::vector<int> scores;
-    for (const auto& entry : std::filesystem::directory_iterator(input_folder_path)) {
-        // Load image
-        cv::Mat img = cv::imread(entry.path().string(), cv::IMREAD_GRAYSCALE);
-
-        // Extract ORB keypoints and descriptors from the image
-        std::vector<cv::KeyPoint> keypoints;
-        cv::Mat descriptors;
-        orb->detectAndCompute(img, cv::Mat(), keypoints, descriptors);
-
-        // Match descriptors with the map
-        std::vector<std::vector<cv::DMatch>> matches;
-        matcher.knnMatch(descriptors, descriptorsOrbSlam, matches, 2);
-
-        // Find good matches
-        std::vector<cv::DMatch> good_matches;
-        for (auto& match: matches) {
-            if (match[0].distance < 0.7 * match[1].distance) {
-                good_matches.push_back(match[0]);
-            }
-        }
-
-        // Save the image path and descriptors
-        image_paths.push_back(entry.path().string());
-        descriptors_images.push_back(descriptors);
-        scores.push_back((int)good_matches.size());
-
-        // Print the score
-        std::cout << "Image: " << entry.path().string() << ", Score: " << good_matches.size() << std::endl;
-    }
-
-    // Find the image with the highest similarity score
-    int best_index = 0;
-    double best_score = 0;
-    for (int i = 0; i < image_paths.size(); ++i) {
-        if (scores[i] > best_score) {
-            best_index = i;
-            best_score = scores[i];
-        }
-    }
-
-    std::cout << "Best Image: " << image_paths[best_index] << ", Score: " << best_score << std::endl;
-
-    return 0;
-}
diff --git a/exe/save_map.cc b/exe/save_map.cc
deleted file mode 100644
index 8b09516..0000000
--- a/exe/save_map.cc
+++ /dev/null
@@ -1,76 +0,0 @@
-#include <memory>
-#include <string>
-#include <thread>
-#include <iostream>
-#include <unistd.h>
-#include <unordered_set>
-#include <nlohmann/json.hpp>
-#include <opencv2/videoio.hpp>
-#include <opencv2/highgui.hpp>
-
-#include "System.h"
-#include "Converter.h"
-#include "include/Point.h"
-#include "include/Auxiliary.h"
-
-/************* SIGNAL *************/
-std::unique_ptr<ORB_SLAM2::System> SLAM;
-std::string simulatorOutputDir;
-
-
-void saveMap(int mapNumber) {
-    std::ofstream pointData;
-    std::unordered_set<int> seen_frames;
-
-    pointData.open(simulatorOutputDir + "cloud" + std::to_string(mapNumber) + ".csv");
-    for (auto &p: SLAM->GetMap()->GetAllMapPoints()) {
-        if (p != nullptr && !p->isBad()) {
-            auto point = p->GetWorldPos();
-            Eigen::Matrix<double, 3, 1> vector = ORB_SLAM2::Converter::toVector3d(point);
-            cv::Mat worldPos = cv::Mat::zeros(3, 1, CV_64F);
-            worldPos.at<double>(0) = vector.x();
-            worldPos.at<double>(1) = vector.y();
-            worldPos.at<double>(2) = vector.z();
-            pointData << worldPos.at<double>(0) << "," << worldPos.at<double>(1) << "," << worldPos.at<double>(2);
-            pointData << std::endl;
-        }
-    }
-    pointData.close();
-    std::cout << "saved map" << std::endl;
-
-}
-
-int main() {
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-    char currentDirPath[256];
-    getcwd(currentDirPath, 256);
-
-    char time_buf[21];
-    time_t now;
-    std::time(&now);
-    std::strftime(time_buf, 21, "%Y-%m-%d_%H:%S:%MZ", gmtime(&now));
-    std::string currentTime(time_buf);
-    std::string vocPath = data["VocabularyPath"];
-    std::string droneYamlPathSlam = data["DroneYamlPathSlam"];
-    std::string videoPath = data["offlineVideoTestPath"];
-    bool loadMap = data["loadMap"];
-    bool isSavingMap = data["saveMap"];
-    std::string loadMapPath = data["loadMapPath"];
-    std::string simulatorOutputDirPath = data["simulatorOutputDir"];
-    simulatorOutputDir = simulatorOutputDirPath + currentTime + "/";
-    std::filesystem::create_directory(simulatorOutputDir);
-    SLAM = std::make_unique<ORB_SLAM2::System>(vocPath, droneYamlPathSlam, ORB_SLAM2::System::MONOCULAR, true, true,
-                                               simulatorOutputDirPath + "simulatorMap.bin",
-                                               false);
-
-    saveMap(0);
-
-    SLAM->Shutdown();
-    cvDestroyAllWindows();
-
-    return 0;
-}
diff --git a/exe/see_keypoints.cc b/exe/see_keypoints.cc
deleted file mode 100644
index 3b91429..0000000
--- a/exe/see_keypoints.cc
+++ /dev/null
@@ -1,47 +0,0 @@
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-#include <iostream>
-#include <string>
-
-#include "include/Auxiliary.h"
-
-#include "ORBextractor.h"
-
-int main(void)
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fSettings.isOpened())
-    {
-        std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-        exit(-1);
-    }
-
-    int nFeatures = fSettings["ORBextractor.nFeatures"];
-    float fScaleFactor = fSettings["ORBextractor.scaleFactor"];
-    int nLevels = fSettings["ORBextractor.nLevels"];
-    int fIniThFAST = fSettings["ORBextractor.iniThFAST"];
-    int fMinThFAST = fSettings["ORBextractor.minThFAST"];
-
-    cv::Mat img = cv::imread("/home/liam/Documents/slamMaps/example_mapping11/frame_45.png");
-    cv::cvtColor(img, img,  cv::COLOR_RGBA2GRAY);
-    img.convertTo(img, CV_8UC1);
-    ORB_SLAM2::ORBextractor* orbExtractor = new ORB_SLAM2::ORBextractor(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);
-    // Detect keypoints
-    std::vector<cv::KeyPoint> keypoints;
-    cv::Mat descriptors;
-    (*orbExtractor)(img, cv::Mat(), keypoints, descriptors);
-
-    // Draw keypoints on the image
-    cv::Mat image_keypoints;
-    cv::drawKeypoints(img, keypoints, image_keypoints);
-
-    cv::imwrite("/home/liam/image_keypoints.png", image_keypoints);
-    cv::waitKey(2);
-    return 0;}
diff --git a/exe/simulator.cc b/exe/simulator.cc
deleted file mode 100644
index 3542a10..0000000
--- a/exe/simulator.cc
+++ /dev/null
@@ -1,113 +0,0 @@
-#include <opencv2/opencv.hpp>
-#include <termios.h> // for getch()
-#include <iostream>
-
-#include "include/Auxiliary.h"
-
-int main() {
-     // Initialize the data structure
-    std::vector<cv::Point3d> points_seen;
-
-    termios old_settings, new_settings;
-    tcgetattr(STDIN_FILENO, &old_settings);
-    new_settings = old_settings;
-    new_settings.c_lflag &= ~(ICANON | ECHO);
-    tcsetattr(STDIN_FILENO, TCSANOW, &new_settings);
-
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-    std::string map_input_dir = data["mapInputDir"];
-    const std::string cloud_points = map_input_dir + "cloud1.csv";
-
-    double startPointX = data["startingCameraPosX"];
-    double startPointY = data["startingCameraPosY"];
-    double startPointZ = data["startingCameraPosZ"];
-    cv::Point3d start_position = cv::Point3d(startPointX, startPointY, startPointZ);
-    double yaw = data["yawRad"];
-    double pitch = data["pitchRad"];
-    double roll = data["rollRad"];
-
-    cv::Mat Twc;
-
-    points_seen = Auxiliary::getPointsFromPos(cloud_points, start_position, yaw, pitch, roll, Twc);
-
-    cv::Point3d current_position = start_position;
-    double current_yaw = yaw, current_pitch = pitch, current_roll = roll;
-
-    // Wait for user input and update position/orientation
-    char ch = '\0';
-    do {
-        // Update the points seen
-        std::vector<cv::Point3d> new_points_seen = Auxiliary::getPointsFromPos(cloud_points, current_position, current_yaw, current_pitch, current_roll, Twc);
-
-        std::vector<cv::Point3d>::iterator it;
-        for (it = new_points_seen.begin(); it != new_points_seen.end();)
-        {
-            if (std::find(points_seen.begin(), points_seen.end(), *it) != points_seen.end())
-            {
-                it = new_points_seen.erase(it);
-            }
-            else
-            {
-                ++it;
-            }
-        }
-
-
-        std::cout << "new: " << new_points_seen.size() << std::endl;
-        points_seen.insert(points_seen.end(), new_points_seen.begin(), new_points_seen.end());
-        std::cout << "total: " << points_seen.size() << std::endl;
-        // Wait for user input
-
-        // Print current position and orientation
-        std::cout << "Position: (" << current_position.x << ", " << current_position.y << ", " << current_position.z << ")" << std::endl;
-        std::cout << "Yaw: " << current_yaw << ", Pitch: " << current_pitch << ", Roll: " << current_roll << std::endl;
-
-        ch = std::cin.get();
-
-        double rotateScale = data["rotateScale"];
-        double movingScale = data["movingScale"];
-
-        // Update position/orientation based on input
-        switch(ch) {
-            case 'a':
-                current_yaw -= rotateScale;
-                break;
-            case 'd':
-                current_yaw += rotateScale;
-                break;
-            case 'w':
-                current_pitch += rotateScale;
-                break;
-            case 's':
-                current_pitch -= rotateScale;
-                break;
-            case 'i': // up arrow
-                current_position.y += movingScale * cos(current_pitch) * cos(current_yaw);
-                current_position.x -= movingScale * cos(current_pitch) * sin(current_yaw);
-                current_position.z -= movingScale * sin(current_pitch);
-                break;
-            case 'k': // down arrow
-                current_position.y -= movingScale * cos(current_pitch) * cos(current_yaw);
-                current_position.x += movingScale * cos(current_pitch) * sin(current_yaw);
-                current_position.z += movingScale * sin(current_pitch);
-                break;
-            case 'j': // left arrow
-                current_position.x += movingScale * cos(current_yaw);
-                current_position.y += movingScale * sin(current_yaw);
-                break;
-            case 'l': // right arrow
-                current_position.x -= movingScale * cos(current_yaw);
-                current_position.y -= movingScale * sin(current_yaw);
-                break;
-        }
-
-    } while(ch != 27); // 27 is the ASCII code for escape
-
-    tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
-
-    return 0;
-}
diff --git a/exe/take_frame_images.cc b/exe/take_frame_images.cc
deleted file mode 100644
index 2c6a4df..0000000
--- a/exe/take_frame_images.cc
+++ /dev/null
@@ -1,190 +0,0 @@
-#include <thread>
-#include <future>
-#include <queue>
-
-#include <pangolin/pangolin.h>
-#include <pangolin/geometry/geometry.h>
-#include <pangolin/gl/glsl.h>
-#include <pangolin/gl/glvbo.h>
-
-#include <pangolin/utils/file_utils.h>
-
-#include <pangolin/geometry/geometry_ply.h>
-#include <pangolin/geometry/glgeometry.h>
-
-#include "include/run_model/TextureShader.h"
-#include "include/Auxiliary.h"
-
-#include <Eigen/SVD>
-#include <Eigen/Geometry>
-
-#include <opencv2/core.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-Eigen::Matrix4d read_matrix_4d_from_csv(std::string filename)
-{
-    Eigen::Matrix4d matrix;
-
-    std::ifstream csv_file(filename);
-
-    if (!csv_file.is_open()) {
-        std::cerr << "Error: could not open file '" << filename << "' for reading." << std::endl;
-        return matrix;
-    }
-
-    // Read matrix elements from file
-    std::string line;
-    int row = 0;
-    while (std::getline(csv_file, line) && row < 4) {
-        std::stringstream line_stream(line);
-        std::string cell;
-        int col = 0;
-        while (std::getline(line_stream, cell, ',') && col < 4) {
-            matrix(row, col) = std::stod(cell);
-            col++;
-        }
-        row++;
-    }
-
-    csv_file.close();
-
-    return matrix;
-}
-
-
-int main(int argc, char **argv) {
-
-    using namespace pangolin;
-
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    std::string configPath = data["DroneYamlPathSlam"];
-    cv::FileStorage fSettings(configPath, cv::FileStorage::READ);
-
-    // Read matrices
-    int frame_to_check = data["frameNumber"];
-    std::string mv_filename = std::string(data["framesOutput"]) + "frame_" + std::to_string(frame_to_check) + "_mv.csv";
-    Eigen::Matrix4d mv_mat = read_matrix_4d_from_csv(mv_filename);
-    std::string proj_filename = std::string(data["framesOutput"]) + "frame_" + std::to_string(frame_to_check) + "_proj.csv";
-    Eigen::Matrix4d proj_mat = read_matrix_4d_from_csv(proj_filename);
-    
-    float fx = fSettings["Camera.fx"];
-    float fy = fSettings["Camera.fy"];
-    float cx = fSettings["Camera.cx"];
-    float cy = fSettings["Camera.cy"];
-    float viewpointX = fSettings["RunModel.ViewpointX"];
-    float viewpointY = fSettings["RunModel.ViewpointY"];
-    float viewpointZ = fSettings["RunModel.ViewpointZ"];
-
-    Eigen::Matrix3d K;
-    K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    Eigen::Vector2f viewport_size(fSettings["Camera.width"], fSettings["Camera.height"]);
-
-
-    // Options
-    bool show_bounds = false;
-    bool show_axis = false;
-    bool show_x0 = false;
-    bool show_y0 = false;
-    bool show_z0 = false;
-    bool cull_backfaces = false;
-
-    // Create Window for rendering
-    pangolin::CreateWindowAndBind("Main", viewport_size[0], viewport_size[1]);
-    glEnable(GL_DEPTH_TEST);
-
-    // Define Projection and initial ModelView matrix
-    pangolin::OpenGlRenderState s_cam(
-            pangolin::ProjectionMatrix(viewport_size(0), viewport_size(1), K(0, 0), K(1, 1), K(0, 2), K(1, 2), 0.1, 10000),
-            pangolin::ModelViewLookAt(viewpointX, viewpointY, viewpointZ, 0, 0, 0, 0.0, -1.0, pangolin::AxisY)
-    );
-
-    // Create Interactive View in window
-    pangolin::Handler3D handler(s_cam);
-    pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, -viewport_size[0] / viewport_size[1])
-            .SetHandler(&handler);
-
-    // Load Geometry asynchronously
-    std::string model_path = data["modelPath"];
-    const pangolin::Geometry geom_to_load = pangolin::LoadGeometry(model_path);
-    auto aabb = pangolin::GetAxisAlignedBox(geom_to_load);
-    Eigen::AlignedBox3f total_aabb;
-    total_aabb.extend(aabb);
-    s_cam.SetModelViewMatrix(mv_mat);
-    s_cam.SetProjectionMatrix(proj_mat);
-    const pangolin::GlGeometry geomToRender = pangolin::ToGlGeometry(geom_to_load);
-    // Render tree for holding object position
-    pangolin::GlSlProgram default_prog;
-    auto LoadProgram = [&]() {
-        default_prog.ClearShaders();
-        default_prog.AddShader(pangolin::GlSlAnnotatedShader, shader);
-        default_prog.Link();
-    };
-    LoadProgram();
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-
-    // Show axis and axis planes
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-
-    Eigen::Vector3d Pick_w = handler.Selected_P_w();
-    std::vector<Eigen::Vector3d> Picks_w;
-    cv::Mat img;
-
-    while (!pangolin::ShouldQuit()) {
-        if ((handler.Selected_P_w() - Pick_w).norm() > 1E-6) {
-            Pick_w = handler.Selected_P_w();
-            Picks_w.push_back(Pick_w);
-            std::cout << pangolin::FormatString("\"Translation\": [%,%,%]", Pick_w[0], Pick_w[1], Pick_w[2])
-                      << std::endl;
-        }
-
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        // Load any pending geometry to the GPU.
-        if (d_cam.IsShown()) {
-            d_cam.Activate();
-
-            if (cull_backfaces) {
-                glEnable(GL_CULL_FACE);
-                glCullFace(GL_BACK);
-            }
-            default_prog.Bind();
-            default_prog.SetUniform("KT_cw",  s_cam.GetProjectionMatrix() *  s_cam.GetModelViewMatrix());
-            pangolin::GlDraw( default_prog, geomToRender, nullptr);
-            default_prog.Unbind();
-
-            s_cam.Apply();
-
-            glDisable(GL_CULL_FACE);
-
-            pangolin::Image<unsigned char> buffer;
-            pangolin::VideoPixelFormat fmt = pangolin::VideoFormatFromString("RGBA32");
-            buffer.Alloc(viewport_size[0], viewport_size[1], viewport_size[0] * fmt.bpp/8 );
-            glReadBuffer(GL_BACK);
-            glPixelStorei(GL_PACK_ALIGNMENT, 1);
-            glReadPixels(0, 0, viewport_size[0], viewport_size[1], GL_RGBA, GL_UNSIGNED_BYTE, buffer.ptr );
- 
-            cv::Mat  imgBuffer = cv::Mat(viewport_size[1], viewport_size[0], CV_8UC4, buffer.ptr);
-            cv::cvtColor(imgBuffer, img,  cv::COLOR_RGBA2BGR);
-            cv::flip(img, img, 0);
-
-            pangolin::FinishFrame();
-            break;
-        }
-    }
-
-    std::string frame_location = std::string(data["framesOutput"]) + "frame_" + std::to_string(frame_to_check) + ".png";
-    cv::imwrite(frame_location, img);
-
-    return 0;
-}
diff --git a/exe/testOnMonocularEurocDataset.cpp b/exe/testOnMonocularEurocDataset.cpp
new file mode 100644
index 0000000..069f6c0
--- /dev/null
+++ b/exe/testOnMonocularEurocDataset.cpp
@@ -0,0 +1,151 @@
+/**
+* This file is part of ORB-SLAM2.
+*
+* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+* For more information see <https://github.com/raulmur/ORB_SLAM2>
+*
+* ORB-SLAM2 is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation, either version 3 of the License, or
+* (at your option) any later version.
+*
+* ORB-SLAM2 is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#include<iostream>
+#include<algorithm>
+#include<fstream>
+#include<chrono>
+
+#include<opencv2/core/core.hpp>
+
+#include<System.h>
+
+using namespace std;
+
+void LoadImages(const string &strImagePath, const string &strPathTimes,
+                vector<string> &vstrImages, vector<double> &vTimeStamps);
+
+int main(int argc, char **argv)
+{
+    if(argc != 5)
+    {
+        cerr << endl << "Usage: ./mono_tum path_to_vocabulary path_to_settings path_to_image_folder path_to_times_file" << endl;
+        return 1;
+    }
+
+    // Retrieve paths to images
+    vector<string> vstrImageFilenames;
+    vector<double> vTimestamps;
+    LoadImages(string(argv[3]), string(argv[4]), vstrImageFilenames, vTimestamps);
+
+    int nImages = vstrImageFilenames.size();
+
+    if(nImages<=0)
+    {
+        cerr << "ERROR: Failed to load images" << endl;
+        return 1;
+    }
+
+    // Create SLAM system. It initializes all system threads and gets ready to process frames.
+    ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::MONOCULAR,true);
+
+    // Vector for tracking time statistics
+    vector<float> vTimesTrack;
+    vTimesTrack.resize(nImages);
+
+    cout << endl << "-------" << endl;
+    cout << "Start processing sequence ..." << endl;
+    cout << "Images in the sequence: " << nImages << endl << endl;
+
+    // Main loop
+    cv::Mat im;
+    for(int ni=0; ni<nImages; ni++)
+    {
+        // Read image from file
+        im = cv::imread(vstrImageFilenames[ni],CV_LOAD_IMAGE_UNCHANGED);
+        double tframe = vTimestamps[ni];
+
+        if(im.empty())
+        {
+            cerr << endl << "Failed to load image at: "
+                 <<  vstrImageFilenames[ni] << endl;
+            return 1;
+        }
+
+        std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
+
+        // Pass the image to the SLAM system
+        SLAM.TrackMonocular(im,tframe);
+
+        std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();
+
+        double ttrack= std::chrono::duration_cast<std::chrono::duration<double> >(t2 - t1).count();
+
+        vTimesTrack[ni]=ttrack;
+
+        // Wait to load the next frame
+        double T=0;
+        if(ni<nImages-1)
+            T = vTimestamps[ni+1]-tframe;
+        else if(ni>0)
+            T = tframe-vTimestamps[ni-1];
+
+        if(ttrack<T)
+            Sleep((T-ttrack)*1e3);
+    }
+
+    // Stop all threads
+    SLAM.Shutdown();
+
+    // Tracking time statistics
+    sort(vTimesTrack.begin(),vTimesTrack.end());
+    float totaltime = 0;
+    for(int ni=0; ni<nImages; ni++)
+    {
+        totaltime+=vTimesTrack[ni];
+    }
+    cout << "-------" << endl << endl;
+    cout << "median tracking time: " << vTimesTrack[nImages/2] << endl;
+    cout << "mean tracking time: " << totaltime/nImages << endl;
+
+    // Save camera trajectory
+    SLAM.SaveKeyFrameTrajectoryTUM("KeyFrameTrajectory.txt");
+
+    return 0;
+}
+
+void LoadImages(const string &strImagePath, const string &strPathTimes,
+                vector<string> &vstrImages, vector<double> &vTimeStamps)
+{
+    ifstream fTimes;
+    fTimes.open(strPathTimes.c_str());
+    vTimeStamps.reserve(5000);
+    vstrImages.reserve(5000);
+    string s;
+    getline(fTimes,s);
+    while(!fTimes.eof())
+    {
+        getline(fTimes,s);
+        if(!s.empty())
+        {
+            stringstream ss;
+            ss << s;
+            std::getline(ss,s,',');
+            double t = std::stod(s);
+            vTimeStamps.push_back(t/1e9);
+            std::getline(ss,s,',');
+
+            vstrImages.push_back(strImagePath + "/" + s);
+            
+
+        }
+    }
+}
\ No newline at end of file
diff --git a/exe/testOnMonocularKittiDataset.cpp b/exe/testOnMonocularKittiDataset.cpp
new file mode 100644
index 0000000..93b86fe
--- /dev/null
+++ b/exe/testOnMonocularKittiDataset.cpp
@@ -0,0 +1,150 @@
+/**
+* This file is part of ORB-SLAM2.
+*
+* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+* For more information see <https://github.com/raulmur/ORB_SLAM2>
+*
+* ORB-SLAM2 is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation, either version 3 of the License, or
+* (at your option) any later version.
+*
+* ORB-SLAM2 is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#include<iostream>
+#include<algorithm>
+#include<fstream>
+#include<chrono>
+#include<iomanip>
+
+#include<opencv2/core/core.hpp>
+
+#include"System.h"
+
+using namespace std;
+
+void LoadImages(const string &strSequence, vector<string> &vstrImageFilenames,
+                vector<double> &vTimestamps);
+
+int main(int argc, char **argv)
+{
+    if(argc != 4)
+    {
+        cerr << std::endl << "Usage: ./mono_kitti path_to_vocabulary path_to_settings path_to_sequence" << std::endl;
+        return 1;
+    }
+
+    // Retrieve paths to images
+    vector<string> vstrImageFilenames;
+    vector<double> vTimestamps;
+    LoadImages(string(argv[3]), vstrImageFilenames, vTimestamps);
+
+    int nImages = vstrImageFilenames.size();
+
+    // Create SLAM system. It initializes all system threads and gets ready to process frames.
+    ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::MONOCULAR,true);
+
+    // Vector for tracking time statistics
+    vector<float> vTimesTrack;
+    vTimesTrack.resize(nImages);
+
+    std::cout << std::endl << "-------" << std::endl;
+    std::cout << "Start processing sequence ..." << std::endl;
+    std::cout << "Images in the sequence: " << nImages << std::endl << std::endl;
+
+    // Main loop
+    cv::Mat im;
+    for(int ni=0; ni<nImages; ni++)
+    {
+        // Read image from file
+        im = cv::imread(vstrImageFilenames[ni],CV_LOAD_IMAGE_UNCHANGED);
+        double tframe = vTimestamps[ni];
+
+        if(im.empty())
+        {
+            cerr << std::endl << "Failed to load image at: " << vstrImageFilenames[ni] << std::endl;
+            return 1;
+        }
+
+        std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
+
+        // Pass the image to the SLAM system
+        SLAM.TrackMonocular(im,tframe);
+
+        std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();
+
+
+        double ttrack= std::chrono::duration_cast<std::chrono::duration<double> >(t2 - t1).count();
+
+        vTimesTrack[ni]=ttrack;
+
+        // Wait to load the next frame
+        double T=0;
+        if(ni<nImages-1)
+            T = vTimestamps[ni+1]-tframe;
+        else if(ni>0)
+            T = tframe-vTimestamps[ni-1];
+
+        if(ttrack<T)
+            Sleep((T-ttrack)*1e3);
+    }
+
+    // Stop all threads
+    SLAM.Shutdown();
+
+    // Tracking time statistics
+    std::sort(vTimesTrack.begin(),vTimesTrack.end());
+    float totaltime = 0;
+    for(int ni=0; ni<nImages; ni++)
+    {
+        totaltime+=vTimesTrack[ni];
+    }
+    std::cout << "-------" << std::endl << std::endl;
+    std::cout << "median tracking time: " << vTimesTrack[nImages/2] << std::endl;
+    std::cout << "mean tracking time: " << totaltime/nImages << std::endl;
+
+    // Save camera trajectory
+    SLAM.SaveKeyFrameTrajectoryTUM("KeyFrameTrajectory.txt");    
+
+    return 0;
+}
+
+void LoadImages(const string &strPathToSequence, vector<string> &vstrImageFilenames, vector<double> &vTimestamps)
+{
+    ifstream fTimes;
+    string strPathTimeFile = strPathToSequence + "/times.txt";
+    fTimes.open(strPathTimeFile.c_str());
+    while(!fTimes.eof())
+    {
+        string s;
+        getline(fTimes,s);
+        if(!s.empty())
+        {
+            stringstream ss;
+            ss << s;
+            double t;
+            ss >> t;
+            vTimestamps.push_back(t);
+        }
+    }
+
+    string strPrefixLeft = strPathToSequence + "/image_0/";
+
+    const int nTimes = vTimestamps.size();
+    vstrImageFilenames.resize(nTimes);
+
+    for(int i=0; i<nTimes; i++)
+    {
+        stringstream ss;
+        ss << setfill('0') << setw(6) << i;
+        vstrImageFilenames[i] = strPrefixLeft + ss.str() + ".png";
+    }
+}
\ No newline at end of file
diff --git a/exe/testOnStereoKittiDataset.cpp b/exe/testOnStereoKittiDataset.cpp
new file mode 100644
index 0000000..acca435
--- /dev/null
+++ b/exe/testOnStereoKittiDataset.cpp
@@ -0,0 +1,158 @@
+/**
+* This file is part of ORB-SLAM2.
+*
+* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+* For more information see <https://github.com/raulmur/ORB_SLAM2>
+*
+* ORB-SLAM2 is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation, either version 3 of the License, or
+* (at your option) any later version.
+*
+* ORB-SLAM2 is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+#include<iostream>
+#include<algorithm>
+#include<fstream>
+#include<iomanip>
+#include<chrono>
+
+#include<opencv2/core/core.hpp>
+
+#include<System.h>
+
+using namespace std;
+
+void LoadImages(const string &strPathToSequence, vector<string> &vstrImageLeft,
+                vector<string> &vstrImageRight, vector<double> &vTimestamps);
+
+int main(int argc, char **argv)
+{
+    if(argc != 4)
+    {
+        cerr << endl << "Usage: ./stereo_kitti path_to_vocabulary path_to_settings path_to_sequence" << endl;
+        return 1;
+    }
+
+    // Retrieve paths to images
+    vector<string> vstrImageLeft;
+    vector<string> vstrImageRight;
+    vector<double> vTimestamps;
+    LoadImages(string(argv[3]), vstrImageLeft, vstrImageRight, vTimestamps);
+
+    const int nImages = vstrImageLeft.size();
+
+    // Create SLAM system. It initializes all system threads and gets ready to process frames.
+    ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::STEREO,true);
+
+    // Vector for tracking time statistics
+    vector<float> vTimesTrack;
+    vTimesTrack.resize(nImages);
+
+    cout << endl << "-------" << endl;
+    cout << "Start processing sequence ..." << endl;
+    cout << "Images in the sequence: " << nImages << endl << endl;   
+
+    // Main loop
+    cv::Mat imLeft, imRight;
+    for(int ni=0; ni<nImages; ni++)
+    {
+        // Read left and right images from file
+        imLeft = cv::imread(vstrImageLeft[ni],CV_LOAD_IMAGE_UNCHANGED);
+        imRight = cv::imread(vstrImageRight[ni],CV_LOAD_IMAGE_UNCHANGED);
+        double tframe = vTimestamps[ni];
+
+        if(imLeft.empty())
+        {
+            cerr << endl << "Failed to load image at: "
+                 << string(vstrImageLeft[ni]) << endl;
+            return 1;
+        }
+
+        std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();
+
+
+        // Pass the images to the SLAM system
+        SLAM.TrackStereo(imLeft,imRight,tframe);
+
+        std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();
+
+
+        double ttrack= std::chrono::duration_cast<std::chrono::duration<double> >(t2 - t1).count();
+
+        vTimesTrack[ni]=ttrack;
+
+        // Wait to load the next frame
+        double T=0;
+        if(ni<nImages-1)
+            T = vTimestamps[ni+1]-tframe;
+        else if(ni>0)
+            T = tframe-vTimestamps[ni-1];
+
+        if(ttrack<T)
+           Sleep((T-ttrack)*1e3);
+    }
+
+    // Stop all threads
+    SLAM.Shutdown();
+
+    // Tracking time statistics
+    sort(vTimesTrack.begin(),vTimesTrack.end());
+    float totaltime = 0;
+    for(int ni=0; ni<nImages; ni++)
+    {
+        totaltime+=vTimesTrack[ni];
+    }
+    cout << "-------" << endl << endl;
+    cout << "median tracking time: " << vTimesTrack[nImages/2] << endl;
+    cout << "mean tracking time: " << totaltime/nImages << endl;
+
+    // Save camera trajectory
+    SLAM.SaveTrajectoryKITTI("CameraTrajectory.txt");
+
+    return 0;
+}
+
+void LoadImages(const string &strPathToSequence, vector<string> &vstrImageLeft,
+                vector<string> &vstrImageRight, vector<double> &vTimestamps)
+{
+    ifstream fTimes;
+    string strPathTimeFile = strPathToSequence + "/times.txt";
+    fTimes.open(strPathTimeFile.c_str());
+    while(!fTimes.eof())
+    {
+        string s;
+        getline(fTimes,s);
+        if(!s.empty())
+        {
+            stringstream ss;
+            ss << s;
+            double t;
+            ss >> t;
+            vTimestamps.push_back(t);
+        }
+    }
+
+    string strPrefixLeft = strPathToSequence + "/image_0/";
+    string strPrefixRight = strPathToSequence + "/image_1/";
+
+    const int nTimes = vTimestamps.size();
+    vstrImageLeft.resize(nTimes);
+    vstrImageRight.resize(nTimes);
+
+    for(int i=0; i<nTimes; i++)
+    {
+        stringstream ss;
+        ss << setfill('0') << setw(6) << i;
+        vstrImageLeft[i] = strPrefixLeft + ss.str() + ".png";
+        vstrImageRight[i] = strPrefixRight + ss.str() + ".png";
+    }
+}
\ No newline at end of file
diff --git a/exe/unused/get_points_from_camera.cc b/exe/unused/get_points_from_camera.cc
deleted file mode 100644
index e1c42f0..0000000
--- a/exe/unused/get_points_from_camera.cc
+++ /dev/null
@@ -1,54 +0,0 @@
-#include <math.h>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    const cv::Point3f camera_position(data["startingCameraPosX"], data["startingCameraPosY"], data["startingCameraPosZ"]);
-
-    // Between -180 to 180, yaw
-    double yaw = data["yawDegree"];
-    // Between -180 to 180, pitch
-    double pitch = data["pitchDegree"];
-    // between -180 to 180, roll
-    double roll = data["rollDegree"];
-
-    float fx = fsSettings["Camera.fx"];
-    float fy = fsSettings["Camera.fy"];
-    float cx = fsSettings["Camera.cx"];
-    float cy = fsSettings["Camera.cy"];
-    float k1 = fsSettings["Camera.k1"];
-    float k2 = fsSettings["Camera.k2"];
-    float k3 = fsSettings["Camera.k3"];
-    float p1 = fsSettings["Camera.p1"];
-    float p2 = fsSettings["Camera.p2"];
-    int width = fsSettings["Camera.width"];
-    int height = fsSettings["Camera.height"];
-
-    std::vector<cv::Point3f> points;
-    Auxiliary::getPoints(data["getPointDataCsv"], &points, camera_position, fx, fy, cx, cy, k1, k2, k3, p1, p2, width, height, roll, yaw, pitch);
-
-    for(cv::Point3f  point : points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    return 0;
-}
diff --git a/exe/unused/get_points_from_camera_orb_slam.cc b/exe/unused/get_points_from_camera_orb_slam.cc
deleted file mode 100644
index 23d14a1..0000000
--- a/exe/unused/get_points_from_camera_orb_slam.cc
+++ /dev/null
@@ -1,79 +0,0 @@
-#include <math.h>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    const cv::Point3f camera_position(data["startingCameraPosX"], data["startingCameraPosY"], data["startingCameraPosZ"]);
-
-    // Between -180 to 180, yaw
-    double yaw_degree = data["yawDegree"];
-    // Between -180 to 180, pitch
-    double pitch_degree = data["pitchDegree"];
-    // between -180 to 180, roll
-    double roll_degree = data["rollDegree"];
-
-    double yaw = yaw_degree * CV_PI / 180.0;
-    double pitch = pitch_degree * CV_PI / 180.0;
-    double roll = roll_degree * CV_PI / 180.0;
-
-    float fx = fsSettings["Camera.fx"];
-    float fy = fsSettings["Camera.fy"];
-    float cx = fsSettings["Camera.cx"];
-    float cy = fsSettings["Camera.cy"];
-
-    cv::Mat K = cv::Mat::zeros(3, 3, CV_64F);
-    K.at<double>(0, 0) = fx;
-    K.at<double>(1, 1) = fy;
-    K.at<double>(0, 2) = cx;
-    K.at<double>(1, 2) = cy;
-    K.at<double>(2, 2) = 1.0;
-
-
-    cv::Mat R = (cv::Mat_<float>(3, 3) <<
-             cos(pitch)*cos(yaw), cos(pitch)*sin(yaw), -sin(pitch),
-             sin(roll)*sin(pitch)*cos(yaw)-cos(roll)*sin(yaw), 
-             sin(roll)*sin(pitch)*sin(yaw)+cos(roll)*cos(yaw), 
-             sin(roll)*cos(pitch), 
-             cos(roll)*sin(pitch)*cos(yaw)+sin(roll)*sin(yaw), 
-             cos(roll)*sin(pitch)*sin(yaw)-sin(roll)*cos(yaw), 
-             cos(roll)*cos(pitch));
-
-    // Create translation vector from camera position
-    cv::Mat t = (cv::Mat_<float>(3, 1) << camera_position.x, camera_position.y, camera_position.z);
-
-    // Create camera matrix
-    cv::Mat P = K * (cv::Mat_<float>(3, 4) << R.at<float>(0,0), R.at<float>(0,1), R.at<float>(0,2), t.at<float>(0,0),
-                                            R.at<float>(1,0), R.at<float>(1,1), R.at<float>(1,2), t.at<float>(1,0),
-                                            R.at<float>(2,0), R.at<float>(2,1), R.at<float>(2,2), t.at<float>(2,0));
-
-
-
-    std::vector<cv::Point3f> seen_points;
-
-    seen_points = Auxiliary::FilterPointsInView(points, camera_position, cv::Vec3f(yaw_rad, pitch_rad, roll_rad), cv::Vec3f(fx, cy*2, cx*2));
-
-    for(cv::Point3f  point : seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    return 0;
-}
diff --git a/exe/unused/get_points_from_camera_second.cc b/exe/unused/get_points_from_camera_second.cc
deleted file mode 100644
index dcfc78d..0000000
--- a/exe/unused/get_points_from_camera_second.cc
+++ /dev/null
@@ -1,79 +0,0 @@
-#include <math.h>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    const cv::Point3f camera_position(data["startingCameraPosX"], data["startingCameraPosY"], data["startingCameraPosZ"]);
-
-    // Between -180 to 180, yaw
-    double left_to_right_degree = data["yawDegree"];
-    // Between -180 to 180, pitch
-    double bottom_to_up_degree = data["pitchDegree"];
-    // between -180 to 180, roll
-    double roll_degree = data["rollDegree"];
-
-    double roll_rad = roll_degree * CV_PI / 180.0;
-    double pitch_rad = bottom_to_up_degree * CV_PI / 180.0;
-    double yaw_rad = left_to_right_degree * CV_PI / 180.0;
-
-    float fx = fsSettings["Camera.fx"];
-    float fy = fsSettings["Camera.fy"];
-    float cx = fsSettings["Camera.cx"];
-    float cy = fsSettings["Camera.cy"];
-
-    std::vector<cv::Point3f> points;
-
-    std::fstream pointData;
-    pointData.open(data["getPointDataCsv"], std::ios::in);
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    while (!pointData.eof()) {
-        row.clear();
-        
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-        
-        points.push_back(cv::Point3f(std::stod(row[0]), std::stod(row[1]), std::stod(row[2])));
-    }
-    pointData.close();
-
-    std::vector<cv::Point3f> seen_points;
-
-    seen_points = Auxiliary::FilterPointsInView(points, camera_position, cv::Vec3f(yaw_rad, pitch_rad, roll_rad), cv::Vec3f(fx, cy*2, cx*2));
-
-    for(cv::Point3f  point : seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    return 0;
-}
diff --git a/exe/unused/get_points_from_camera_third.cc b/exe/unused/get_points_from_camera_third.cc
deleted file mode 100644
index 069f8a2..0000000
--- a/exe/unused/get_points_from_camera_third.cc
+++ /dev/null
@@ -1,132 +0,0 @@
-#include <math.h>
-#include <opencv2/core.hpp>
-#include <nlohmann/json.hpp>
-
-#include "include/Auxiliary.h"
-
-cv::Mat createTransformationMatrix(double x, double y, double z, double yaw, double pitch, double roll)
-{
-    // Create rotation matrix from yaw-pitch-roll angles
-    cv::Mat R;
-    cv::Vec3d angles(yaw, pitch, roll);
-    cv::Rodrigues(angles, R);
-
-    // Create translation vector from 3D position
-    cv::Mat t = (cv::Mat_<double>(3,1) << x, y, z);
-
-    // Concatenate rotation matrix and translation vector
-    cv::Mat Rt = cv::Mat::zeros(3, 4, CV_64F);
-    R.copyTo(Rt(cv::Rect(0, 0, 3, 3)));
-    t.copyTo(Rt(cv::Rect(3, 0, 1, 3)));
-
-    // Add fourth row [0 0 0 1] to obtain 4x4 transformation matrix
-    cv::Mat T = cv::Mat::eye(4, 4, CV_64F);
-    Rt.copyTo(T(cv::Rect(0, 0, 4, 3)));
-
-    return T;
-}
-
-bool isPointInFOV(cv::Mat& point3d, const cv::Mat& K, const cv::Mat& T_cw, const cv::Size& imgSize)
-{
-    // Convert 3D point to camera coordinates
-
-    cv::Mat point4d(4, 1, CV_64F);
-    point4d.at<double>(3) = 1.0;
-    point4d.at<double>(0, 0) = point3d.at<double>(0, 0);
-    point4d.at<double>(1, 0) = point3d.at<double>(0, 1);
-    point4d.at<double>(2, 0) = point3d.at<double>(0, 2);
-    cv::Mat pointCam = T_cw.inv() * point4d;
-    
-    // Check that the point is in front of the camera
-    if (pointCam.at<double>(2) < 0.01)
-        return false;
-    
-    // Check that the point is within the image bounds
-    cv::Mat pointImg = K * pointCam.rowRange(0, 3);
-    float u = pointImg.at<double>(0) / pointImg.at<double>(2);
-    float v = pointImg.at<double>(1) / pointImg.at<double>(2);
-    if (u < 0 || u >= imgSize.width || v < 0 || v >= imgSize.height)
-        return false;
-    
-    // Point is within the field of view
-    return true;
-}
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    const cv::Point3d camera_position(data["startingCameraPosX"], data["startingCameraPosY"], data["startingCameraPosZ"]);
-
-    // Between -180 to 180, yaw
-    double yaw = data["yawDegree"];
-    // Between -180 to 180, pitch
-    double pitch = data["pitchDegree"];
-    // between -180 to 180, roll
-    double roll = data["rollDegree"];
-
-    double yaw_rad = yaw * CV_PI / 180.0;
-    double pitch_rad = pitch * CV_PI / 180.0;
-    double roll_rad = roll * CV_PI / 180.0;
-
-    cv::Mat T_cw = createTransformationMatrix(camera_position.x, camera_position.y, camera_position.z, yaw_rad, pitch_rad, roll_rad);
-
-    cv::Mat K = cv::Mat::eye(3, 3, CV_64F);
-    fsSettings["Camera.fx"] >> K.at<double>(0, 0);
-    fsSettings["Camera.fy"] >> K.at<double>(1, 1);
-    fsSettings["Camera.cx"] >> K.at<double>(0, 2);
-    fsSettings["Camera.cy"] >> K.at<double>(1, 2);
-
-    cv::Size image_size(fsSettings["Camera.width"], fsSettings["Camera.height"]);
-
-    std::vector<cv::Point3d> points;
-
-    std::fstream pointData;
-    std::string map_input_dir = data["mapInputDir"];
-    pointData.open(map_input_dir + "cloud1.csv", std::ios::in);
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-
-    while (!pointData.eof()) {
-        row.clear();
-
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-
-        cv::Mat curr_point = (cv::Mat_<double>(1, 3) << std::stod(row[0]), std::stod(row[1]), std::stod(row[2]));
-        if (isPointInFOV(curr_point, K, T_cw, image_size))
-            points.push_back(cv::Point3d(curr_point.at<double>(0), curr_point.at<double>(1), curr_point.at<double>(2)));
-    }
-    pointData.close();
-
-    for(cv::Point3d  point : points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    std::cout << points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/unused/points_seen_by_camera_by_frame.cc b/exe/unused/points_seen_by_camera_by_frame.cc
deleted file mode 100644
index da5dd74..0000000
--- a/exe/unused/points_seen_by_camera_by_frame.cc
+++ /dev/null
@@ -1,106 +0,0 @@
-#include <math.h>
-#include <string>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    float fx = fsSettings["Camera.fx"];
-    float fy = fsSettings["Camera.fy"];
-    float cx = fsSettings["Camera.cx"];
-    float cy = fsSettings["Camera.cy"];
-    float k1 = fsSettings["Camera.k1"];
-    float k2 = fsSettings["Camera.k2"];
-    float k3 = fsSettings["Camera.k3"];
-    float p1 = fsSettings["Camera.p1"];
-    float p2 = fsSettings["Camera.p2"];
-    int width = fsSettings["Camera.width"];
-    int height = fsSettings["Camera.height"];
-
-    std::vector<cv::Point3f> points;
-
-    int frame_to_check = data["frameToCheck"];
-    std::string map_inpur_dir = data["mapInputDir"];
-    std::ifstream pointData;
-    pointData.open(map_inpur_dir + "frameData" + std::to_string(frame_to_check) + ".csv");
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-    
-    std::getline(pointData, line);
-
-    std::stringstream words(line);
-
-    while (std::getline(words, word, ',')) {
-        row.push_back(word);
-    }
-
-    pointData.close();
-    
-    // Extract the camera position
-    float x = stof(row[1]);
-    float y = stof(row[2]);
-    float z = stof(row[3]);
-
-    cv::Point3f camera_position(x, y, z);
-
-    float yaw_rad = stof(row[4]);
-    float pitch_rad = stof(row[5]);
-    float roll_rad = stof(row[6]);
-    
-    // Convert the Euler angles to degrees
-    float yaw_degree = yaw_rad * 180.0 / CV_PI;
-    float pitch_degree = pitch_rad * 180.0 / CV_PI;
-    float roll_degree = roll_rad * 180.0 / CV_PI;
-
-    pointData.open(map_inpur_dir + "cloud1.csv");
-
-    while (!pointData.eof()) {
-        row.clear();
-        
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-        
-        points.push_back(cv::Point3f(std::stod(row[0]), std::stod(row[1]), std::stod(row[2])));
-    }
-    pointData.close();
-
-    std::vector<cv::Point3f> seen_points;
-
-    Auxiliary::getPoints(data["getPointDataCsv"], &seen_points, camera_position, fx, fy, cx, cy, k1, k2, k3, p1, p2, width, height, roll_degree, yaw_degree, pitch_degree);
-
-    for(cv::Point3f  point : seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    std::cout << seen_points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/unused/points_seen_by_camera_by_frame_second.cc b/exe/unused/points_seen_by_camera_by_frame_second.cc
deleted file mode 100644
index b25217f..0000000
--- a/exe/unused/points_seen_by_camera_by_frame_second.cc
+++ /dev/null
@@ -1,97 +0,0 @@
-#include <math.h>
-#include <string>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#include "include/Auxiliary.h"
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    float fx = fsSettings["Camera.fx"];
-    float fy = fsSettings["Camera.fy"];
-    float cx = fsSettings["Camera.cx"];
-    float cy = fsSettings["Camera.cy"];
-
-    std::vector<cv::Point3f> points;
-
-    int frame_to_check = data["frameToCheck"];
-    std::string map_inpur_dir = data["mapInputDir"];
-    std::ifstream pointData;
-    pointData.open(map_inpur_dir + "frameData" + std::to_string(frame_to_check) + ".csv");
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-    
-    std::getline(pointData, line);
-
-    std::stringstream words(line);
-
-    while (std::getline(words, word, ',')) {
-        row.push_back(word);
-    }
-
-    pointData.close();
-    
-    // Extract the camera position
-    double x = stod(row[1]);
-    double y = stod(row[2]);
-    double z = stod(row[3]);
-
-    double yaw_rad = stod(row[4]);
-    double pitch_rad = stod(row[5]);
-    double roll_rad = stod(row[6]);
-    
-    // Convert the Euler angles to degrees
-    double yaw_degree = yaw_rad * 180.0 / CV_PI;
-    double pitch_degree = pitch_rad * 180.0 / CV_PI;
-    double roll_degree = roll_rad * 180.0 / CV_PI;
-
-    pointData.open(map_inpur_dir + "cloud1.csv");
-
-    while (!pointData.eof()) {
-        row.clear();
-        
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-        
-        points.push_back(cv::Point3f(std::stod(row[0]), std::stod(row[1]), std::stod(row[2])));
-    }
-    pointData.close();
-
-    std::vector<cv::Point3f> seen_points;
-
-    seen_points = Auxiliary::FilterPointsInView(points, cv::Point3f(x, y, z), cv::Vec3f(yaw_rad, pitch_rad, roll_rad), cv::Vec3f(fx, cy*2, cx*2));
-
-    for(cv::Point3f  point : seen_points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    std::cout << seen_points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/unused/points_seen_by_camera_by_frame_third.cc b/exe/unused/points_seen_by_camera_by_frame_third.cc
deleted file mode 100644
index fed4c08..0000000
--- a/exe/unused/points_seen_by_camera_by_frame_third.cc
+++ /dev/null
@@ -1,149 +0,0 @@
-#include <math.h>
-#include <string>
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-#include <opencv2/calib3d.hpp>
-
-#include "include/Auxiliary.h"
-
-cv::Mat createTransformationMatrix(double x, double y, double z, double yaw, double pitch, double roll)
-{
-    // Create rotation matrix from yaw-pitch-roll angles
-    cv::Mat R;
-    cv::Vec3d angles(yaw, pitch, roll);
-    cv::Rodrigues(angles, R);
-
-    // Create translation vector from 3D position
-    cv::Mat t = (cv::Mat_<double>(3,1) << x, y, z);
-
-    // Concatenate rotation matrix and translation vector
-    cv::Mat Rt = cv::Mat::zeros(3, 4, CV_64F);
-    R.copyTo(Rt(cv::Rect(0, 0, 3, 3)));
-    t.copyTo(Rt(cv::Rect(3, 0, 1, 3)));
-
-    // Add fourth row [0 0 0 1] to obtain 4x4 transformation matrix
-    cv::Mat T = cv::Mat::eye(4, 4, CV_64F);
-    Rt.copyTo(T(cv::Rect(0, 0, 4, 3)));
-
-    return T;
-}
-
-bool isPointInFOV(cv::Mat& point3d, const cv::Mat& K, const cv::Mat& T_cw, const cv::Size& imgSize)
-{
-    // Convert 3D point to camera coordinates
-
-    cv::Mat point4d(4, 1, CV_64F);
-    point4d.at<double>(3) = 1.0;
-    point4d.at<double>(0, 0) = point3d.at<double>(0, 0);
-    point4d.at<double>(1, 0) = point3d.at<double>(0, 1);
-    point4d.at<double>(2, 0) = point3d.at<double>(0, 2);
-    cv::Mat pointCam = T_cw.inv() * point4d;
-    
-    // Check that the point is in front of the camera
-    if (pointCam.at<double>(2) < 0.01)
-        return false;
-    
-    // Check that the point is within the image bounds
-    cv::Mat pointImg = K * pointCam.rowRange(0, 3);
-    float u = pointImg.at<double>(0) / pointImg.at<double>(2);
-    float v = pointImg.at<double>(1) / pointImg.at<double>(2);
-    if (u < 0 || u >= imgSize.width || v < 0 || v >= imgSize.height)
-        return false;
-    
-    // Point is within the field of view
-    return true;
-}
-
-int main()
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    cv::Mat K = cv::Mat::eye(3, 3, CV_64F);
-    fsSettings["Camera.fx"] >> K.at<double>(0, 0);
-    fsSettings["Camera.fy"] >> K.at<double>(1, 1);
-    fsSettings["Camera.cx"] >> K.at<double>(0, 2);
-    fsSettings["Camera.cy"] >> K.at<double>(1, 2);
-    // K.at<double>(2, 2) = 1.0;
-
-    cv::Size image_size(fsSettings["Camera.width"], fsSettings["Camera.height"]);
-
-    std::vector<cv::Point3f> points;
-
-    int frame_to_check = data["frameToCheck"];
-    std::string map_inpur_dir = data["mapInputDir"];
-    std::ifstream pointData;
-    pointData.open(map_inpur_dir + "frameData" + std::to_string(frame_to_check) + ".csv");
-
-    std::vector<std::string> row;
-    std::string line, word, temp;
-    
-    std::getline(pointData, line);
-
-    std::stringstream words(line);
-
-    while (std::getline(words, word, ',')) {
-        row.push_back(word);
-    }
-
-    pointData.close();
-
-    // Extract the camera position
-    double x = stod(row[1]);
-    double y = stod(row[2]);
-    double z = stod(row[3]);
-
-    double yaw_rad = stod(row[4]);
-    double pitch_rad = stod(row[5]);
-    double roll_rad = stod(row[6]);
-    
-    // Convert the Euler angles to degrees
-    double yaw_degree = yaw_rad * 180.0 / CV_PI;
-    double pitch_degree = pitch_rad * 180.0 / CV_PI;
-    double roll_degree = roll_rad * 180.0 / CV_PI;
-
-    cv::Mat T_cw = createTransformationMatrix(x, y, z, yaw_rad, pitch_rad, roll_rad);
-
-    pointData.open(map_inpur_dir + "cloud1.csv");
-
-    while (!pointData.eof()) {
-        row.clear();
-        
-        std::getline(pointData, line);
-
-        std::stringstream words(line);
-
-        if (line == "") {
-            continue;
-        }
-
-        while (std::getline(words, word, ',')) {
-            row.push_back(word);
-        }
-        
-        cv::Mat curr_point = (cv::Mat_<double>(1, 3) << std::stod(row[0]), std::stod(row[1]), std::stod(row[2]));
-        if (isPointInFOV(curr_point, K, T_cw, image_size))
-            points.push_back(cv::Point3d(curr_point.at<double>(0), curr_point.at<double>(1), curr_point.at<double>(2)));
-    }
-    pointData.close();
-
-    for(cv::Point3f  point : points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    std::cout << points.size() << std::endl;
-
-    return 0;
-}
diff --git a/exe/unused/test_is_point_visible.cc b/exe/unused/test_is_point_visible.cc
deleted file mode 100644
index bbe2dfa..0000000
--- a/exe/unused/test_is_point_visible.cc
+++ /dev/null
@@ -1,87 +0,0 @@
-#include <nlohmann/json.hpp>
-#include <opencv2/opencv.hpp>
-#include <iostream>
-#include <string>
-#include <sstream>
-
-#include "Python.h"
-
-#include "include/Auxiliary.h"
-
-int main(void)
-{
-    std::string settingPath = Auxiliary::GetGeneralSettingsPath();
-    std::ifstream programData(settingPath);
-    nlohmann::json data;
-    programData >> data;
-    programData.close();
-
-    // Check settings file
-    cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
-    {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
-    }
-
-    const cv::Point3f camera_position(data["startingCameraPosX"], data["startingCameraPosY"], data["startingCameraPosZ"]);
-
-    // Between -180 to 180, yaw
-    double left_to_right_degree = data["yawDegree"];
-    // Between -180 to 180, pitch
-    double bottom_to_up_degree = data["pitchDegree"];
-    // between -180 to 180, roll
-    double roll_degree = data["rollDegree"];
-
-    float fx = fsSettings["Camera.fx"];
-    float fy = fsSettings["Camera.fy"];
-    float cx = fsSettings["Camera.cx"];
-    float cy = fsSettings["Camera.cy"];
-    float k1 = fsSettings["Camera.k1"];
-    float k2 = fsSettings["Camera.k2"];
-    float k3 = fsSettings["Camera.k3"];
-    float p1 = fsSettings["Camera.p1"];
-    float p2 = fsSettings["Camera.p2"];
-    int width = fsSettings["Camera.width"];
-    int height = fsSettings["Camera.height"];
-
-    std::vector<cv::Point3f> points;
-    Auxiliary::getPoints(data["getPointDataCsv"], &points, camera_position, fx, fy, cx, cy, k1, k2, k3, p1, p2, width, height, roll_degree, left_to_right_degree, bottom_to_up_degree);
-
-    for(cv::Point3f  point : points)
-    {
-        std::cout << "(" << point.x << ", " << point.y << ", " << point.z << ")" << std::endl;
-    }
-
-    std::stringstream command, command2;
-    Py_Initialize();
-    command << "ax.scatter([";
-    for(cv::Point3f  point : points)
-    {
-        command << point.x << ", ";
-    }
-    command << "0.0], [";
-    for(cv::Point3f  point : points)
-    {
-        command << point.y << ", ";
-    }
-    command << "0.0], [";
-    for(cv::Point3f  point : points)
-    {
-        command << point.z << ", ";
-    }
-    command << "0.0], c='r', marker='o')";
-
-    command2 << "ax.scatter(" << camera_position.x << ", " << camera_position.y << ", " << camera_position.z << ", c='b', marker='o')";
-    PyRun_SimpleString("import matplotlib.pyplot as plt");
-    PyRun_SimpleString("fig = plt.figure()");
-    PyRun_SimpleString("ax = fig.add_subplot(111, projection='3d')");
-    PyRun_SimpleString(command.str().c_str());
-    PyRun_SimpleString("ax.scatter(0, 0, 0, c='g', marker='o')");
-    PyRun_SimpleString(command2.str().c_str());
-    PyRun_SimpleString("ax.set_xlabel('X Label')");
-    PyRun_SimpleString("ax.set_xlabel('Y Label')");
-    PyRun_SimpleString("ax.set_xlabel('Z Label')");
-    PyRun_SimpleString("plt.show()");
-    Py_Exit(0);
-    return 0;}
diff --git a/generalSettings.json b/generalSettings.json
index b724206..3a84c29 100644
--- a/generalSettings.json
+++ b/generalSettings.json
@@ -1,12 +1,12 @@
 {
-  "VocabularyPath": "/home/tzuk/simulatorMapping/Vocabulary/ORBvoc.txt",
-  "DroneYamlPathSlam": "/home/tzuk/simulatorMapping/config/tello_9F5EC2_640.yaml",
-  "offlineVideoTestPath": "/home/tzuk/Downloads/mapping.avi",
+  "VocabularyPath": "C:\\Users\\tzuk9\\Documents\\simulatorMapping\\Vocabulary\\ORBvoc.bin",
+  "DroneYamlPathSlam": "C:\\Users\\tzuk9\\Documents\\simulatorMapping\\config\\tello_9F5EC2_640.yaml",
+  "offlineVideoTestPath": "C:\\Users\\tzuk9\\Documents\\simulatorMapping\\videos\\mapping.avi",
   "onlineVideoPath": "udp://0.0.0.0:11111?overrun_nonfatal=1&fifo_size=1000",
   "loadMap": false,
   "loadMapPath": "/home/tzuk/slamMaps/HaifaLab.bin",
   "saveMap": true,
-  "simulatorOutputDir": "/home/tzuk/slamMaps/",
+  "simulatorOutputDir": "C:\\Users\\tzuk9\\Documents\\simulatorMapping\\slamMaps\\",
   "modelTextureNameToAlignTo": "floor",
   "mapInputDir": "/home/tzuk/slamMaps/example_mapping11/",
   "getPointDataCsv": "/home/liam/example.csv",
@@ -25,7 +25,7 @@
   "rollRad": 2.87,
   "movingScale": 0.2,
   "rotateScale": 0.2,
-  "modelPath": "/home/tzuk/Documents/TLV_lab/FBX/drones_lab.obj",
+  "modelPath": "C:\\Users\\tzuk9\\Documents\\simulatorMapping\\TLV-data\\drones_lab.obj",
   "pointSize": 10,
   "xOffset": 0.0696954,
   "yOffset": 0.232057,
@@ -34,11 +34,11 @@
   "pitchOffset": -0.35643,
   "rollOffset": -0.0139628,
   "scaleFactor": 0.0305,
-  "movementFactor": 0.01,
+  "movementFactor": 0.1,
   "framesFolder": "/home/liam/Documents/textures/",
   "framesOutput": "/home/liam/Downloads/frames/",
   "frameNumber": 99,
   "useLabICP": true,
-  "trackImages": false
+  "trackImages": true
 }
 
diff --git a/install.sh b/install.sh
index f70c184..847505f 100755
--- a/install.sh
+++ b/install.sh
@@ -56,13 +56,6 @@ cd build
 cmake ..
 sudo make -j$(nproc) install
 cd ~
-git clone https://github.com/tzukpolinsky/ctello.git
-cd ctello
-mkdir build
-cd build
-cmake ..
-sudo make -j$(nproc) install
-cd ~
 git clone https://gitlab.com/libeigen/eigen.git
 cd eigen
 git checkout 3.4.0
diff --git a/installWithVcpkg.bat b/installWithVcpkg.bat
new file mode 100644
index 0000000..59293be
--- /dev/null
+++ b/installWithVcpkg.bat
@@ -0,0 +1,23 @@
+$simulatorMappingDir = Get-Location
+cd ~
+git clone https://github.com/microsoft/vcpkg
+.\vcpkg\bootstrap-vcpkg.bat
+.\vcpkg\vcpkg install cmake --triplet=x64-windows
+cd "$simulatorMappingDir\ThirdParty\"
+rm Pangolin
+git clone https://github.com/tzukpolinsky/Pangolin.git
+cd Pangolin
+mkdir build
+cd build
+cmake ..  -DCMAKE_TOOLCHAIN_FILE=~\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake
+cmake --build . --target ALL_BUILD
+cd ~
+.\vcpkg\vcpkg install opencv3 --triplet=x64-windows
+cd "$simulatorMappingDir\ThirdParty\DBoW2"
+mkdir build
+cd build
+cmake ..  -DCMAKE_TOOLCHAIN_FILE=~\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake
+cmake --build . --target ALL_BUILD
+
+
+
diff --git a/slam/include/Converter.h b/slam/include/Converter.h
index 5181369..a948e3f 100644
--- a/slam/include/Converter.h
+++ b/slam/include/Converter.h
@@ -23,9 +23,9 @@
 
 #include<opencv2/core/core.hpp>
 
-#include<eigen3/Eigen/Dense>
-#include"../Thirdparty/g2o/g2o/types/types_six_dof_expmap.h"
-#include"../Thirdparty/g2o/g2o/types/types_seven_dof_expmap.h"
+#include<Eigen/Dense>
+#include"g2o/types/types_six_dof_expmap.h"
+#include"g2o/types/types_seven_dof_expmap.h"
 
 namespace ORB_SLAM2
 {
diff --git a/slam/include/Frame.h b/slam/include/Frame.h
index ee9999d..ff9c7ca 100644
--- a/slam/include/Frame.h
+++ b/slam/include/Frame.h
@@ -24,8 +24,8 @@
 #include<vector>
 
 #include "MapPoint.h"
-#include "../Thirdparty/DBoW2/DBoW2/BowVector.h"
-#include "../Thirdparty/DBoW2/DBoW2/FeatureVector.h"
+#include "DBoW2/BowVector.h"
+#include "DBoW2/FeatureVector.h"
 #include "ORBVocabulary.h"
 #include "KeyFrame.h"
 #include "ORBextractor.h"
diff --git a/slam/include/KeyFrame.h b/slam/include/KeyFrame.h
index eab2f08..9183f81 100644
--- a/slam/include/KeyFrame.h
+++ b/slam/include/KeyFrame.h
@@ -23,8 +23,8 @@
 #include <iostream>
 using namespace std;
 #include "MapPoint.h"
-#include "../Thirdparty/DBoW2/DBoW2/BowVector.h"
-#include "../Thirdparty/DBoW2/DBoW2/FeatureVector.h"
+#include "DBoW2/BowVector.h"
+#include "DBoW2/FeatureVector.h"
 #include "ORBVocabulary.h"
 #include "ORBextractor.h"
 #include "Frame.h"
@@ -41,7 +41,7 @@ using namespace std;
 #include <boost/serialization/split_member.hpp>
 #include <mutex>
 
-#include <eigen3/Eigen/Core>
+#include <Eigen/Core>
 
 // #define _BAR
 
diff --git a/slam/include/LoopClosing.h b/slam/include/LoopClosing.h
index 558fd14..544533b 100644
--- a/slam/include/LoopClosing.h
+++ b/slam/include/LoopClosing.h
@@ -31,7 +31,7 @@
 
 #include <thread>
 #include <mutex>
-#include "../Thirdparty/g2o/g2o/types/types_seven_dof_expmap.h"
+#include "g2o/types/types_seven_dof_expmap.h"
 
 namespace ORB_SLAM2
 {
diff --git a/slam/include/ORBVocabulary.h b/slam/include/ORBVocabulary.h
index 69ba6d3..d7ac2e0 100644
--- a/slam/include/ORBVocabulary.h
+++ b/slam/include/ORBVocabulary.h
@@ -22,8 +22,8 @@
 #ifndef ORBVOCABULARY_H
 #define ORBVOCABULARY_H
 
-#include"../Thirdparty/DBoW2/DBoW2/FORB.h"
-#include"../Thirdparty/DBoW2/DBoW2/TemplatedVocabulary.h"
+#include"DBoW2/FORB.h"
+#include"DBoW2/TemplatedVocabulary.h"
 
 namespace ORB_SLAM2
 {
diff --git a/slam/include/ORBextractor.h b/slam/include/ORBextractor.h
index 66e8e7a..8d751a8 100644
--- a/slam/include/ORBextractor.h
+++ b/slam/include/ORBextractor.h
@@ -1,116 +1,124 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #ifndef ORBEXTRACTOR_H
 #define ORBEXTRACTOR_H
 
 #include <vector>
 #include <list>
-#include <opencv/cv.h>
-
+#include <opencv2/opencv.hpp>
 
 namespace ORB_SLAM2
 {
 
-class ExtractorNode
-{
-public:
-    ExtractorNode():bNoMore(false){}
-
-    void DivideNode(ExtractorNode &n1, ExtractorNode &n2, ExtractorNode &n3, ExtractorNode &n4);
-
-    std::vector<cv::KeyPoint> vKeys;
-    cv::Point2i UL, UR, BL, BR;
-    std::list<ExtractorNode>::iterator lit;
-    bool bNoMore;
-};
-
-class ORBextractor
-{
-public:
-    
-    enum {HARRIS_SCORE=0, FAST_SCORE=1 };
-
-    ORBextractor(int nfeatures, float scaleFactor, int nlevels,
-                 int iniThFAST, int minThFAST);
-
-    ~ORBextractor(){}
-
-    // Compute the ORB features and descriptors on an image.
-    // ORB are dispersed on the image using an octree.
-    // Mask is ignored in the current implementation.
-    void operator()( cv::InputArray image, cv::InputArray mask,
-      std::vector<cv::KeyPoint>& keypoints,
-      cv::OutputArray descriptors);
-
-    int inline GetLevels(){
-        return nlevels;}
-
-    float inline GetScaleFactor(){
-        return scaleFactor;}
-
-    std::vector<float> inline GetScaleFactors(){
-        return mvScaleFactor;
-    }
-
-    std::vector<float> inline GetInverseScaleFactors(){
-        return mvInvScaleFactor;
-    }
-
-    std::vector<float> inline GetScaleSigmaSquares(){
-        return mvLevelSigma2;
-    }
-
-    std::vector<float> inline GetInverseScaleSigmaSquares(){
-        return mvInvLevelSigma2;
-    }
-
-    std::vector<cv::Mat> mvImagePyramid;
-
-protected:
-
-    void ComputePyramid(cv::Mat image);
-    void ComputeKeyPointsOctTree(std::vector<std::vector<cv::KeyPoint> >& allKeypoints);    
-    std::vector<cv::KeyPoint> DistributeOctTree(const std::vector<cv::KeyPoint>& vToDistributeKeys, const int &minX,
-                                           const int &maxX, const int &minY, const int &maxY, const int &nFeatures, const int &level);
-
-    void ComputeKeyPointsOld(std::vector<std::vector<cv::KeyPoint> >& allKeypoints);
-    std::vector<cv::Point> pattern;
-
-    int nfeatures;
-    double scaleFactor;
-    int nlevels;
-    int iniThFAST;
-    int minThFAST;
-
-    std::vector<int> mnFeaturesPerLevel;
-
-    std::vector<int> umax;
-
-    std::vector<float> mvScaleFactor;
-    std::vector<float> mvInvScaleFactor;    
-    std::vector<float> mvLevelSigma2;
-    std::vector<float> mvInvLevelSigma2;
-};
-
-} //namespace ORB_SLAM
+    class ExtractorNode
+    {
+    public:
+        ExtractorNode() : bNoMore(false) {}
+
+        void DivideNode(ExtractorNode &n1, ExtractorNode &n2, ExtractorNode &n3, ExtractorNode &n4);
+
+        std::vector<cv::KeyPoint> vKeys;
+        cv::Point2i UL, UR, BL, BR;
+        std::list<ExtractorNode>::iterator lit;
+        bool bNoMore;
+    };
+
+    class ORBextractor
+    {
+    public:
+        enum
+        {
+            HARRIS_SCORE = 0,
+            FAST_SCORE = 1
+        };
+
+        ORBextractor(int nfeatures, float scaleFactor, int nlevels,
+                     int iniThFAST, int minThFAST);
+
+        ~ORBextractor() {}
+
+        // Compute the ORB features and descriptors on an image.
+        // ORB are dispersed on the image using an octree.
+        // Mask is ignored in the current implementation.
+        void operator()(cv::InputArray image, cv::InputArray mask,
+                        std::vector<cv::KeyPoint> &keypoints,
+                        cv::OutputArray descriptors);
+
+        int inline GetLevels()
+        {
+            return nlevels;
+        }
+
+        float inline GetScaleFactor()
+        {
+            return scaleFactor;
+        }
+
+        std::vector<float> inline GetScaleFactors()
+        {
+            return mvScaleFactor;
+        }
+
+        std::vector<float> inline GetInverseScaleFactors()
+        {
+            return mvInvScaleFactor;
+        }
+
+        std::vector<float> inline GetScaleSigmaSquares()
+        {
+            return mvLevelSigma2;
+        }
+
+        std::vector<float> inline GetInverseScaleSigmaSquares()
+        {
+            return mvInvLevelSigma2;
+        }
+
+        std::vector<cv::Mat> mvImagePyramid;
+
+    protected:
+        void ComputePyramid(cv::Mat image);
+        void ComputeKeyPointsOctTree(std::vector<std::vector<cv::KeyPoint>> &allKeypoints);
+        std::vector<cv::KeyPoint> DistributeOctTree(const std::vector<cv::KeyPoint> &vToDistributeKeys, const int &minX,
+                                                    const int &maxX, const int &minY, const int &maxY, const int &nFeatures, const int &level);
+
+        void ComputeKeyPointsOld(std::vector<std::vector<cv::KeyPoint>> &allKeypoints);
+        std::vector<cv::Point> pattern;
+
+        int nfeatures;
+        double scaleFactor;
+        int nlevels;
+        int iniThFAST;
+        int minThFAST;
+
+        std::vector<int> mnFeaturesPerLevel;
+
+        std::vector<int> umax;
+
+        std::vector<float> mvScaleFactor;
+        std::vector<float> mvInvScaleFactor;
+        std::vector<float> mvLevelSigma2;
+        std::vector<float> mvInvLevelSigma2;
+    };
+
+} // namespace ORB_SLAM
 
 #endif
-
diff --git a/slam/include/Optimizer.h b/slam/include/Optimizer.h
index 71cd8e4..fa075b1 100644
--- a/slam/include/Optimizer.h
+++ b/slam/include/Optimizer.h
@@ -27,7 +27,7 @@
 #include "LoopClosing.h"
 #include "Frame.h"
 
-#include "../Thirdparty/g2o/g2o/types/types_seven_dof_expmap.h"
+#include "g2o/types/types_seven_dof_expmap.h"
 
 namespace ORB_SLAM2
 {
diff --git a/slam/include/RaspberryKeyFrame.h b/slam/include/RaspberryKeyFrame.h
deleted file mode 100644
index 8587ca1..0000000
--- a/slam/include/RaspberryKeyFrame.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef RASPBERRY_KEYFRAME_H
-#define RASPBERRY_KEYFRAME_H
-#include <iostream>
-using namespace std;
-#include "MapPoint.h"
-#include "../Thirdparty/DBoW2/DBoW2/BowVector.h"
-#include "../Thirdparty/DBoW2/DBoW2/FeatureVector.h"
-#include "ORBVocabulary.h"
-#include "ORBextractor.h"
-#include "Frame.h"
-#include "KeyFrameDatabase.h"
-#include "Converter.h"
-#include "KeyFrame.h"
-#include "Serialization.h"
-
-#include <boost/serialization/serialization.hpp>
-#include <boost/serialization/list.hpp>
-#include <boost/serialization/vector.hpp>
-
-#include <boost/serialization/split_member.hpp>
-#include <mutex>
-
-#include <eigen3/Eigen/Core>
-
-// #define _BAR_
-
-namespace ORB_SLAM2
-{
-    // struct id_map
-    // {
-    // 	bool is_valid;
-    // 	long unsigned int id;
-    // };
-    // class Map;
-    // class MapPoint;
-    // class Frame;
-    // class KeyFrameDatabase;
-    // struct id_map;
-
-    // class CameraMatrix{
-    //     public:
-    //         CameraMatrix()
-    //         {
-
-    //         }
-
-    //         CameraMatrix(cv::Mat mtx):fx_(mtx.at<float>(0, 0)), fy_(mtx.at<float>(1, 1)), cx_(mtx.at<float>(0, 2)), cy_(mtx.at<float>(1, 2))
-    //         {
-    // 	        invfx_ = 1/fx_;
-    // 	        invfy_ = 1/fy_;
-    //         }
-
-    //         float fx_;
-    //         float fy_;
-    //         float cx_;
-    //         float cy_;
-    //         float invfx_;
-    //         float invfy_;
-
-    //     private:
-    //         friend class boost::serialization::access;
-    //         // When the class Archive corresponds to an output archive, the
-    //         // & operator is defined similar to <<.  Likewise, when the class Archive
-    //         // is a type of input archive the & operator is defined similar to >>.
-    //         template<class Archive>
-    //         void serialize(Archive & ar, const unsigned int version)
-    //         {
-    //             ar & fx_;
-    //             ar & fy_;
-    //             ar & cx_;
-    //             ar & cy_;
-    //             ar & invfx_;
-    //             ar & invfy_;
-    //         }
-    // };
-
-    class KeyFrame;
-
-    class RaspberryKeyFrame
-    {
-    public:
-        RaspberryKeyFrame(KeyFrame &kf);
-
-        // The following variables are accesed from only 1 thread or never change (no mutex needed).
-    public:
-        cv::Mat image;
-
-        // static long unsigned int nNextId;
-        // long unsigned int mnId;
-        // const long unsigned int mnFrameId;
-
-        // const double mTimeStamp;
-
-        // // Grid (to speed up feature matching)
-        // const int mnGridCols;
-        // const int mnGridRows;
-        // const float mfGridElementWidthInv;
-        // const float mfGridElementHeightInv;
-
-        // // Variables used by the tracking
-        // long unsigned int mnTrackReferenceForFrame;
-        // long unsigned int mnFuseTargetForKF;
-
-        // // Variables used by the local mapping
-        // long unsigned int mnBALocalForKF;
-        // long unsigned int mnBAFixedForKF;
-
-        // // Variables used by the keyframe database
-        // long unsigned int mnLoopQuery;
-        // int mnLoopWords;
-        // float mLoopScore;
-        // long unsigned int mnRelocQuery;
-        // int mnRelocWords;
-        // float mRelocScore;
-
-        // // Variables used by loop closing
-        // cv::Mat mTcwGBA;
-        // cv::Mat mTcwBefGBA;
-        // long unsigned int mnBAGlobalForKF;
-
-        // Calibration parameters
-        const float fx, fy, cx, cy, invfx, invfy; //, mbf, mb, mThDepth;
-
-        // // Number of KeyPoints
-        // const int N;
-
-        // KeyPoints, stereo coordinate and descriptors (all associated by an index)
-        const std::vector<cv::KeyPoint> mvKeys;
-        const std::vector<cv::KeyPoint> mvKeysUn;
-        // const std::vector<float> mvuRight; // negative value for monocular points
-        // const std::vector<float> mvDepth; // negative value for monocular points
-        cv::Mat mDescriptors;
-
-        //BoW
-        // DBoW2::BowVector mBowVec;
-        // DBoW2::FeatureVector mFeatVec;
-
-        // // Pose relative to parent (this is computed when bad flag is activated)
-        // cv::Mat mTcp;
-
-        // Scale
-        // const int mnScaleLevels;
-        // const float mfScaleFactor;
-        // const float mfLogScaleFactor;
-        // const std::vector<float> mvScaleFactors;
-        // const std::vector<float> mvLevelSigma2;
-        // const std::vector<float> mvInvLevelSigma2;
-
-        // // Image bounds and calibration
-        // const int mnMinX;
-        // const int mnMinY;
-        // const int mnMaxX;
-        // const int mnMaxY;
-        // const cv::Mat mK;
-
-        // The following variables need to be accessed trough a mutex to be thread safe.
-    protected:
-        // SE3 Pose and camera center
-        cv::Mat Tcw;
-        // cv::Mat Twc;
-        // cv::Mat Ow;
-
-        // cv::Mat Cw; // Stereo middel point. Only for visualization
-
-        // MapPoints associated to keypoints
-        std::vector<MapPoint *> mvpMapPoints;
-        // std::map<long unsigned int, id_map> 	   mmMapPoints_nId;
-
-        // BoW
-        // KeyFrameDatabase* mpKeyFrameDB;
-        // ORBVocabulary* mpORBvocabulary;
-
-        // Grid over the image to speed up feature matching
-        // std::vector< std::vector <std::vector<size_t> > > mGrid;
-
-        // std::map<KeyFrame*,int> mConnectedKeyFrameWeights;
-        // 	std::map<long unsigned int, int> 	   mConnectedKeyFrameWeights_nId;
-        // std::vector<KeyFrame*> mvpOrderedConnectedKeyFrames;
-        // 	std::map<long unsigned int, id_map> 	mvpOrderedConnectedKeyFrames_nId;
-        // std::vector<int> mvOrderedWeights;
-
-        // Spanning Tree and Loop Edges
-        // bool mbFirstConnection;
-
-        // KeyFrame* mpParent;
-        // 	id_map mparent_KfId_map;
-        // std::set<KeyFrame*> mspChildrens;
-        // 	std::map<long unsigned int, id_map> 	   mmChildrens_nId;
-        // std::set<KeyFrame*> mspLoopEdges;
-        // 	std::map<long unsigned int, id_map> 	   mmLoopEdges_nId;
-
-        // Bad flags
-        // bool mbNotErase;
-        // bool mbToBeErased;
-        // bool mbBad;
-
-        // float mHalfBaseline; // Only for visualization
-
-        // Map* mpMap;
-        // #ifndef _BAR_
-        // 	friend class boost::serialization::access;
-        //  	template<class Archive>
-        //     void serialize(Archive & ar, const unsigned int version)
-        // 	{
-        // 		boost::serialization::split_member(ar, *this, version);
-        // 	}
-
-        // 	template<class Archive>
-        // 	void save(Archive & ar, const unsigned int version) const;
-
-        // 	template<class Archive>
-        // 	void load(Archive & ar, const unsigned int version);
-        // #endif
-
-        // std::mutex mMutexPose;
-        // std::mutex mMutexConnections;
-        // std::mutex mMutexFeatures;
-
-    public:
-        //   void rpi_save(const std::string& file_name){
-        //     std::ofstream bin_file(file_name, std::ios::out | std::ios::binary);
-
-        //     boost::archive::binary_oarchive oa(bin_file);
-
-        //     oa << *this;
-
-        //     bin_file.close();
-
-        //   }
-
-    private:
-        friend class boost::serialization::access;
-
-        template <class Archive>
-        void save(Archive &ar, const unsigned int version) const
-        {
-            std::vector<cv::Point2f> kpnts;
-            std::vector<cv::Point2f> kpnts_undist;
-            std::vector<int> kpnts_octave;
-            std::vector<cv::Point3f> list_points3d;
-
-            uint nKeyPoints = this->mvKeys.size();
-            kpnts.reserve(nKeyPoints);
-            kpnts_undist.reserve(nKeyPoints);
-            kpnts_octave.reserve(nKeyPoints);
-            for (uint i = 0; i < nKeyPoints; i++)
-            {
-                kpnts.push_back(this->mvKeys[i].pt);
-                kpnts_undist.push_back(this->mvKeysUn[i].pt);
-                kpnts_octave.push_back(this->mvKeysUn[i].octave);
-            }
-
-            uint nDescs = this->mDescriptors.rows;
-            list_points3d.reserve(nDescs);
-            for (uint i = 0; i < nDescs; i++)
-            {
-                MapPoint *p = this->mvpMapPoints[i];
-                if (p && !p->isBad())
-                {
-                    auto point = p->GetWorldPos();
-                    Eigen::Matrix<double, 3, 1> v = ORB_SLAM2::Converter::toVector3d(point);
-                    list_points3d.emplace_back(v.x(), v.y(), v.z());
-                }
-                else
-                {
-                    list_points3d.emplace_back(0, 0, 0);
-                }
-            }
-
-            cv::Mat R = this->Tcw.rowRange(0, 3).colRange(0, 3);
-            cv::Mat t = this->Tcw.rowRange(0, 3).col(3);
-
-            R.convertTo(R, CV_32F);
-            t.convertTo(t, CV_32F);
-
-            // ar & this->image;
-            std::cout << "Descriptors: " << mDescriptors << std::endl;
-            ar &this->mDescriptors.clone();
-            ar &kpnts;
-            ar &kpnts_undist;
-            ar &const_cast<std::vector<int> &>(kpnts_octave);
-            ar &list_points3d;
-            ar &R;
-            ar &t;
-            ar &this->fx;
-            ar &this->fy;
-            ar &this->cx;
-            ar &this->cy;
-            ar &this->invfx;
-            ar &this->invfy;
-        }
-
-        template <class Archive>
-        void load(Archive &ar, const unsigned int version)
-        {
-        }
-
-        BOOST_SERIALIZATION_SPLIT_MEMBER()
-    };
-
-} //namespace ORB_SLAM
-
-#endif // KEYFRAME_H
diff --git a/slam/include/System.h b/slam/include/System.h
index 0ba90ce..626b853 100644
--- a/slam/include/System.h
+++ b/slam/include/System.h
@@ -1,31 +1,31 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
-
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #ifndef SYSTEM_H
 #define SYSTEM_H
 
-#include<string>
-#include<thread>
-#include<opencv2/core/core.hpp>
-#include<unistd.h>
+#include <string>
+#include <thread>
+#include <opencv2/core/core.hpp>
+#define NOMINMAX
+#include <windows.h>
 
 #include <boost/serialization/serialization.hpp>
 #include <boost/archive/binary_oarchive.hpp>
@@ -42,8 +42,8 @@
 #include "KeyFrameDatabase.h"
 #include "ORBVocabulary.h"
 #include "Viewer.h"
-
-namespace ORB_SLAM2 {
+namespace ORB_SLAM2
+{
 
     class Viewer;
 
@@ -57,17 +57,18 @@ namespace ORB_SLAM2 {
 
     class LoopClosing;
 
-    class System {
+    class System
+    {
     public:
         // Input sensor
-        enum eSensor {
+        enum eSensor
+        {
             MONOCULAR = 0,
             STEREO = 1,
             RGBD = 2
         };
 
     public:
-
         bool shutdown_requested = false;
 
         // Enable serialization
@@ -77,11 +78,9 @@ namespace ORB_SLAM2 {
         System(const string &strVocFile, const string &strSettingsFile, const eSensor sensor,
                const bool bUseViewer = true,
                const bool bUseFrameDrawer = true,
-               bool reuse = false, std::string
-               mapName = "Slam_latest_Map.bin",
+               bool reuse = false, std::string mapName = "Slam_latest_Map.bin",
                bool continue_mapping = false,
-               bool isPangolinExists = false
-        );
+               bool isPangolinExists = false);
 
         // Proccess the given stereo frame. Images must be synchronized and rectified.
         // Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.
@@ -113,15 +112,18 @@ namespace ORB_SLAM2 {
 
         Map *GetMap();
 
-        inline MapDrawer *GetMapDrawer() {
+        inline MapDrawer *GetMapDrawer()
+        {
             return mpMapDrawer;
         }
 
-        inline LocalMapping *GetLocalMapping() {
+        inline LocalMapping *GetLocalMapping()
+        {
             return mpLocalMapper;
         }
 
-        inline LoopClosing *GetLoopClosing() {
+        inline LoopClosing *GetLoopClosing()
+        {
             return mpLoopCloser;
         }
 
@@ -139,7 +141,7 @@ namespace ORB_SLAM2 {
 
         // Get map with tracked frames and points.
         // Call first Shutdown()
-        //Map *GetMap();
+        // Map *GetMap();
 
         // Save camera trajectory in the TUM RGB-D dataset format.
         // Call first Shutdown()
@@ -162,7 +164,6 @@ namespace ORB_SLAM2 {
         // LoadMap(const string &filename);
 
     private:
-
         // Input sensor
         eSensor mSensor;
 
@@ -209,6 +210,6 @@ namespace ORB_SLAM2 {
         bool mbDeactivateLocalizationMode;
     };
 
-}// namespace ORB_SLAM
+} // namespace ORB_SLAM
 
 #endif // SYSTEM_H
diff --git a/slam/src/Frame.cc b/slam/src/Frame.cc
index 30a5e33..c68b6d1 100644
--- a/slam/src/Frame.cc
+++ b/slam/src/Frame.cc
@@ -281,7 +281,7 @@ namespace ORB_SLAM2 {
         }
 
         mb = mbf / fx;
-
+        std::cout << "AssignFeaturesToGrid" <<std::endl;
         AssignFeaturesToGrid();
     }
 
@@ -397,19 +397,19 @@ namespace ORB_SLAM2 {
         vector<size_t> vIndices;
         vIndices.reserve(N);
 
-        const int nMinCellX = max(0, (int) floor((x - mnMinX - r) * mfGridElementWidthInv));
+        const int nMinCellX = std::max(0, (int) std::floor((x - mnMinX - r) * mfGridElementWidthInv));
         if (nMinCellX >= FRAME_GRID_COLS)
             return vIndices;
 
-        const int nMaxCellX = min((int) FRAME_GRID_COLS - 1, (int) ceil((x - mnMinX + r) * mfGridElementWidthInv));
+        const int nMaxCellX = std::min((int) FRAME_GRID_COLS - 1, (int) std::ceil((x - mnMinX + r) * mfGridElementWidthInv));
         if (nMaxCellX < 0)
             return vIndices;
 
-        const int nMinCellY = max(0, (int) floor((y - mnMinY - r) * mfGridElementHeightInv));
+        const int nMinCellY = std::max(0, (int) std::floor((y - mnMinY - r) * mfGridElementHeightInv));
         if (nMinCellY >= FRAME_GRID_ROWS)
             return vIndices;
 
-        const int nMaxCellY = min((int) FRAME_GRID_ROWS - 1, (int) ceil((y - mnMinY + r) * mfGridElementHeightInv));
+        const int nMaxCellY = std::min((int) FRAME_GRID_ROWS - 1, (int) std::ceil((y - mnMinY + r) * mfGridElementHeightInv));
         if (nMaxCellY < 0)
             return vIndices;
 
diff --git a/slam/src/FrameDrawer.cc b/slam/src/FrameDrawer.cc
index a316548..17d35e5 100644
--- a/slam/src/FrameDrawer.cc
+++ b/slam/src/FrameDrawer.cc
@@ -66,7 +66,7 @@ namespace ORB_SLAM2 {
             }
         } // destroy scoped mutex -> release mutex
 
-        if (im.channels() < 3) //this should be always true
+        if (!im.empty() && im.channels() < 3) //this should be always true
             cvtColor(im, im, CV_GRAY2BGR);
 
         //Draw
diff --git a/slam/src/Initializer.cc b/slam/src/Initializer.cc
index 3f70214..768adbe 100644
--- a/slam/src/Initializer.cc
+++ b/slam/src/Initializer.cc
@@ -20,7 +20,7 @@
 
 #include "Initializer.h"
 
-#include "../Thirdparty/DBoW2/DUtils/Random.h"
+#include "DUtils/Random.h"
 
 #include "Optimizer.h"
 #include "ORBmatcher.h"
diff --git a/slam/src/KeyFrame.cc b/slam/src/KeyFrame.cc
index b93b4b2..1b30e36 100644
--- a/slam/src/KeyFrame.cc
+++ b/slam/src/KeyFrame.cc
@@ -1,87 +1,85 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "KeyFrame.h"
 #include "Converter.h"
 #include "ORBmatcher.h"
-#include "RaspberryKeyFrame.h"
-#include<mutex>
+#include <mutex>
 
 #include <boost/archive/text_oarchive.hpp>
 // #include <boost/archive/binary_iarchive.hpp>
 
+namespace boost
+{
+    namespace serialization
+    {
 
-namespace boost{
-    namespace serialization{
-        
     }
 }
 
 namespace ORB_SLAM2
 {
 
-long unsigned int KeyFrame::nNextId=0;
-
-KeyFrame::KeyFrame(Frame &F, Map *pMap, KeyFrameDatabase *pKFDB):
-    mnFrameId(F.mnId),  mTimeStamp(F.mTimeStamp), mnGridCols(FRAME_GRID_COLS), mnGridRows(FRAME_GRID_ROWS),
-    mfGridElementWidthInv(F.mfGridElementWidthInv), mfGridElementHeightInv(F.mfGridElementHeightInv),
-    mnTrackReferenceForFrame(0), mnFuseTargetForKF(0), mnBALocalForKF(0), mnBAFixedForKF(0),
-    mnLoopQuery(0), mnLoopWords(0), mnRelocQuery(0), mnRelocWords(0), mnBAGlobalForKF(0),
-    fx(F.fx), fy(F.fy), cx(F.cx), cy(F.cy), invfx(F.invfx), invfy(F.invfy),
-    mbf(F.mbf), mb(F.mb), mThDepth(F.mThDepth), N(F.N), mvKeys(F.mvKeys), mvKeysUn(F.mvKeysUn),
-    mvuRight(F.mvuRight), mvDepth(F.mvDepth), mDescriptors(F.mDescriptors.clone()),
-    mBowVec(F.mBowVec), mFeatVec(F.mFeatVec), mnScaleLevels(F.mnScaleLevels), mfScaleFactor(F.mfScaleFactor),
-    mfLogScaleFactor(F.mfLogScaleFactor), mvScaleFactors(F.mvScaleFactors), mvLevelSigma2(F.mvLevelSigma2),
-    mvInvLevelSigma2(F.mvInvLevelSigma2), mnMinX(F.mnMinX), mnMinY(F.mnMinY), mnMaxX(F.mnMaxX),
-    mnMaxY(F.mnMaxY), mK(F.mK), mvpMapPoints(F.mvpMapPoints), mpKeyFrameDB(pKFDB),
-    mpORBvocabulary(F.mpORBvocabulary), mbFirstConnection(true), mpParent(NULL), mbNotErase(false),
-    mbToBeErased(false), mbBad(false), mHalfBaseline(F.mb/2), mpMap(pMap)
-{
+    long unsigned int KeyFrame::nNextId = 0;
+
+    KeyFrame::KeyFrame(Frame &F, Map *pMap, KeyFrameDatabase *pKFDB) : mnFrameId(F.mnId), mTimeStamp(F.mTimeStamp), mnGridCols(FRAME_GRID_COLS), mnGridRows(FRAME_GRID_ROWS),
+                                                                       mfGridElementWidthInv(F.mfGridElementWidthInv), mfGridElementHeightInv(F.mfGridElementHeightInv),
+                                                                       mnTrackReferenceForFrame(0), mnFuseTargetForKF(0), mnBALocalForKF(0), mnBAFixedForKF(0),
+                                                                       mnLoopQuery(0), mnLoopWords(0), mnRelocQuery(0), mnRelocWords(0), mnBAGlobalForKF(0),
+                                                                       fx(F.fx), fy(F.fy), cx(F.cx), cy(F.cy), invfx(F.invfx), invfy(F.invfy),
+                                                                       mbf(F.mbf), mb(F.mb), mThDepth(F.mThDepth), N(F.N), mvKeys(F.mvKeys), mvKeysUn(F.mvKeysUn),
+                                                                       mvuRight(F.mvuRight), mvDepth(F.mvDepth), mDescriptors(F.mDescriptors.clone()),
+                                                                       mBowVec(F.mBowVec), mFeatVec(F.mFeatVec), mnScaleLevels(F.mnScaleLevels), mfScaleFactor(F.mfScaleFactor),
+                                                                       mfLogScaleFactor(F.mfLogScaleFactor), mvScaleFactors(F.mvScaleFactors), mvLevelSigma2(F.mvLevelSigma2),
+                                                                       mvInvLevelSigma2(F.mvInvLevelSigma2), mnMinX(F.mnMinX), mnMinY(F.mnMinY), mnMaxX(F.mnMaxX),
+                                                                       mnMaxY(F.mnMaxY), mK(F.mK), mvpMapPoints(F.mvpMapPoints), mpKeyFrameDB(pKFDB),
+                                                                       mpORBvocabulary(F.mpORBvocabulary), mbFirstConnection(true), mpParent(NULL), mbNotErase(false),
+                                                                       mbToBeErased(false), mbBad(false), mHalfBaseline(F.mb / 2), mpMap(pMap)
+    {
 
-    image = F.image;
-    
-    mnId=nNextId++;
+        image = F.image;
 
-    mGrid.resize(mnGridCols);
-    for(int i=0; i<mnGridCols;i++)
-    {
-        mGrid[i].resize(mnGridRows);
-        for(int j=0; j<mnGridRows; j++)
-            mGrid[i][j] = F.mGrid[i][j];
-    }
+        mnId = nNextId++;
 
-    SetPose(F.mTcw);    
-}
+        mGrid.resize(mnGridCols);
+        for (int i = 0; i < mnGridCols; i++)
+        {
+            mGrid[i].resize(mnGridRows);
+            for (int j = 0; j < mnGridRows; j++)
+                mGrid[i][j] = F.mGrid[i][j];
+        }
 
-// Default serializing Constructor
-KeyFrame::KeyFrame():
-    mnFrameId(0),  mTimeStamp(0.0), mnGridCols(FRAME_GRID_COLS), mnGridRows(FRAME_GRID_ROWS),
-    mfGridElementWidthInv(0.0), mfGridElementHeightInv(0.0),
-    mnTrackReferenceForFrame(0), mnFuseTargetForKF(0), mnBALocalForKF(0), mnBAFixedForKF(0),
-    mnLoopQuery(0), mnLoopWords(0), mnRelocQuery(0), mnRelocWords(0), mnBAGlobalForKF(0),
-    fx(0.0), fy(0.0), cx(0.0), cy(0.0), invfx(0.0), invfy(0.0),
-    mbf(0.0), mb(0.0), mThDepth(0.0), N(0), mnScaleLevels(0), mfScaleFactor(0),
-    mfLogScaleFactor(0.0),
-    mnMinX(0), mnMinY(0), mnMaxX(0),
-    mnMaxY(0)
-{
+        SetPose(F.mTcw);
+    }
+
+    // Default serializing Constructor
+    KeyFrame::KeyFrame() : mnFrameId(0), mTimeStamp(0.0), mnGridCols(FRAME_GRID_COLS), mnGridRows(FRAME_GRID_ROWS),
+                           mfGridElementWidthInv(0.0), mfGridElementHeightInv(0.0),
+                           mnTrackReferenceForFrame(0), mnFuseTargetForKF(0), mnBALocalForKF(0), mnBAFixedForKF(0),
+                           mnLoopQuery(0), mnLoopWords(0), mnRelocQuery(0), mnRelocWords(0), mnBAGlobalForKF(0),
+                           fx(0.0), fy(0.0), cx(0.0), cy(0.0), invfx(0.0), invfy(0.0),
+                           mbf(0.0), mb(0.0), mThDepth(0.0), N(0), mnScaleLevels(0), mfScaleFactor(0),
+                           mfLogScaleFactor(0.0),
+                           mnMinX(0), mnMinY(0), mnMaxX(0),
+                           mnMaxY(0)
+    {
 #if 0
     mnId=nNextId++;
 
@@ -93,149 +91,150 @@ KeyFrame::KeyFrame():
             mGrid[i][j] = F.mGrid[i][j];
     }
 
-    SetPose(F.mTcw);    
+    SetPose(F.mTcw);
 #endif
-}
+    }
 
 #ifndef _BAR_
-template<class Archive>
-    void KeyFrame::save(Archive & ar, const unsigned int version) const
+    template <class Archive>
+    void KeyFrame::save(Archive &ar, const unsigned int version) const
     {
-        ar & const_cast<cv::Mat &> (image);
+        ar &const_cast<cv::Mat &>(image);
 
-        int nItems;bool is_id;bool has_parent = false;
+        int nItems;
+        bool is_id;
+        bool has_parent = false;
         long unsigned int t_nId;
-        //int ordered_weight;
-        ar & nNextId;
+        // int ordered_weight;
+        ar &nNextId;
         int ConKfWeight;
-        
-        //if (mbToBeErased)
-            //return;
-        //if (mbBad)
-            //return;
-        ar & const_cast<long unsigned int &> (mnId);
-        ar & const_cast<long unsigned int &> (mnFrameId);
-        ar & const_cast<double &> (mTimeStamp);
-        ar & const_cast<int &> (mnGridCols);
-        ar & const_cast<int &> (mnGridRows);
-        ar & const_cast<float &>  (mfGridElementWidthInv);
-        ar & const_cast<float &>  (mfGridElementHeightInv);
-        ar & const_cast<long unsigned int &> (mnTrackReferenceForFrame);
-        ar & const_cast<long unsigned int &> (mnFuseTargetForKF);
-        ar & const_cast<long unsigned int &> (mnBALocalForKF);
-        ar & const_cast<long unsigned int &> (mnBAFixedForKF);
-        ar & const_cast<long unsigned int &> (mnLoopQuery);
-        ar & const_cast<int &> (mnLoopWords);
-        ar & const_cast<float &> (mLoopScore);
-        ar & const_cast<long unsigned int &> (mnRelocQuery);
-        ar & const_cast<int &> (mnRelocWords);
-        ar & const_cast<float &> (mRelocScore);
-        ar & const_cast<cv::Mat &> (mTcwGBA);
-        ar & const_cast<cv::Mat &> (mTcwBefGBA);
-        ar & const_cast<long unsigned int &> (mnBAGlobalForKF);
-        ar & const_cast<float &> (fx);
-        ar & const_cast<float &> (fy);
-        ar & const_cast<float &> (cx);
-        ar & const_cast<float &> (cy);
-        ar & const_cast<float &> (invfx);
-        ar & const_cast<float &> (invfy);
-        ar & const_cast<float &> (mbf);
-        ar & const_cast<float &> (mb);
-        ar & const_cast<float &> (mThDepth);
-        ar & const_cast<int &> (N);
-        ar & const_cast<std::vector<cv::KeyPoint> &> (mvKeys);
-        ar & const_cast<std::vector<cv::KeyPoint> &> (mvKeysUn);
-        ar & const_cast<std::vector<float> &> (mvuRight);
-        ar & const_cast<std::vector<float> &> (mvDepth);
-        ar & const_cast<cv::Mat &> (mDescriptors);
-        ar & const_cast<cv::Mat &> (mTcp);
-        ar & const_cast<int &> (mnScaleLevels);
-        ar & const_cast<float &> (mfScaleFactor);
-        ar & const_cast<float &> (mfLogScaleFactor);
-        ar & const_cast<std::vector<float> &> (mvScaleFactors);
-        ar & const_cast<std::vector<float> &> (mvLevelSigma2);
-        ar & const_cast<std::vector<float> &> (mvInvLevelSigma2);
-
-        ar & const_cast<int &> (mnMinX);
-        ar & const_cast<int &> (mnMinY);
-        ar & const_cast<int &> (mnMaxX);
-        ar & const_cast<int &> (mnMaxY);
-        ar & const_cast<cv::Mat &> (mK);
-        ar & const_cast<cv::Mat &> (Tcw);
-        ar & const_cast<cv::Mat &> (Twc);
-        ar & const_cast<cv::Mat &> (Ow);
-        ar & const_cast<cv::Mat &> (Cw);
+
+        // if (mbToBeErased)
+        // return;
+        // if (mbBad)
+        // return;
+        ar &const_cast<long unsigned int &>(mnId);
+        ar &const_cast<long unsigned int &>(mnFrameId);
+        ar &const_cast<double &>(mTimeStamp);
+        ar &const_cast<int &>(mnGridCols);
+        ar &const_cast<int &>(mnGridRows);
+        ar &const_cast<float &>(mfGridElementWidthInv);
+        ar &const_cast<float &>(mfGridElementHeightInv);
+        ar &const_cast<long unsigned int &>(mnTrackReferenceForFrame);
+        ar &const_cast<long unsigned int &>(mnFuseTargetForKF);
+        ar &const_cast<long unsigned int &>(mnBALocalForKF);
+        ar &const_cast<long unsigned int &>(mnBAFixedForKF);
+        ar &const_cast<long unsigned int &>(mnLoopQuery);
+        ar &const_cast<int &>(mnLoopWords);
+        ar &const_cast<float &>(mLoopScore);
+        ar &const_cast<long unsigned int &>(mnRelocQuery);
+        ar &const_cast<int &>(mnRelocWords);
+        ar &const_cast<float &>(mRelocScore);
+        ar &const_cast<cv::Mat &>(mTcwGBA);
+        ar &const_cast<cv::Mat &>(mTcwBefGBA);
+        ar &const_cast<long unsigned int &>(mnBAGlobalForKF);
+        ar &const_cast<float &>(fx);
+        ar &const_cast<float &>(fy);
+        ar &const_cast<float &>(cx);
+        ar &const_cast<float &>(cy);
+        ar &const_cast<float &>(invfx);
+        ar &const_cast<float &>(invfy);
+        ar &const_cast<float &>(mbf);
+        ar &const_cast<float &>(mb);
+        ar &const_cast<float &>(mThDepth);
+        ar &const_cast<int &>(N);
+        ar &const_cast<std::vector<cv::KeyPoint> &>(mvKeys);
+        ar &const_cast<std::vector<cv::KeyPoint> &>(mvKeysUn);
+        ar &const_cast<std::vector<float> &>(mvuRight);
+        ar &const_cast<std::vector<float> &>(mvDepth);
+        ar &const_cast<cv::Mat &>(mDescriptors);
+        ar &const_cast<cv::Mat &>(mTcp);
+        ar &const_cast<int &>(mnScaleLevels);
+        ar &const_cast<float &>(mfScaleFactor);
+        ar &const_cast<float &>(mfLogScaleFactor);
+        ar &const_cast<std::vector<float> &>(mvScaleFactors);
+        ar &const_cast<std::vector<float> &>(mvLevelSigma2);
+        ar &const_cast<std::vector<float> &>(mvInvLevelSigma2);
+
+        ar &const_cast<int &>(mnMinX);
+        ar &const_cast<int &>(mnMinY);
+        ar &const_cast<int &>(mnMaxX);
+        ar &const_cast<int &>(mnMaxY);
+        ar &const_cast<cv::Mat &>(mK);
+        ar &const_cast<cv::Mat &>(Tcw);
+        ar &const_cast<cv::Mat &>(Twc);
+        ar &const_cast<cv::Mat &>(Ow);
+        ar &const_cast<cv::Mat &>(Cw);
         // Save each map point id
         nItems = mvpMapPoints.size();
-        ar & nItems;
-        
-        //cout << "{INFO}mvpMapPoints nItems -" << nItems << endl;
-        for (std::vector<MapPoint*>::const_iterator it = mvpMapPoints.begin(); it != mvpMapPoints.end(); ++it) {        
+        ar &nItems;
+
+        // cout << "{INFO}mvpMapPoints nItems -" << nItems << endl;
+        for (std::vector<MapPoint *>::const_iterator it = mvpMapPoints.begin(); it != mvpMapPoints.end(); ++it)
+        {
             if (*it == NULL)
             {
                 is_id = false;
-                ar & is_id;
+                ar &is_id;
                 continue;
             }
             else
             {
                 is_id = true;
-                ar & is_id;
-                t_nId =  (**it).mnId;
-                //cout << "[" << t_nId <<"]";
-
-                ar & t_nId;
+                ar &is_id;
+                t_nId = (**it).mnId;
+                // cout << "[" << t_nId <<"]";
 
+                ar &t_nId;
             }
- 
-            
         }
 
         // Grid
-        ar & const_cast<std::vector< std::vector <std::vector<size_t> > > &> (mGrid);
-         nItems = mConnectedKeyFrameWeights.size();
-         ar & nItems;
+        ar &const_cast<std::vector<std::vector<std::vector<size_t>>> &>(mGrid);
+        nItems = mConnectedKeyFrameWeights.size();
+        ar &nItems;
 
-         for (std::map<KeyFrame*,int>::const_iterator it = mConnectedKeyFrameWeights.begin(); 
-                it != mConnectedKeyFrameWeights.end();
-                ++it) 
-         {        
+        for (std::map<KeyFrame *, int>::const_iterator it = mConnectedKeyFrameWeights.begin();
+             it != mConnectedKeyFrameWeights.end();
+             ++it)
+        {
             if (it->first == NULL)
             {
                 is_id = false;
-                ar & is_id;
+                ar &is_id;
                 continue;
             }
             else
             {
                 is_id = true;
-                ar & is_id;
-                t_nId =  it->first->mnId;
-                ar & t_nId;
+                ar &is_id;
+                t_nId = it->first->mnId;
+                ar &t_nId;
                 ConKfWeight = it->second;
-                ar & ConKfWeight;
+                ar &ConKfWeight;
             }
-         }
-         // Save each mvpOrderedConnectedKeyFrames
+        }
+        // Save each mvpOrderedConnectedKeyFrames
         nItems = mvpOrderedConnectedKeyFrames.size();
-        ar & nItems;
-        
-        for (std::vector<KeyFrame*>::const_iterator it = mvpOrderedConnectedKeyFrames.begin(); 
-                it != mvpOrderedConnectedKeyFrames.end(); 
-                ++it) {        
+        ar &nItems;
+
+        for (std::vector<KeyFrame *>::const_iterator it = mvpOrderedConnectedKeyFrames.begin();
+             it != mvpOrderedConnectedKeyFrames.end();
+             ++it)
+        {
             if (*it == NULL)
             {
                 is_id = false;
-                ar & is_id;
+                ar &is_id;
                 continue;
             }
             else
             {
                 is_id = true;
-                ar & is_id;
-                t_nId =  (**it).mnId;
-                ar & t_nId;
-            }            
+                ar &is_id;
+                t_nId = (**it).mnId;
+                ar &t_nId;
+            }
         }
         // Save Each mvOrderedWeights
 #if 0
@@ -253,1211 +252,1182 @@ template<class Archive>
                     
         }
 #endif
-        ar &  const_cast<std::vector<int> &>(mvOrderedWeights);
+        ar &const_cast<std::vector<int> &>(mvOrderedWeights);
 
         // Spanning Tree
-        ar & const_cast<bool &> (mbFirstConnection);
-        
+        ar &const_cast<bool &>(mbFirstConnection);
+
         if (mpParent)
         {
             has_parent = true;
-            ar & has_parent;
+            ar &has_parent;
             ar & mpParent->mnId;
         }
         else
         {
             has_parent = false;
-            ar & has_parent;
-            //ar & mpParent->mnId;
+            ar &has_parent;
+            // ar & mpParent->mnId;
         }
         // Save each child Frame id
         nItems = mspChildrens.size();
-        ar & nItems;
-            for (std::set<KeyFrame*>::const_iterator it = mspChildrens.begin(); it != mspChildrens.end(); ++it) {        
+        ar &nItems;
+        for (std::set<KeyFrame *>::const_iterator it = mspChildrens.begin(); it != mspChildrens.end(); ++it)
+        {
             if (*it == NULL)
             {
                 is_id = false;
-                ar & is_id;
+                ar &is_id;
                 continue;
             }
             else
             {
                 is_id = true;
-                ar & is_id;
-                t_nId =  (**it).mnId;
-                //cout << "[" << t_nId <<"]";
-                ar & t_nId;
-            } 
-            
+                ar &is_id;
+                t_nId = (**it).mnId;
+                // cout << "[" << t_nId <<"]";
+                ar &t_nId;
+            }
         }
         // Save each Loop Edge id
         nItems = mspLoopEdges.size();
-        ar & nItems;
-            for (std::set<KeyFrame*>::const_iterator it = mspLoopEdges.begin(); it != mspLoopEdges.end(); ++it) {        
+        ar &nItems;
+        for (std::set<KeyFrame *>::const_iterator it = mspLoopEdges.begin(); it != mspLoopEdges.end(); ++it)
+        {
             if (*it == NULL)
             {
                 is_id = false;
-                ar & is_id;
+                ar &is_id;
                 continue;
             }
             else
             {
                 is_id = true;
-                ar & is_id;
-                t_nId =  (**it).mnId;
-                //cout << "[" << t_nId <<"]";
-                ar & t_nId;
-            } 
-            
+                ar &is_id;
+                t_nId = (**it).mnId;
+                // cout << "[" << t_nId <<"]";
+                ar &t_nId;
+            }
         }
 
-        ar & const_cast<bool &> (mbNotErase);
-        ar & const_cast<bool &> (mbToBeErased);
-        ar & const_cast<bool &> (mbBad);
-        ar & const_cast<float &> (mHalfBaseline);
+        ar &const_cast<bool &>(mbNotErase);
+        ar &const_cast<bool &>(mbToBeErased);
+        ar &const_cast<bool &>(mbBad);
+        ar &const_cast<float &>(mHalfBaseline);
         // cout << "{INFO}mvpMapPoints nItems fin"<< endl;
-        //cout << "Save Map :  KF stat is : " << endl;
-        //t_nId = has_parent?mpParent->mnId:0;
-        //cout << "KF mnId = " << mnId << " Parent ID " <<t_nId <<" mspLoopEdges.size() = " << nItems <<endl;
-
-       
+        // cout << "Save Map :  KF stat is : " << endl;
+        // t_nId = has_parent?mpParent->mnId:0;
+        // cout << "KF mnId = " << mnId << " Parent ID " <<t_nId <<" mspLoopEdges.size() = " << nItems <<endl;
     }
 
-    template<class Archive>
-    void KeyFrame::load(Archive & ar, const unsigned int version)
+    template <class Archive>
+    void KeyFrame::load(Archive &ar, const unsigned int version)
     {
-        ar & const_cast<cv::Mat &> (image);
+        ar &const_cast<cv::Mat &>(image);
 
         id_map storer;
-        int nItems;bool is_id = false;
+        int nItems;
+        bool is_id = false;
         bool has_parent = false;
         long unsigned int t_nId;
-        ar & nNextId;
-        ar & const_cast<long unsigned int &> (mnId);
+        ar &nNextId;
+        ar &const_cast<long unsigned int &>(mnId);
         int ConKfWeight = 0;
-        //cout << "{INFO}Keyframe Load - " << mnId << endl;
-
-        ar & const_cast<long unsigned int &> (mnFrameId);
-        ar & const_cast<double &> (mTimeStamp);
-        ar & const_cast<int &> (mnGridCols);
-        ar & const_cast<int &> (mnGridRows);
-        ar & const_cast<float &>  (mfGridElementWidthInv);
-        ar & const_cast<float &>  (mfGridElementHeightInv);
-        ar & const_cast<long unsigned int &> (mnTrackReferenceForFrame);
-        ar & const_cast<long unsigned int &> (mnFuseTargetForKF);
-        ar & const_cast<long unsigned int &> (mnBALocalForKF);
-        ar & const_cast<long unsigned int &> (mnBAFixedForKF);
-        ar & const_cast<long unsigned int &> (mnLoopQuery);
-        ar & const_cast<int &> (mnLoopWords);
-        ar & const_cast<float &> (mLoopScore);
-        ar & const_cast<long unsigned int &> (mnRelocQuery);
-        ar & const_cast<int &> (mnRelocWords);
-        ar & const_cast<float &> (mRelocScore);
-        ar & const_cast<cv::Mat &> (mTcwGBA);
-        ar & const_cast<cv::Mat &> (mTcwBefGBA);
-        ar & const_cast<long unsigned int &> (mnBAGlobalForKF);
-        ar & const_cast<float &> (fx);
-        ar & const_cast<float &> (fy);
-        ar & const_cast<float &> (cx);
-        ar & const_cast<float &> (cy);
-        ar & const_cast<float &> (invfx);
-        ar & const_cast<float &> (invfy);
-        ar & const_cast<float &> (mbf);
-        ar & const_cast<float &> (mb);
-        ar & const_cast<float &> (mThDepth);
-        ar & const_cast<int &> (N);
-        ar & const_cast<std::vector<cv::KeyPoint> &> (mvKeys);
-        ar & const_cast<std::vector<cv::KeyPoint> &> (mvKeysUn);
-        ar & const_cast<std::vector<float> &> (mvuRight);
-        ar & const_cast<std::vector<float> &> (mvDepth);
-        ar & const_cast<cv::Mat &> (mDescriptors);
-        ar & const_cast<cv::Mat &> (mTcp);
-        ar & const_cast<int &> (mnScaleLevels);
-        ar & const_cast<float &> (mfScaleFactor);
-        ar & const_cast<float &> (mfLogScaleFactor);
-        ar & const_cast<std::vector<float> &> (mvScaleFactors);
-        ar & const_cast<std::vector<float> &> (mvLevelSigma2);
-        ar & const_cast<std::vector<float> &> (mvInvLevelSigma2);
-
-        ar & const_cast<int &> (mnMinX);
-        ar & const_cast<int &> (mnMinY);
-        ar & const_cast<int &> (mnMaxX);
-        ar & const_cast<int &> (mnMaxY);
-        ar & const_cast<cv::Mat &> (mK);
-        ar & const_cast<cv::Mat &> (Tcw);
-        ar & const_cast<cv::Mat &> (Twc);
-        ar & const_cast<cv::Mat &> (Ow);
-        ar & const_cast<cv::Mat &> (Cw);
+        // cout << "{INFO}Keyframe Load - " << mnId << endl;
+
+        ar &const_cast<long unsigned int &>(mnFrameId);
+        ar &const_cast<double &>(mTimeStamp);
+        ar &const_cast<int &>(mnGridCols);
+        ar &const_cast<int &>(mnGridRows);
+        ar &const_cast<float &>(mfGridElementWidthInv);
+        ar &const_cast<float &>(mfGridElementHeightInv);
+        ar &const_cast<long unsigned int &>(mnTrackReferenceForFrame);
+        ar &const_cast<long unsigned int &>(mnFuseTargetForKF);
+        ar &const_cast<long unsigned int &>(mnBALocalForKF);
+        ar &const_cast<long unsigned int &>(mnBAFixedForKF);
+        ar &const_cast<long unsigned int &>(mnLoopQuery);
+        ar &const_cast<int &>(mnLoopWords);
+        ar &const_cast<float &>(mLoopScore);
+        ar &const_cast<long unsigned int &>(mnRelocQuery);
+        ar &const_cast<int &>(mnRelocWords);
+        ar &const_cast<float &>(mRelocScore);
+        ar &const_cast<cv::Mat &>(mTcwGBA);
+        ar &const_cast<cv::Mat &>(mTcwBefGBA);
+        ar &const_cast<long unsigned int &>(mnBAGlobalForKF);
+        ar &const_cast<float &>(fx);
+        ar &const_cast<float &>(fy);
+        ar &const_cast<float &>(cx);
+        ar &const_cast<float &>(cy);
+        ar &const_cast<float &>(invfx);
+        ar &const_cast<float &>(invfy);
+        ar &const_cast<float &>(mbf);
+        ar &const_cast<float &>(mb);
+        ar &const_cast<float &>(mThDepth);
+        ar &const_cast<int &>(N);
+        ar &const_cast<std::vector<cv::KeyPoint> &>(mvKeys);
+        ar &const_cast<std::vector<cv::KeyPoint> &>(mvKeysUn);
+        ar &const_cast<std::vector<float> &>(mvuRight);
+        ar &const_cast<std::vector<float> &>(mvDepth);
+        ar &const_cast<cv::Mat &>(mDescriptors);
+        ar &const_cast<cv::Mat &>(mTcp);
+        ar &const_cast<int &>(mnScaleLevels);
+        ar &const_cast<float &>(mfScaleFactor);
+        ar &const_cast<float &>(mfLogScaleFactor);
+        ar &const_cast<std::vector<float> &>(mvScaleFactors);
+        ar &const_cast<std::vector<float> &>(mvLevelSigma2);
+        ar &const_cast<std::vector<float> &>(mvInvLevelSigma2);
+
+        ar &const_cast<int &>(mnMinX);
+        ar &const_cast<int &>(mnMinY);
+        ar &const_cast<int &>(mnMaxX);
+        ar &const_cast<int &>(mnMaxY);
+        ar &const_cast<cv::Mat &>(mK);
+        ar &const_cast<cv::Mat &>(Tcw);
+        ar &const_cast<cv::Mat &>(Twc);
+        ar &const_cast<cv::Mat &>(Ow);
+        ar &const_cast<cv::Mat &>(Cw);
         // Load each map point id
-        ar & nItems;
+        ar &nItems;
         mvpMapPoints.resize(nItems);
-        //mmMapPoints_nId.resize(nItems);
-        int j=0;
-        for (int i = 0; i < nItems; ++i) { 
+        // mmMapPoints_nId.resize(nItems);
+        int j = 0;
+        for (int i = 0; i < nItems; ++i)
+        {
 
-            ar & is_id;
+            ar &is_id;
             if (is_id)
             {
                 j++;
-                ar & t_nId;
+                ar &t_nId;
                 storer.is_valid = true;
-                storer.id= t_nId;
+                storer.id = t_nId;
                 mmMapPoints_nId[i] = storer;
             }
             else
             {
                 storer.is_valid = false;
-                storer.id= 0;
+                storer.id = 0;
                 mmMapPoints_nId[i] = storer;
             }
         }
-        
-        //cout << "KF " << mnId <<" valid points = " << j << "invalid points = " << (nItems - j) << endl;
-        // Grid
-        ar & const_cast<std::vector< std::vector <std::vector<size_t> > > &> (mGrid);
 
-        ar & nItems;
-        //mConnectedKeyFrameWeights_nId.resize(nItems);
-       //mConnectedKeyFrameWeights.resize(nItems);
-        for (int i = 0; i < nItems; ++i) { 
+        // cout << "KF " << mnId <<" valid points = " << j << "invalid points = " << (nItems - j) << endl;
+        //  Grid
+        ar &const_cast<std::vector<std::vector<std::vector<size_t>>> &>(mGrid);
 
-            ar & is_id;
+        ar &nItems;
+        // mConnectedKeyFrameWeights_nId.resize(nItems);
+        // mConnectedKeyFrameWeights.resize(nItems);
+        for (int i = 0; i < nItems; ++i)
+        {
+
+            ar &is_id;
             if (is_id)
             {
-                ar & t_nId;
-                ar & ConKfWeight;
+                ar &t_nId;
+                ar &ConKfWeight;
                 mConnectedKeyFrameWeights_nId[t_nId] = ConKfWeight;
             }
             else
             {
-
             }
         }
 
-         // Load each mvpOrderedConnectedKeyFrames id
-        ar & nItems;
+        // Load each mvpOrderedConnectedKeyFrames id
+        ar &nItems;
         j = 0;
-        //mvpOrderedConnectedKeyFrames.resize(nItems);
-        //mvpOrderedConnectedKeyFrames_nId.resize(nItems);
-        for (int i = 0; i < nItems; ++i) {
-            ar & is_id;
+        // mvpOrderedConnectedKeyFrames.resize(nItems);
+        // mvpOrderedConnectedKeyFrames_nId.resize(nItems);
+        for (int i = 0; i < nItems; ++i)
+        {
+            ar &is_id;
             if (is_id)
             {
                 j++;
-                ar & t_nId;
+                ar &t_nId;
                 storer.is_valid = true;
-                storer.id= t_nId;
+                storer.id = t_nId;
                 mvpOrderedConnectedKeyFrames_nId[i] = storer;
             }
             else
             {
                 storer.is_valid = false;
-                storer.id= 0;
+                storer.id = 0;
                 mvpOrderedConnectedKeyFrames_nId[i] = storer;
             }
         }
         // Load each mvOrderedWeights
-        ar & const_cast<std::vector<int> &>(mvOrderedWeights);
+        ar &const_cast<std::vector<int> &>(mvOrderedWeights);
 
-        ar & const_cast<bool &> (mbFirstConnection);
-        
-        // Spanning Tree    
-        ar & has_parent;
+        ar &const_cast<bool &>(mbFirstConnection);
+
+        // Spanning Tree
+        ar &has_parent;
         if (has_parent)
         {
             mparent_KfId_map.is_valid = true;
-            ar & mparent_KfId_map.id;      
+            ar &mparent_KfId_map.id;
         }
         else
         {
-            mparent_KfId_map.is_valid = false; 
+            mparent_KfId_map.is_valid = false;
             mparent_KfId_map.id = 0;
         }
         // load each child Frame id
-        ar & nItems;
-        //mspChildrens.resize(nItems);
-        //mmChildrens_nId.resize(nItems);
+        ar &nItems;
+        // mspChildrens.resize(nItems);
+        // mmChildrens_nId.resize(nItems);
 
-       for (int i = 0; i < nItems; ++i) { 
+        for (int i = 0; i < nItems; ++i)
+        {
 
-            ar & is_id;
+            ar &is_id;
             if (is_id)
             {
-                ar & t_nId;
+                ar &t_nId;
                 storer.is_valid = true;
-                storer.id= t_nId;
+                storer.id = t_nId;
                 mmChildrens_nId[i] = storer;
             }
             else
             {
                 storer.is_valid = false;
-                storer.id= 0;
+                storer.id = 0;
                 mmChildrens_nId[i] = storer;
             }
         }
 
         // Load each Loop Edge Frame id
-        ar & nItems;
-        //mspLoopEdges.resize(nItems);
-        //mmLoopEdges_nId.resize(nItems);
+        ar &nItems;
+        // mspLoopEdges.resize(nItems);
+        // mmLoopEdges_nId.resize(nItems);
 
-       for (int i = 0; i < nItems; ++i) { 
+        for (int i = 0; i < nItems; ++i)
+        {
 
-            ar & is_id;
+            ar &is_id;
             if (is_id)
             {
-                ar & t_nId;
+                ar &t_nId;
                 storer.is_valid = true;
-                storer.id= t_nId;
+                storer.id = t_nId;
                 mmLoopEdges_nId[i] = storer;
             }
             else
             {
                 storer.is_valid = false;
-                storer.id= 0;
+                storer.id = 0;
                 mmLoopEdges_nId[i] = storer;
             }
         }
 
-        ar & const_cast<bool &> (mbNotErase);
-        ar & const_cast<bool &> (mbToBeErased);
-        ar & const_cast<bool &> (mbBad);
-        ar & const_cast<float &> (mHalfBaseline);
-        //cout << "Load Map :  KF stat is : " << endl;
-        //cout << "KF mnId = " << mnId << " Parent ID " <<mparent_KfId_map.id <<" mspLoopEdges.size() = " << nItems <<endl;
-
+        ar &const_cast<bool &>(mbNotErase);
+        ar &const_cast<bool &>(mbToBeErased);
+        ar &const_cast<bool &>(mbBad);
+        ar &const_cast<float &>(mHalfBaseline);
+        // cout << "Load Map :  KF stat is : " << endl;
+        // cout << "KF mnId = " << mnId << " Parent ID " <<mparent_KfId_map.id <<" mspLoopEdges.size() = " << nItems <<endl;
     }
 
-
-// Explicit template instantiation
-template void KeyFrame::save<boost::archive::binary_oarchive>(
-    boost::archive::binary_oarchive &, 
-    const unsigned int) const;
-template void KeyFrame::save<boost::archive::binary_iarchive>(
-    boost::archive::binary_iarchive &, 
-    const unsigned int) const;
-template void KeyFrame::load<boost::archive::binary_oarchive>(
-    boost::archive::binary_oarchive &, 
-    const unsigned int);
-template void KeyFrame::load<boost::archive::binary_iarchive>(
-    boost::archive::binary_iarchive &, 
-    const unsigned int);
+    // Explicit template instantiation
+    template void KeyFrame::save<boost::archive::binary_oarchive>(
+        boost::archive::binary_oarchive &,
+        const unsigned int) const;
+    template void KeyFrame::save<boost::archive::binary_iarchive>(
+        boost::archive::binary_iarchive &,
+        const unsigned int) const;
+    template void KeyFrame::load<boost::archive::binary_oarchive>(
+        boost::archive::binary_oarchive &,
+        const unsigned int);
+    template void KeyFrame::load<boost::archive::binary_iarchive>(
+        boost::archive::binary_iarchive &,
+        const unsigned int);
 #endif
 
-void KeyFrame::SetMapPoints(std::vector<MapPoint*> spMapPoints)
-{
-    // We assume the mvpMapPoints_nId list has been initialized and contains the Map point IDS
-    // With nid, Search the KetFrame List and populate mvpMapPoints
-    long unsigned int id;
-    bool is_valid = false;
-    bool mapp_found = false;
-
-    int j = 0, ctr = 0;
-    for (std::map<long unsigned int,id_map>::iterator it = mmMapPoints_nId.begin(); 
-            it != mmMapPoints_nId.end(); 
-            j++,++it) 
+    void KeyFrame::SetMapPoints(std::vector<MapPoint *> spMapPoints)
     {
-        is_valid = it->second.is_valid; 
-        if (!is_valid)  
+        // We assume the mvpMapPoints_nId list has been initialized and contains the Map point IDS
+        // With nid, Search the KetFrame List and populate mvpMapPoints
+        long unsigned int id;
+        bool is_valid = false;
+        bool mapp_found = false;
+
+        int j = 0, ctr = 0;
+        for (std::map<long unsigned int, id_map>::iterator it = mmMapPoints_nId.begin();
+             it != mmMapPoints_nId.end();
+             j++, ++it)
         {
-            //j--; 
-            //continue;
-            mvpMapPoints[j] = static_cast<MapPoint*>(NULL);
-        }
-        else
-        {
-            id = it->second.id;  
-            //cout << "pushing a map point to mvp mappoint" << endl;
-            mapp_found = false;
-            for(std::vector<MapPoint*>::iterator mit=spMapPoints.begin(); mit !=spMapPoints.end(); mit++)
+            is_valid = it->second.is_valid;
+            if (!is_valid)
             {
-                MapPoint* pMp = *mit;
-               
-                if(id == pMp->mnId)
-                {    
-                    ctr ++;
-                    mvpMapPoints[j] = pMp;
-                    mapp_found = true;
-                    break;
-                }
+                // j--;
+                // continue;
+                mvpMapPoints[j] = static_cast<MapPoint *>(NULL);
             }
-            if (mapp_found == false)
+            else
             {
-                //cout << " map point [" << id <<"] not found in KF " << mnId << endl;
-                mvpMapPoints[j] = static_cast<MapPoint*>(NULL);
-            }
-
-        }
-
-    }
-}
+                id = it->second.id;
+                // cout << "pushing a map point to mvp mappoint" << endl;
+                mapp_found = false;
+                for (std::vector<MapPoint *>::iterator mit = spMapPoints.begin(); mit != spMapPoints.end(); mit++)
+                {
+                    MapPoint *pMp = *mit;
 
-void KeyFrame::SetSpanningTree(std::vector<KeyFrame*> vpKeyFrames)
-{
-    // We assume the mvpMapPoints_nId list has been initialized and contains the Map point IDS
-    // With nid, Search the KetFrame List and populate mvpMapPoints
-    long unsigned int id;
-    bool is_valid = false;
-    bool kf_found = false;
-
-    int j = 0, ctr = 0;
-    // Search Parent
-    if (mparent_KfId_map.is_valid)
-    {        
-        for(std::vector<KeyFrame*>::iterator mit=vpKeyFrames.begin(); mit !=vpKeyFrames.end(); mit++)
-        {
-            KeyFrame* pKf = *mit;
-            id = pKf->mnId;
-            //if (mnId == 10 && 964 == id)
-                 //cout << "[" << pMp->mnId <<"]";
-            if(id == mparent_KfId_map.id)
-            {    
-                ctr ++;
-                mpParent = pKf;
-                kf_found = true;
-                break;
+                    if (id == pMp->mnId)
+                    {
+                        ctr++;
+                        mvpMapPoints[j] = pMp;
+                        mapp_found = true;
+                        break;
+                    }
+                }
+                if (mapp_found == false)
+                {
+                    // cout << " map point [" << id <<"] not found in KF " << mnId << endl;
+                    mvpMapPoints[j] = static_cast<MapPoint *>(NULL);
+                }
             }
         }
-        if (kf_found == false)
-        {
-            cout << endl << "Parent KF [" << mparent_KfId_map.id <<"] not found for KF " << mnId << endl;
-            //mpParent = new KeyFrame();
-            //mpParent->mbBad = true;     
-            mpParent = static_cast<KeyFrame*>(NULL);             
-        }
     }
-    // Search Child
-    kf_found = false;
-    j = 0; ctr = 0;
-    is_valid = false;
-    for (std::map<long unsigned int,id_map>::iterator it = mmChildrens_nId.begin(); 
-            it != mmChildrens_nId.end(); 
-            j++,++it) 
-    {
-        is_valid = it->second.is_valid;  
-        if (!is_valid) 
-        {
-            //j--;
-            continue;
-            //mspChildrens.insert(NULL);            
-        }  
 
-        else
+    void KeyFrame::SetSpanningTree(std::vector<KeyFrame *> vpKeyFrames)
+    {
+        // We assume the mvpMapPoints_nId list has been initialized and contains the Map point IDS
+        // With nid, Search the KetFrame List and populate mvpMapPoints
+        long unsigned int id;
+        bool is_valid = false;
+        bool kf_found = false;
+
+        int j = 0, ctr = 0;
+        // Search Parent
+        if (mparent_KfId_map.is_valid)
         {
-            id = it->second.id;  
-            
-            kf_found = false;
-            for(std::vector<KeyFrame*>::iterator mit=vpKeyFrames.begin(); mit !=vpKeyFrames.end(); mit++)
+            for (std::vector<KeyFrame *>::iterator mit = vpKeyFrames.begin(); mit != vpKeyFrames.end(); mit++)
             {
-                KeyFrame* pKf = *mit;
-                //if (mnId == 10 && 964 == id)
-                     //cout << "[" << pMp->mnId <<"]";
-                if(id == pKf->mnId)
-                {    
-                    ctr ++;
-                    mspChildrens.insert(pKf);
+                KeyFrame *pKf = *mit;
+                id = pKf->mnId;
+                // if (mnId == 10 && 964 == id)
+                // cout << "[" << pMp->mnId <<"]";
+                if (id == mparent_KfId_map.id)
+                {
+                    ctr++;
+                    mpParent = pKf;
                     kf_found = true;
                     break;
                 }
             }
             if (kf_found == false)
-                cout << endl << "Child [" << id <<"] not found for KF " << mnId << endl;
-
+            {
+                cout << endl
+                     << "Parent KF [" << mparent_KfId_map.id << "] not found for KF " << mnId << endl;
+                // mpParent = new KeyFrame();
+                // mpParent->mbBad = true;
+                mpParent = static_cast<KeyFrame *>(NULL);
+            }
         }
+        // Search Child
+        kf_found = false;
+        j = 0;
+        ctr = 0;
+        is_valid = false;
+        for (std::map<long unsigned int, id_map>::iterator it = mmChildrens_nId.begin();
+             it != mmChildrens_nId.end();
+             j++, ++it)
+        {
+            is_valid = it->second.is_valid;
+            if (!is_valid)
+            {
+                // j--;
+                continue;
+                // mspChildrens.insert(NULL);
+            }
 
-    }
-
-    // Search Loop Edges
-    kf_found = false;
-    j = 0; ctr = 0;
-    is_valid = false;
-    for (std::map<long unsigned int,id_map>::iterator it = mmLoopEdges_nId.begin(); 
-            it != mmLoopEdges_nId.end(); 
-            j++,++it) 
-    {
-        is_valid = it->second.is_valid;  
+            else
+            {
+                id = it->second.id;
 
+                kf_found = false;
+                for (std::vector<KeyFrame *>::iterator mit = vpKeyFrames.begin(); mit != vpKeyFrames.end(); mit++)
+                {
+                    KeyFrame *pKf = *mit;
+                    // if (mnId == 10 && 964 == id)
+                    // cout << "[" << pMp->mnId <<"]";
+                    if (id == pKf->mnId)
+                    {
+                        ctr++;
+                        mspChildrens.insert(pKf);
+                        kf_found = true;
+                        break;
+                    }
+                }
+                if (kf_found == false)
+                    cout << endl
+                         << "Child [" << id << "] not found for KF " << mnId << endl;
+            }
+        }
 
-        if (!is_valid) 
-        {
-            //j--;
-            continue;
-            //mspLoopEdges.insert(NULL);
-        }  
-            
-        else
+        // Search Loop Edges
+        kf_found = false;
+        j = 0;
+        ctr = 0;
+        is_valid = false;
+        for (std::map<long unsigned int, id_map>::iterator it = mmLoopEdges_nId.begin();
+             it != mmLoopEdges_nId.end();
+             j++, ++it)
         {
-            id = it->second.id;  
-            
-            kf_found = false;
-            for(std::vector<KeyFrame*>::iterator mit=vpKeyFrames.begin(); mit !=vpKeyFrames.end(); mit++)
+            is_valid = it->second.is_valid;
+
+            if (!is_valid)
             {
-                KeyFrame* pKf = *mit;
-              
-                if(id == pKf->mnId)
-                {    
-                    ctr ++;                    
-                    mspLoopEdges.insert(pKf);
-                    kf_found = true;
-                    break;
-                }
+                // j--;
+                continue;
+                // mspLoopEdges.insert(NULL);
             }
-            if (kf_found == false)
-                cout << endl << "Loop Edge [" << id <<"] not found for KF " << mnId << endl;
 
-        }
+            else
+            {
+                id = it->second.id;
 
-    }
+                kf_found = false;
+                for (std::vector<KeyFrame *>::iterator mit = vpKeyFrames.begin(); mit != vpKeyFrames.end(); mit++)
+                {
+                    KeyFrame *pKf = *mit;
 
-}
-void KeyFrame::SetGridParams(std::vector<KeyFrame*> vpKeyFrames)
-{
-    long unsigned int id; int weight;  
-    bool Kf_found = false;  
-    //cout << "KF" << mnId <<" valid indexes-" << endl;
-    int j = 0; 
-    int ctr = 0;
-    bool is_valid = false;
-
-    
-    // Set up mConnectedKeyFrameWeights
-    for (map<long unsigned int, int>::iterator it = mConnectedKeyFrameWeights_nId.begin(); 
-            it != mConnectedKeyFrameWeights_nId.end(); 
-            j++,++it) 
-    {
-        id = it->first;
-        weight = it->second;        
-        {
-            
-            for(std::vector<KeyFrame*>::iterator mit=vpKeyFrames.begin(); mit !=vpKeyFrames.end(); mit++)
-            {
-                KeyFrame* pKf = *mit;
-               
-                if(id == pKf->mnId)
-                {   
-                    mConnectedKeyFrameWeights[pKf] = weight;
-                    break;
+                    if (id == pKf->mnId)
+                    {
+                        ctr++;
+                        mspLoopEdges.insert(pKf);
+                        kf_found = true;
+                        break;
+                    }
                 }
+                if (kf_found == false)
+                    cout << endl
+                         << "Loop Edge [" << id << "] not found for KF " << mnId << endl;
             }
-            
         }
     }
-
-    // Set up mvpOrderedConnectedKeyFrames
-    j = 0;
-    for (std::map<long unsigned int,id_map>::iterator it = mvpOrderedConnectedKeyFrames_nId.begin(); 
-            it != mvpOrderedConnectedKeyFrames_nId.end(); 
-            ++it) 
+    void KeyFrame::SetGridParams(std::vector<KeyFrame *> vpKeyFrames)
     {
-        is_valid = it->second.is_valid; 
-        if (!is_valid)  
-        {   
-            continue; 
-            ;//mvpOrderedConnectedKeyFrames[j] = NULL;
-        }
-        else
+        long unsigned int id;
+        int weight;
+        bool Kf_found = false;
+        // cout << "KF" << mnId <<" valid indexes-" << endl;
+        int j = 0;
+        int ctr = 0;
+        bool is_valid = false;
+
+        // Set up mConnectedKeyFrameWeights
+        for (map<long unsigned int, int>::iterator it = mConnectedKeyFrameWeights_nId.begin();
+             it != mConnectedKeyFrameWeights_nId.end();
+             j++, ++it)
         {
-            id = it->second.id;  
-            
-            Kf_found = false;
-            for(std::vector<KeyFrame*>::iterator mit=vpKeyFrames.begin(); mit !=vpKeyFrames.end(); mit++)
+            id = it->first;
+            weight = it->second;
             {
-                KeyFrame* pKf = *mit;
 
-                if(id == pKf->mnId)
-                {    
-                    ctr ++;
-                    mvpOrderedConnectedKeyFrames.push_back(pKf);
-                    Kf_found = true;
-                    break;
+                for (std::vector<KeyFrame *>::iterator mit = vpKeyFrames.begin(); mit != vpKeyFrames.end(); mit++)
+                {
+                    KeyFrame *pKf = *mit;
+
+                    if (id == pKf->mnId)
+                    {
+                        mConnectedKeyFrameWeights[pKf] = weight;
+                        break;
+                    }
                 }
             }
-            if (Kf_found == false)
+        }
+
+        // Set up mvpOrderedConnectedKeyFrames
+        j = 0;
+        for (std::map<long unsigned int, id_map>::iterator it = mvpOrderedConnectedKeyFrames_nId.begin();
+             it != mvpOrderedConnectedKeyFrames_nId.end();
+             ++it)
+        {
+            is_valid = it->second.is_valid;
+            if (!is_valid)
             {
-                //cout << "[" << id <<"] not found in KF " << mnId << endl;
-                
+                continue;
+                ; // mvpOrderedConnectedKeyFrames[j] = NULL;
             }
+            else
+            {
+                id = it->second.id;
 
-        }
+                Kf_found = false;
+                for (std::vector<KeyFrame *>::iterator mit = vpKeyFrames.begin(); mit != vpKeyFrames.end(); mit++)
+                {
+                    KeyFrame *pKf = *mit;
 
+                    if (id == pKf->mnId)
+                    {
+                        ctr++;
+                        mvpOrderedConnectedKeyFrames.push_back(pKf);
+                        Kf_found = true;
+                        break;
+                    }
+                }
+                if (Kf_found == false)
+                {
+                    // cout << "[" << id <<"] not found in KF " << mnId << endl;
+                }
+            }
+        }
     }
-}
-
-void KeyFrame::SetMap(Map* map)
-{
-    mpMap = map;   
-}
-
-void KeyFrame::SetKeyFrameDatabase(KeyFrameDatabase* pKeyFrameDB)
-{
-    mpKeyFrameDB = pKeyFrameDB;
-}
-
-void KeyFrame::SetORBvocabulary(ORBVocabulary* pORBvocabulary)
-{
-    mpORBvocabulary = pORBvocabulary;
-}
 
-void KeyFrame::ComputeBoW()
-{
-    if(mBowVec.empty() || mFeatVec.empty())
+    void KeyFrame::SetMap(Map *map)
     {
-        vector<cv::Mat> vCurrentDesc = Converter::toDescriptorVector(mDescriptors);
-        // Feature vector associate features with nodes in the 4th level (from leaves up)
-        // We assume the vocabulary tree has 6 levels, change the 4 otherwise
-        mpORBvocabulary->transform(vCurrentDesc,mBowVec,mFeatVec,4);
+        mpMap = map;
     }
-}
 
-void KeyFrame::SetPose(const cv::Mat &Tcw_)
-{
-    unique_lock<mutex> lock(mMutexPose);
-    Tcw_.copyTo(Tcw);
-    cv::Mat Rcw = Tcw.rowRange(0,3).colRange(0,3);
-    cv::Mat tcw = Tcw.rowRange(0,3).col(3);
-    cv::Mat Rwc = Rcw.t();
-    Ow = -Rwc*tcw;
-
-    Twc = cv::Mat::eye(4,4,Tcw.type());
-    Rwc.copyTo(Twc.rowRange(0,3).colRange(0,3));
-    Ow.copyTo(Twc.rowRange(0,3).col(3));
-    cv::Mat center = (cv::Mat_<float>(4,1) << mHalfBaseline, 0 , 0, 1);
-    Cw = Twc*center;
-}
-
-cv::Mat KeyFrame::GetPose()
-{
-    unique_lock<mutex> lock(mMutexPose);
-    return Tcw.clone();
-}
+    void KeyFrame::SetKeyFrameDatabase(KeyFrameDatabase *pKeyFrameDB)
+    {
+        mpKeyFrameDB = pKeyFrameDB;
+    }
 
-cv::Mat KeyFrame::GetPoseInverse()
-{
-    unique_lock<mutex> lock(mMutexPose);
-    return Twc.clone();
-}
+    void KeyFrame::SetORBvocabulary(ORBVocabulary *pORBvocabulary)
+    {
+        mpORBvocabulary = pORBvocabulary;
+    }
 
-cv::Mat KeyFrame::GetCameraCenter()
-{
-    unique_lock<mutex> lock(mMutexPose);
-    return Ow.clone();
-}
+    void KeyFrame::ComputeBoW()
+    {
+        if (mBowVec.empty() || mFeatVec.empty())
+        {
+            vector<cv::Mat> vCurrentDesc = Converter::toDescriptorVector(mDescriptors);
+            // Feature vector associate features with nodes in the 4th level (from leaves up)
+            // We assume the vocabulary tree has 6 levels, change the 4 otherwise
+            mpORBvocabulary->transform(vCurrentDesc, mBowVec, mFeatVec, 4);
+        }
+    }
 
-cv::Mat KeyFrame::GetStereoCenter()
-{
-    unique_lock<mutex> lock(mMutexPose);
-    return Cw.clone();
-}
+    void KeyFrame::SetPose(const cv::Mat &Tcw_)
+    {
+        unique_lock<mutex> lock(mMutexPose);
+        Tcw_.copyTo(Tcw);
+        cv::Mat Rcw = Tcw.rowRange(0, 3).colRange(0, 3);
+        cv::Mat tcw = Tcw.rowRange(0, 3).col(3);
+        cv::Mat Rwc = Rcw.t();
+        Ow = -Rwc * tcw;
+
+        Twc = cv::Mat::eye(4, 4, Tcw.type());
+        Rwc.copyTo(Twc.rowRange(0, 3).colRange(0, 3));
+        Ow.copyTo(Twc.rowRange(0, 3).col(3));
+        cv::Mat center = (cv::Mat_<float>(4, 1) << mHalfBaseline, 0, 0, 1);
+        Cw = Twc * center;
+    }
 
-cv::Mat KeyFrame::GetRotation()
-{
-    unique_lock<mutex> lock(mMutexPose);
-    return Tcw.rowRange(0,3).colRange(0,3).clone();
-}
+    cv::Mat KeyFrame::GetPose()
+    {
+        unique_lock<mutex> lock(mMutexPose);
+        return Tcw.clone();
+    }
 
-cv::Mat KeyFrame::GetTranslation()
-{
-    unique_lock<mutex> lock(mMutexPose);
-    return Tcw.rowRange(0,3).col(3).clone();
-}
+    cv::Mat KeyFrame::GetPoseInverse()
+    {
+        unique_lock<mutex> lock(mMutexPose);
+        return Twc.clone();
+    }
 
-void KeyFrame::AddConnection(KeyFrame *pKF, const int &weight)
-{
+    cv::Mat KeyFrame::GetCameraCenter()
     {
-        unique_lock<mutex> lock(mMutexConnections);
-        if(!mConnectedKeyFrameWeights.count(pKF))
-            mConnectedKeyFrameWeights[pKF]=weight;
-        else if(mConnectedKeyFrameWeights[pKF]!=weight)
-            mConnectedKeyFrameWeights[pKF]=weight;
-        else
-            return;
+        unique_lock<mutex> lock(mMutexPose);
+        return Ow.clone();
     }
 
-    UpdateBestCovisibles();
-}
+    cv::Mat KeyFrame::GetStereoCenter()
+    {
+        unique_lock<mutex> lock(mMutexPose);
+        return Cw.clone();
+    }
 
-void KeyFrame::UpdateBestCovisibles()
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    vector<pair<int,KeyFrame*> > vPairs;
-    vPairs.reserve(mConnectedKeyFrameWeights.size());
-    for(map<KeyFrame*,int>::iterator mit=mConnectedKeyFrameWeights.begin(), mend=mConnectedKeyFrameWeights.end(); mit!=mend; mit++)
-       vPairs.push_back(make_pair(mit->second,mit->first));
-
-    sort(vPairs.begin(),vPairs.end());
-    list<KeyFrame*> lKFs;
-    list<int> lWs;
-    for(size_t i=0, iend=vPairs.size(); i<iend;i++)
+    cv::Mat KeyFrame::GetRotation()
     {
-        lKFs.push_front(vPairs[i].second);
-        lWs.push_front(vPairs[i].first);
+        unique_lock<mutex> lock(mMutexPose);
+        return Tcw.rowRange(0, 3).colRange(0, 3).clone();
     }
 
-    mvpOrderedConnectedKeyFrames = vector<KeyFrame*>(lKFs.begin(),lKFs.end());
-    mvOrderedWeights = vector<int>(lWs.begin(), lWs.end());    
-}
+    cv::Mat KeyFrame::GetTranslation()
+    {
+        unique_lock<mutex> lock(mMutexPose);
+        return Tcw.rowRange(0, 3).col(3).clone();
+    }
 
-set<KeyFrame*> KeyFrame::GetConnectedKeyFrames()
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    set<KeyFrame*> s;
-    for(map<KeyFrame*,int>::iterator mit=mConnectedKeyFrameWeights.begin();mit!=mConnectedKeyFrameWeights.end();mit++)
-        s.insert(mit->first);
-    return s;
-}
+    void KeyFrame::AddConnection(KeyFrame *pKF, const int &weight)
+    {
+        {
+            unique_lock<mutex> lock(mMutexConnections);
+            if (!mConnectedKeyFrameWeights.count(pKF))
+                mConnectedKeyFrameWeights[pKF] = weight;
+            else if (mConnectedKeyFrameWeights[pKF] != weight)
+                mConnectedKeyFrameWeights[pKF] = weight;
+            else
+                return;
+        }
 
-vector<KeyFrame*> KeyFrame::GetVectorCovisibleKeyFrames()
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    return mvpOrderedConnectedKeyFrames;
-}
+        UpdateBestCovisibles();
+    }
 
-vector<KeyFrame*> KeyFrame::GetBestCovisibilityKeyFrames(const int &N)
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    if((int)mvpOrderedConnectedKeyFrames.size()<N)
-        return mvpOrderedConnectedKeyFrames;
-    else
-        return vector<KeyFrame*>(mvpOrderedConnectedKeyFrames.begin(),mvpOrderedConnectedKeyFrames.begin()+N);
+    void KeyFrame::UpdateBestCovisibles()
+    {
+        unique_lock<mutex> lock(mMutexConnections);
+        vector<pair<int, KeyFrame *>> vPairs;
+        vPairs.reserve(mConnectedKeyFrameWeights.size());
+        for (map<KeyFrame *, int>::iterator mit = mConnectedKeyFrameWeights.begin(), mend = mConnectedKeyFrameWeights.end(); mit != mend; mit++)
+            vPairs.push_back(make_pair(mit->second, mit->first));
+
+        sort(vPairs.begin(), vPairs.end());
+        list<KeyFrame *> lKFs;
+        list<int> lWs;
+        for (size_t i = 0, iend = vPairs.size(); i < iend; i++)
+        {
+            lKFs.push_front(vPairs[i].second);
+            lWs.push_front(vPairs[i].first);
+        }
 
-}
+        mvpOrderedConnectedKeyFrames = vector<KeyFrame *>(lKFs.begin(), lKFs.end());
+        mvOrderedWeights = vector<int>(lWs.begin(), lWs.end());
+    }
 
-vector<KeyFrame*> KeyFrame::GetCovisiblesByWeight(const int &w)
-{
-    unique_lock<mutex> lock(mMutexConnections);
+    set<KeyFrame *> KeyFrame::GetConnectedKeyFrames()
+    {
+        unique_lock<mutex> lock(mMutexConnections);
+        set<KeyFrame *> s;
+        for (map<KeyFrame *, int>::iterator mit = mConnectedKeyFrameWeights.begin(); mit != mConnectedKeyFrameWeights.end(); mit++)
+            s.insert(mit->first);
+        return s;
+    }
 
-    if(mvpOrderedConnectedKeyFrames.empty())
-        return vector<KeyFrame*>();
+    vector<KeyFrame *> KeyFrame::GetVectorCovisibleKeyFrames()
+    {
+        unique_lock<mutex> lock(mMutexConnections);
+        return mvpOrderedConnectedKeyFrames;
+    }
 
-    vector<int>::iterator it = upper_bound(mvOrderedWeights.begin(),mvOrderedWeights.end(),w,KeyFrame::weightComp);
-    if(it==mvOrderedWeights.end())
-        return vector<KeyFrame*>();
-    else
+    vector<KeyFrame *> KeyFrame::GetBestCovisibilityKeyFrames(const int &N)
     {
-        int n = it-mvOrderedWeights.begin();
-        return vector<KeyFrame*>(mvpOrderedConnectedKeyFrames.begin(), mvpOrderedConnectedKeyFrames.begin()+n);
+        unique_lock<mutex> lock(mMutexConnections);
+        if ((int)mvpOrderedConnectedKeyFrames.size() < N)
+            return mvpOrderedConnectedKeyFrames;
+        else
+            return vector<KeyFrame *>(mvpOrderedConnectedKeyFrames.begin(), mvpOrderedConnectedKeyFrames.begin() + N);
     }
-}
 
-int KeyFrame::GetWeight(KeyFrame *pKF)
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    if(mConnectedKeyFrameWeights.count(pKF))
-        return mConnectedKeyFrameWeights[pKF];
-    else
-        return 0;
-}
+    vector<KeyFrame *> KeyFrame::GetCovisiblesByWeight(const int &w)
+    {
+        unique_lock<mutex> lock(mMutexConnections);
 
-void KeyFrame::AddMapPoint(MapPoint *pMP, const size_t &idx)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    mvpMapPoints[idx]=pMP;
-}
+        if (mvpOrderedConnectedKeyFrames.empty())
+            return vector<KeyFrame *>();
 
-void KeyFrame::EraseMapPointMatch(const size_t &idx)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    mvpMapPoints[idx]=static_cast<MapPoint*>(NULL);
-}
+        vector<int>::iterator it = upper_bound(mvOrderedWeights.begin(), mvOrderedWeights.end(), w, KeyFrame::weightComp);
+        if (it == mvOrderedWeights.end())
+            return vector<KeyFrame *>();
+        else
+        {
+            int n = it - mvOrderedWeights.begin();
+            return vector<KeyFrame *>(mvpOrderedConnectedKeyFrames.begin(), mvpOrderedConnectedKeyFrames.begin() + n);
+        }
+    }
 
-void KeyFrame::EraseMapPointMatch(MapPoint* pMP)
-{
-    int idx = pMP->GetIndexInKeyFrame(this);
-    if(idx>=0)
-        mvpMapPoints[idx]=static_cast<MapPoint*>(NULL);
-}
+    int KeyFrame::GetWeight(KeyFrame *pKF)
+    {
+        unique_lock<mutex> lock(mMutexConnections);
+        if (mConnectedKeyFrameWeights.count(pKF))
+            return mConnectedKeyFrameWeights[pKF];
+        else
+            return 0;
+    }
 
+    void KeyFrame::AddMapPoint(MapPoint *pMP, const size_t &idx)
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        mvpMapPoints[idx] = pMP;
+    }
 
-void KeyFrame::ReplaceMapPointMatch(const size_t &idx, MapPoint* pMP)
-{
-    mvpMapPoints[idx]=pMP;
-}
+    void KeyFrame::EraseMapPointMatch(const size_t &idx)
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        mvpMapPoints[idx] = static_cast<MapPoint *>(NULL);
+    }
 
-set<MapPoint*> KeyFrame::GetMapPoints()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    set<MapPoint*> s;
-    for(size_t i=0, iend=mvpMapPoints.size(); i<iend; i++)
+    void KeyFrame::EraseMapPointMatch(MapPoint *pMP)
     {
-        if(!mvpMapPoints[i])
-            continue;
-        MapPoint* pMP = mvpMapPoints[i];
-        if(!pMP->isBad())
-            s.insert(pMP);
+        int idx = pMP->GetIndexInKeyFrame(this);
+        if (idx >= 0)
+            mvpMapPoints[idx] = static_cast<MapPoint *>(NULL);
     }
-    return s;
-}
 
-int KeyFrame::TrackedMapPoints(const int &minObs)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
+    void KeyFrame::ReplaceMapPointMatch(const size_t &idx, MapPoint *pMP)
+    {
+        mvpMapPoints[idx] = pMP;
+    }
+
+    set<MapPoint *> KeyFrame::GetMapPoints()
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        set<MapPoint *> s;
+        for (size_t i = 0, iend = mvpMapPoints.size(); i < iend; i++)
+        {
+            if (!mvpMapPoints[i])
+                continue;
+            MapPoint *pMP = mvpMapPoints[i];
+            if (!pMP->isBad())
+                s.insert(pMP);
+        }
+        return s;
+    }
 
-    int nPoints=0;
-    const bool bCheckObs = minObs>0;
-    for(int i=0; i<N; i++)
+    int KeyFrame::TrackedMapPoints(const int &minObs)
     {
-        MapPoint* pMP = mvpMapPoints[i];
-        if(pMP)
+        unique_lock<mutex> lock(mMutexFeatures);
+
+        int nPoints = 0;
+        const bool bCheckObs = minObs > 0;
+        for (int i = 0; i < N; i++)
         {
-            if(!pMP->isBad())
+            MapPoint *pMP = mvpMapPoints[i];
+            if (pMP)
             {
-                if(bCheckObs)
+                if (!pMP->isBad())
                 {
-                    if(mvpMapPoints[i]->Observations()>=minObs)
+                    if (bCheckObs)
+                    {
+                        if (mvpMapPoints[i]->Observations() >= minObs)
+                            nPoints++;
+                    }
+                    else
                         nPoints++;
                 }
-                else
-                    nPoints++;
             }
         }
-    }
-
-    return nPoints;
-}
-
-vector<MapPoint*> KeyFrame::GetMapPointMatches()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return mvpMapPoints;
-}
-
-MapPoint* KeyFrame::GetMapPoint(const size_t &idx)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return mvpMapPoints[idx];
-}
 
-void KeyFrame::UpdateConnections()
-{
-    map<KeyFrame*,int> KFcounter;
-
-    vector<MapPoint*> vpMP;
+        return nPoints;
+    }
 
+    vector<MapPoint *> KeyFrame::GetMapPointMatches()
     {
-        unique_lock<mutex> lockMPs(mMutexFeatures);
-        vpMP = mvpMapPoints;
+        unique_lock<mutex> lock(mMutexFeatures);
+        return mvpMapPoints;
     }
 
-    //For all map points in keyframe check in which other keyframes are they seen
-    //Increase counter for those keyframes
-    for(vector<MapPoint*>::iterator vit=vpMP.begin(), vend=vpMP.end(); vit!=vend; vit++)
+    MapPoint *KeyFrame::GetMapPoint(const size_t &idx)
     {
-        MapPoint* pMP = *vit;
+        unique_lock<mutex> lock(mMutexFeatures);
+        return mvpMapPoints[idx];
+    }
 
-        if(!pMP)
-            continue;
+    void KeyFrame::UpdateConnections()
+    {
+        map<KeyFrame *, int> KFcounter;
 
-        if(pMP->isBad())
-            continue;
+        vector<MapPoint *> vpMP;
 
-        map<KeyFrame*,size_t> observations = pMP->GetObservations();
+        {
+            unique_lock<mutex> lockMPs(mMutexFeatures);
+            vpMP = mvpMapPoints;
+        }
 
-        for(map<KeyFrame*,size_t>::iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)
+        // For all map points in keyframe check in which other keyframes are they seen
+        // Increase counter for those keyframes
+        for (vector<MapPoint *>::iterator vit = vpMP.begin(), vend = vpMP.end(); vit != vend; vit++)
         {
-            if(mit->first->mnId==mnId)
+            MapPoint *pMP = *vit;
+
+            if (!pMP)
+                continue;
+
+            if (pMP->isBad())
                 continue;
-            KFcounter[mit->first]++;
+
+            map<KeyFrame *, size_t> observations = pMP->GetObservations();
+
+            for (map<KeyFrame *, size_t>::iterator mit = observations.begin(), mend = observations.end(); mit != mend; mit++)
+            {
+                if (mit->first->mnId == mnId)
+                    continue;
+                KFcounter[mit->first]++;
+            }
         }
-    }
 
-    // This should not happen
-    if(KFcounter.empty())
-        return;
+        // This should not happen
+        if (KFcounter.empty())
+            return;
 
-    //If the counter is greater than threshold add connection
-    //In case no keyframe counter is over threshold add the one with maximum counter
-    int nmax=0;
-    KeyFrame* pKFmax=NULL;
-    int th = 15;
+        // If the counter is greater than threshold add connection
+        // In case no keyframe counter is over threshold add the one with maximum counter
+        int nmax = 0;
+        KeyFrame *pKFmax = NULL;
+        int th = 15;
 
-    vector<pair<int,KeyFrame*> > vPairs;
-    vPairs.reserve(KFcounter.size());
-    for(map<KeyFrame*,int>::iterator mit=KFcounter.begin(), mend=KFcounter.end(); mit!=mend; mit++)
-    {
-        if(mit->second>nmax)
+        vector<pair<int, KeyFrame *>> vPairs;
+        vPairs.reserve(KFcounter.size());
+        for (map<KeyFrame *, int>::iterator mit = KFcounter.begin(), mend = KFcounter.end(); mit != mend; mit++)
+        {
+            if (mit->second > nmax)
+            {
+                nmax = mit->second;
+                pKFmax = mit->first;
+            }
+            if (mit->second >= th)
+            {
+                vPairs.push_back(make_pair(mit->second, mit->first));
+                (mit->first)->AddConnection(this, mit->second);
+            }
+        }
+
+        if (vPairs.empty())
+        {
+            vPairs.push_back(make_pair(nmax, pKFmax));
+            pKFmax->AddConnection(this, nmax);
+        }
+
+        sort(vPairs.begin(), vPairs.end());
+        list<KeyFrame *> lKFs;
+        list<int> lWs;
+        for (size_t i = 0; i < vPairs.size(); i++)
         {
-            nmax=mit->second;
-            pKFmax=mit->first;
+            lKFs.push_front(vPairs[i].second);
+            lWs.push_front(vPairs[i].first);
         }
-        if(mit->second>=th)
+
         {
-            vPairs.push_back(make_pair(mit->second,mit->first));
-            (mit->first)->AddConnection(this,mit->second);
+            unique_lock<mutex> lockCon(mMutexConnections);
+
+            // mspConnectedKeyFrames = spConnectedKeyFrames;
+            mConnectedKeyFrameWeights = KFcounter;
+            mvpOrderedConnectedKeyFrames = vector<KeyFrame *>(lKFs.begin(), lKFs.end());
+            mvOrderedWeights = vector<int>(lWs.begin(), lWs.end());
+
+            if (mbFirstConnection && mnId != 0)
+            {
+                mpParent = mvpOrderedConnectedKeyFrames.front();
+                mpParent->AddChild(this);
+                mbFirstConnection = false;
+            }
         }
     }
 
-    if(vPairs.empty())
+    void KeyFrame::AddChild(KeyFrame *pKF)
     {
-        vPairs.push_back(make_pair(nmax,pKFmax));
-        pKFmax->AddConnection(this,nmax);
+        unique_lock<mutex> lockCon(mMutexConnections);
+        mspChildrens.insert(pKF);
     }
 
-    sort(vPairs.begin(),vPairs.end());
-    list<KeyFrame*> lKFs;
-    list<int> lWs;
-    for(size_t i=0; i<vPairs.size();i++)
+    void KeyFrame::EraseChild(KeyFrame *pKF)
     {
-        lKFs.push_front(vPairs[i].second);
-        lWs.push_front(vPairs[i].first);
+        unique_lock<mutex> lockCon(mMutexConnections);
+        mspChildrens.erase(pKF);
     }
 
+    void KeyFrame::ChangeParent(KeyFrame *pKF)
     {
         unique_lock<mutex> lockCon(mMutexConnections);
-
-        // mspConnectedKeyFrames = spConnectedKeyFrames;
-        mConnectedKeyFrameWeights = KFcounter;
-        mvpOrderedConnectedKeyFrames = vector<KeyFrame*>(lKFs.begin(),lKFs.end());
-        mvOrderedWeights = vector<int>(lWs.begin(), lWs.end());
-
-        if(mbFirstConnection && mnId!=0)
-        {
-            mpParent = mvpOrderedConnectedKeyFrames.front();
-            mpParent->AddChild(this);
-            mbFirstConnection = false;
-        }
-
+        mpParent = pKF;
+        pKF->AddChild(this);
     }
-}
-
-void KeyFrame::AddChild(KeyFrame *pKF)
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    mspChildrens.insert(pKF);
-}
-
-void KeyFrame::EraseChild(KeyFrame *pKF)
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    mspChildrens.erase(pKF);
-}
-
-void KeyFrame::ChangeParent(KeyFrame *pKF)
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    mpParent = pKF;
-    pKF->AddChild(this);
-}
 
-set<KeyFrame*> KeyFrame::GetChilds()
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    return mspChildrens;
-}
-
-KeyFrame* KeyFrame::GetParent()
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    return mpParent;
-}
-
-bool KeyFrame::hasChild(KeyFrame *pKF)
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    return mspChildrens.count(pKF);
-}
-
-void KeyFrame::AddLoopEdge(KeyFrame *pKF)
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    mbNotErase = true;
-    mspLoopEdges.insert(pKF);
-}
+    set<KeyFrame *> KeyFrame::GetChilds()
+    {
+        unique_lock<mutex> lockCon(mMutexConnections);
+        return mspChildrens;
+    }
 
-set<KeyFrame*> KeyFrame::GetLoopEdges()
-{
-    unique_lock<mutex> lockCon(mMutexConnections);
-    return mspLoopEdges;
-}
+    KeyFrame *KeyFrame::GetParent()
+    {
+        unique_lock<mutex> lockCon(mMutexConnections);
+        return mpParent;
+    }
 
-void KeyFrame::SetNotErase()
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    mbNotErase = true;
-}
+    bool KeyFrame::hasChild(KeyFrame *pKF)
+    {
+        unique_lock<mutex> lockCon(mMutexConnections);
+        return mspChildrens.count(pKF);
+    }
 
-void KeyFrame::SetErase()
-{
+    void KeyFrame::AddLoopEdge(KeyFrame *pKF)
     {
-        unique_lock<mutex> lock(mMutexConnections);
-        if(mspLoopEdges.empty())
-        {
-            mbNotErase = false;
-        }
+        unique_lock<mutex> lockCon(mMutexConnections);
+        mbNotErase = true;
+        mspLoopEdges.insert(pKF);
     }
 
-    if(mbToBeErased)
+    set<KeyFrame *> KeyFrame::GetLoopEdges()
     {
-        SetBadFlag();
+        unique_lock<mutex> lockCon(mMutexConnections);
+        return mspLoopEdges;
     }
-}
 
-void KeyFrame::SetBadFlag()
-{   
-  
+    void KeyFrame::SetNotErase()
     {
         unique_lock<mutex> lock(mMutexConnections);
-        if(mnId==0)
-            return;
-        else if(mbNotErase)
+        mbNotErase = true;
+    }
+
+    void KeyFrame::SetErase()
+    {
         {
-            mbToBeErased = true;
-            return;
+            unique_lock<mutex> lock(mMutexConnections);
+            if (mspLoopEdges.empty())
+            {
+                mbNotErase = false;
+            }
         }
-    }
 
-    for(map<KeyFrame*,int>::iterator mit = mConnectedKeyFrameWeights.begin(), mend=mConnectedKeyFrameWeights.end(); mit!=mend; mit++)
-        mit->first->EraseConnection(this);
+        if (mbToBeErased)
+        {
+            SetBadFlag();
+        }
+    }
 
-    for(size_t i=0; i<mvpMapPoints.size(); i++)
-        if(mvpMapPoints[i])
-            mvpMapPoints[i]->EraseObservation(this);
+    void KeyFrame::SetBadFlag()
     {
-        unique_lock<mutex> lock(mMutexConnections);
-        unique_lock<mutex> lock1(mMutexFeatures);
 
-        mConnectedKeyFrameWeights.clear();
-        mvpOrderedConnectedKeyFrames.clear();
+        {
+            unique_lock<mutex> lock(mMutexConnections);
+            if (mnId == 0)
+                return;
+            else if (mbNotErase)
+            {
+                mbToBeErased = true;
+                return;
+            }
+        }
 
-        // Update Spanning Tree
-        set<KeyFrame*> sParentCandidates;
-        if(mpParent)
-            sParentCandidates.insert(mpParent);
+        for (map<KeyFrame *, int>::iterator mit = mConnectedKeyFrameWeights.begin(), mend = mConnectedKeyFrameWeights.end(); mit != mend; mit++)
+            mit->first->EraseConnection(this);
 
-        // Assign at each iteration one children with a parent (the pair with highest covisibility weight)
-        // Include that children as new parent candidate for the rest
-        while(!mspChildrens.empty())
+        for (size_t i = 0; i < mvpMapPoints.size(); i++)
+            if (mvpMapPoints[i])
+                mvpMapPoints[i]->EraseObservation(this);
         {
-            bool bContinue = false;
+            unique_lock<mutex> lock(mMutexConnections);
+            unique_lock<mutex> lock1(mMutexFeatures);
 
-            int max = -1;
-            KeyFrame* pC;
-            KeyFrame* pP;
+            mConnectedKeyFrameWeights.clear();
+            mvpOrderedConnectedKeyFrames.clear();
 
-            for(set<KeyFrame*>::iterator sit=mspChildrens.begin(), send=mspChildrens.end(); sit!=send; sit++)
-            {
+            // Update Spanning Tree
+            set<KeyFrame *> sParentCandidates;
+            if (mpParent)
+                sParentCandidates.insert(mpParent);
 
-                KeyFrame* pKF = *sit;
-                if (!pKF)
-                    continue;
-                if(pKF->isBad())
-                    continue;
-                
+            // Assign at each iteration one children with a parent (the pair with highest covisibility weight)
+            // Include that children as new parent candidate for the rest
+            while (!mspChildrens.empty())
+            {
+                bool bContinue = false;
 
-                // Check if a parent candidate is connected to the keyframe
-                vector<KeyFrame*> vpConnected = pKF->GetVectorCovisibleKeyFrames();
-               
+                int max = -1;
+                KeyFrame *pC;
+                KeyFrame *pP;
 
-                for(size_t i=0, iend=vpConnected.size(); i<iend; i++)
+                for (set<KeyFrame *>::iterator sit = mspChildrens.begin(), send = mspChildrens.end(); sit != send; sit++)
                 {
-                    
 
-                    for(set<KeyFrame*>::iterator spcit=sParentCandidates.begin(), spcend=sParentCandidates.end(); spcit!=spcend; spcit++)
+                    KeyFrame *pKF = *sit;
+                    if (!pKF)
+                        continue;
+                    if (pKF->isBad())
+                        continue;
+
+                    // Check if a parent candidate is connected to the keyframe
+                    vector<KeyFrame *> vpConnected = pKF->GetVectorCovisibleKeyFrames();
+
+                    for (size_t i = 0, iend = vpConnected.size(); i < iend; i++)
                     {
-                        
 
-                        if(vpConnected[i]->mnId == (*spcit)->mnId)
+                        for (set<KeyFrame *>::iterator spcit = sParentCandidates.begin(), spcend = sParentCandidates.end(); spcit != spcend; spcit++)
                         {
-                            
 
-                            int w = pKF->GetWeight(vpConnected[i]);
-                            if(w>max)
+                            if (vpConnected[i]->mnId == (*spcit)->mnId)
                             {
-                                pC = pKF;
-                                pP = vpConnected[i];
-                                max = w;
-                                bContinue = true;
+
+                                int w = pKF->GetWeight(vpConnected[i]);
+                                if (w > max)
+                                {
+                                    pC = pKF;
+                                    pP = vpConnected[i];
+                                    max = w;
+                                    bContinue = true;
+                                }
                             }
                         }
                     }
                 }
-            }
 
-            if(bContinue)
-            {
-                
+                if (bContinue)
+                {
 
-                pC->ChangeParent(pP);
-                sParentCandidates.insert(pC);
-                mspChildrens.erase(pC);
+                    pC->ChangeParent(pP);
+                    sParentCandidates.insert(pC);
+                    mspChildrens.erase(pC);
+                }
+                else
+                    break;
             }
-            else
-                break;
-        }
 
-        // If a children has no covisibility links with any parent candidate, assign to the original parent of this KF
-        if(!mspChildrens.empty())
-            for(set<KeyFrame*>::iterator sit=mspChildrens.begin(); sit!=mspChildrens.end(); sit++)
+            // If a children has no covisibility links with any parent candidate, assign to the original parent of this KF
+            if (!mspChildrens.empty())
+                for (set<KeyFrame *>::iterator sit = mspChildrens.begin(); sit != mspChildrens.end(); sit++)
+                {
+
+                    if (mpParent)
+                        (*sit)->ChangeParent(mpParent);
+                }
+            if (mpParent)
             {
-                
-                if (mpParent)
-                    (*sit)->ChangeParent(mpParent);
+                mpParent->EraseChild(this);
+
+                mTcp = Tcw * mpParent->GetPoseInverse();
             }
-        if (mpParent)
-        {
-            mpParent->EraseChild(this);
-        
-            mTcp = Tcw*mpParent->GetPoseInverse();
+            mbBad = true;
         }
-        mbBad = true;
-    }
 
+        mpMap->EraseKeyFrame(this);
+        mpKeyFrameDB->erase(this);
+    }
 
-    mpMap->EraseKeyFrame(this);
-    mpKeyFrameDB->erase(this);
-}
-
-bool KeyFrame::isBad()
-{
-    unique_lock<mutex> lock(mMutexConnections);
-    return mbBad;
-}
-
-void KeyFrame::EraseConnection(KeyFrame* pKF)
-{
-    bool bUpdate = false;
+    bool KeyFrame::isBad()
     {
         unique_lock<mutex> lock(mMutexConnections);
-        if(mConnectedKeyFrameWeights.count(pKF))
+        return mbBad;
+    }
+
+    void KeyFrame::EraseConnection(KeyFrame *pKF)
+    {
+        bool bUpdate = false;
         {
-            mConnectedKeyFrameWeights.erase(pKF);
-            bUpdate=true;
+            unique_lock<mutex> lock(mMutexConnections);
+            if (mConnectedKeyFrameWeights.count(pKF))
+            {
+                mConnectedKeyFrameWeights.erase(pKF);
+                bUpdate = true;
+            }
         }
+
+        if (bUpdate)
+            UpdateBestCovisibles();
     }
 
-    if(bUpdate)
-        UpdateBestCovisibles();
-}
+    vector<size_t> KeyFrame::GetFeaturesInArea(const float &x, const float &y, const float &r) const
+    {
+        vector<size_t> vIndices;
+        vIndices.reserve(N);
 
-vector<size_t> KeyFrame::GetFeaturesInArea(const float &x, const float &y, const float &r) const
-{
-    vector<size_t> vIndices;
-    vIndices.reserve(N);
+        const int nMinCellX = max(0, (int)floor((x - mnMinX - r) * mfGridElementWidthInv));
+        if (nMinCellX >= mnGridCols)
+            return vIndices;
 
-    const int nMinCellX = max(0,(int)floor((x-mnMinX-r)*mfGridElementWidthInv));
-    if(nMinCellX>=mnGridCols)
-        return vIndices;
+        const int nMaxCellX = min((int)mnGridCols - 1, (int)ceil((x - mnMinX + r) * mfGridElementWidthInv));
+        if (nMaxCellX < 0)
+            return vIndices;
 
-    const int nMaxCellX = min((int)mnGridCols-1,(int)ceil((x-mnMinX+r)*mfGridElementWidthInv));
-    if(nMaxCellX<0)
-        return vIndices;
+        const int nMinCellY = max(0, (int)floor((y - mnMinY - r) * mfGridElementHeightInv));
+        if (nMinCellY >= mnGridRows)
+            return vIndices;
 
-    const int nMinCellY = max(0,(int)floor((y-mnMinY-r)*mfGridElementHeightInv));
-    if(nMinCellY>=mnGridRows)
-        return vIndices;
-
-    const int nMaxCellY = min((int)mnGridRows-1,(int)ceil((y-mnMinY+r)*mfGridElementHeightInv));
-    if(nMaxCellY<0)
-        return vIndices;
+        const int nMaxCellY = min((int)mnGridRows - 1, (int)ceil((y - mnMinY + r) * mfGridElementHeightInv));
+        if (nMaxCellY < 0)
+            return vIndices;
 
-    for(int ix = nMinCellX; ix<=nMaxCellX; ix++)
-    {
-        for(int iy = nMinCellY; iy<=nMaxCellY; iy++)
+        for (int ix = nMinCellX; ix <= nMaxCellX; ix++)
         {
-            const vector<size_t> vCell = mGrid[ix][iy];
-            for(size_t j=0, jend=vCell.size(); j<jend; j++)
+            for (int iy = nMinCellY; iy <= nMaxCellY; iy++)
             {
-                const cv::KeyPoint &kpUn = mvKeysUn[vCell[j]];
-                const float distx = kpUn.pt.x-x;
-                const float disty = kpUn.pt.y-y;
+                const vector<size_t> vCell = mGrid[ix][iy];
+                for (size_t j = 0, jend = vCell.size(); j < jend; j++)
+                {
+                    const cv::KeyPoint &kpUn = mvKeysUn[vCell[j]];
+                    const float distx = kpUn.pt.x - x;
+                    const float disty = kpUn.pt.y - y;
 
-                if(fabs(distx)<r && fabs(disty)<r)
-                    vIndices.push_back(vCell[j]);
+                    if (fabs(distx) < r && fabs(disty) < r)
+                        vIndices.push_back(vCell[j]);
+                }
             }
         }
-    }
 
-    return vIndices;
-}
-
-bool KeyFrame::IsInImage(const float &x, const float &y) const
-{
-    return (x>=mnMinX && x<mnMaxX && y>=mnMinY && y<mnMaxY);
-}
+        return vIndices;
+    }
 
-cv::Mat KeyFrame::UnprojectStereo(int i)
-{
-    const float z = mvDepth[i];
-    if(z>0)
+    bool KeyFrame::IsInImage(const float &x, const float &y) const
     {
-        const float u = mvKeys[i].pt.x;
-        const float v = mvKeys[i].pt.y;
-        const float x = (u-cx)*z*invfx;
-        const float y = (v-cy)*z*invfy;
-        cv::Mat x3Dc = (cv::Mat_<float>(3,1) << x, y, z);
-
-        unique_lock<mutex> lock(mMutexPose);
-        return Twc.rowRange(0,3).colRange(0,3)*x3Dc+Twc.rowRange(0,3).col(3);
+        return (x >= mnMinX && x < mnMaxX && y >= mnMinY && y < mnMaxY);
     }
-    else
-        return cv::Mat();
-}
 
-float KeyFrame::ComputeSceneMedianDepth(const int q)
-{
-    vector<MapPoint*> vpMapPoints;
-    cv::Mat Tcw_;
+    cv::Mat KeyFrame::UnprojectStereo(int i)
     {
-        unique_lock<mutex> lock(mMutexFeatures);
-        unique_lock<mutex> lock2(mMutexPose);
-        vpMapPoints = mvpMapPoints;
-        Tcw_ = Tcw.clone();
+        const float z = mvDepth[i];
+        if (z > 0)
+        {
+            const float u = mvKeys[i].pt.x;
+            const float v = mvKeys[i].pt.y;
+            const float x = (u - cx) * z * invfx;
+            const float y = (v - cy) * z * invfy;
+            cv::Mat x3Dc = (cv::Mat_<float>(3, 1) << x, y, z);
+
+            unique_lock<mutex> lock(mMutexPose);
+            return Twc.rowRange(0, 3).colRange(0, 3) * x3Dc + Twc.rowRange(0, 3).col(3);
+        }
+        else
+            return cv::Mat();
     }
 
-    vector<float> vDepths;
-    vDepths.reserve(N);
-    cv::Mat Rcw2 = Tcw_.row(2).colRange(0,3);
-    Rcw2 = Rcw2.t();
-    float zcw = Tcw_.at<float>(2,3);
-    for(int i=0; i<N; i++)
+    float KeyFrame::ComputeSceneMedianDepth(const int q)
     {
-        if(mvpMapPoints[i])
+        vector<MapPoint *> vpMapPoints;
+        cv::Mat Tcw_;
         {
-            MapPoint* pMP = mvpMapPoints[i];
-            cv::Mat x3Dw = pMP->GetWorldPos();
-            float z = Rcw2.dot(x3Dw)+zcw;
-            vDepths.push_back(z);
+            unique_lock<mutex> lock(mMutexFeatures);
+            unique_lock<mutex> lock2(mMutexPose);
+            vpMapPoints = mvpMapPoints;
+            Tcw_ = Tcw.clone();
         }
-    }
 
-    sort(vDepths.begin(),vDepths.end());
+        vector<float> vDepths;
+        vDepths.reserve(N);
+        cv::Mat Rcw2 = Tcw_.row(2).colRange(0, 3);
+        Rcw2 = Rcw2.t();
+        float zcw = Tcw_.at<float>(2, 3);
+        for (int i = 0; i < N; i++)
+        {
+            if (mvpMapPoints[i])
+            {
+                MapPoint *pMP = mvpMapPoints[i];
+                cv::Mat x3Dw = pMP->GetWorldPos();
+                float z = Rcw2.dot(x3Dw) + zcw;
+                vDepths.push_back(z);
+            }
+        }
 
-    return vDepths[(vDepths.size()-1)/q];
-}
+        sort(vDepths.begin(), vDepths.end());
 
-void KeyFrame::rpi_save(const std::string& file_name)
-{
-    RaspberryKeyFrame* rpi_kf = new RaspberryKeyFrame(*this);
-    {
-    std::ofstream os(file_name);
-    boost::archive::text_oarchive oa(os);
-    //oa << mpKeyFrameDatabase;
-    oa << rpi_kf;
+        return vDepths[(vDepths.size() - 1) / q];
     }
 
-    delete rpi_kf;
-}
-
-void KeyFrame::align(const cv::Mat& R_align, const cv::Mat& mu_align)
-{
-    auto pose = GetPose();
-    cv::Mat Rwc = pose.rowRange(0, 3).colRange(0, 3).clone().t();
-    cv::Mat tcw = pose.rowRange(0, 3).col(3).clone();
+    void KeyFrame::align(const cv::Mat &R_align, const cv::Mat &mu_align)
+    {
+        auto pose = GetPose();
+        cv::Mat Rwc = pose.rowRange(0, 3).colRange(0, 3).clone().t();
+        cv::Mat tcw = pose.rowRange(0, 3).col(3).clone();
 
-    cv::Mat twc = -Rwc*tcw;
+        cv::Mat twc = -Rwc * tcw;
 
-    cv::Mat aligned_Rwc = R_align * Rwc;
-    cv::Mat aligned_twc = R_align * (twc - mu_align);
+        cv::Mat aligned_Rwc = R_align * Rwc;
+        cv::Mat aligned_twc = R_align * (twc - mu_align);
 
-    cv::Mat align_pose;
+        cv::Mat align_pose;
 
-    align_pose = cv::Mat::eye(4,4,CV_32F);
+        align_pose = cv::Mat::eye(4, 4, CV_32F);
 
-    cv::Mat aligned_Rcw = aligned_Rwc.t();
-    cv::Mat aligned_tcw = -aligned_Rcw * aligned_twc;
-    aligned_Rcw.copyTo(align_pose.rowRange(0,3).colRange(0,3));
-    aligned_tcw.copyTo(align_pose.rowRange(0,3).col(3));
+        cv::Mat aligned_Rcw = aligned_Rwc.t();
+        cv::Mat aligned_tcw = -aligned_Rcw * aligned_twc;
+        aligned_Rcw.copyTo(align_pose.rowRange(0, 3).colRange(0, 3));
+        aligned_tcw.copyTo(align_pose.rowRange(0, 3).col(3));
 
-    SetPose(align_pose);
-}
+        SetPose(align_pose);
+    }
 
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/KeyFrameDatabase.cc b/slam/src/KeyFrameDatabase.cc
index 49ed843..9a3227e 100644
--- a/slam/src/KeyFrameDatabase.cc
+++ b/slam/src/KeyFrameDatabase.cc
@@ -21,7 +21,7 @@
 #include "KeyFrameDatabase.h"
 
 #include "KeyFrame.h"
-#include "../Thirdparty/DBoW2/DBoW2/BowVector.h"
+#include "DBoW2/BowVector.h"
 
 #include<mutex>
 
diff --git a/slam/src/LocalMapping.cc b/slam/src/LocalMapping.cc
index c41aa97..832ada5 100644
--- a/slam/src/LocalMapping.cc
+++ b/slam/src/LocalMapping.cc
@@ -1,796 +1,788 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "LocalMapping.h"
 #include "LoopClosing.h"
 #include "ORBmatcher.h"
 #include "Optimizer.h"
 
-#include<mutex>
+#include <mutex>
 
 namespace ORB_SLAM2
 {
 
-LocalMapping::LocalMapping(Map *pMap, const float bMonocular):
-    mbMonocular(bMonocular), mbResetRequested(false), mbFinishRequested(false), mbFinished(true), mpMap(pMap),
-    mbAbortBA(false), mbStopped(false), mbStopRequested(false), mbNotStop(false), mbAcceptKeyFrames(true)
-{
-}
+    LocalMapping::LocalMapping(Map *pMap, const float bMonocular) : mbMonocular(bMonocular), mbResetRequested(false), mbFinishRequested(false), mbFinished(true), mpMap(pMap),
+                                                                    mbAbortBA(false), mbStopped(false), mbStopRequested(false), mbNotStop(false), mbAcceptKeyFrames(true)
+    {
+    }
 
-void LocalMapping::SetLoopCloser(LoopClosing* pLoopCloser)
-{
-    mpLoopCloser = pLoopCloser;
-}
+    void LocalMapping::SetLoopCloser(LoopClosing *pLoopCloser)
+    {
+        mpLoopCloser = pLoopCloser;
+    }
 
-void LocalMapping::SetTracker(Tracking *pTracker)
-{
-    mpTracker=pTracker;
-}
+    void LocalMapping::SetTracker(Tracking *pTracker)
+    {
+        mpTracker = pTracker;
+    }
 
-std::chrono::steady_clock::time_point get_time2()
-{
-    return std::chrono::steady_clock::now();
-}
+    std::chrono::steady_clock::time_point get_time2()
+    {
+        return std::chrono::steady_clock::now();
+    }
 
-unsigned int get_time_diff2(std::chrono::steady_clock::time_point start, std::chrono::steady_clock::time_point end)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
-}
+    unsigned int get_time_diff2(std::chrono::steady_clock::time_point start, std::chrono::steady_clock::time_point end)
+    {
+        return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
+    }
 
+    void LocalMapping::Run()
+    {
 
-void LocalMapping::Run()
-{
+        mbFinished = false;
 
-    mbFinished = false;
+        while (1)
+        {
+            // Tracking will see that Local Mapping is busy
+            SetAcceptKeyFrames(false);
 
-    while(1)
-    {
-        // Tracking will see that Local Mapping is busy
-        SetAcceptKeyFrames(false);
+            // Check if there are keyframes in the queue
+            if (CheckNewKeyFrames())
+            {
+                // BoW conversion and insertion in Map
+                ProcessNewKeyFrame();
 
-        // Check if there are keyframes in the queue
-        if(CheckNewKeyFrames())
-        {
-            // BoW conversion and insertion in Map
-            ProcessNewKeyFrame();
+                // Check recent MapPoints
+                // BAR
+                MapPointCulling();
 
-            // Check recent MapPoints
-            //BAR
-            MapPointCulling();
+                // Triangulate new MapPoints
+                CreateNewMapPoints();
 
-            // Triangulate new MapPoints
-            CreateNewMapPoints();
+                if (!CheckNewKeyFrames())
+                {
+                    // Find more matches in neighbor keyframes and fuse point duplications
+                    // BAR
+                    SearchInNeighbors();
+                }
 
-            if(!CheckNewKeyFrames())
-            {
-                // Find more matches in neighbor keyframes and fuse point duplications
-                //BAR
-                SearchInNeighbors();
-            }
+                mbAbortBA = false;
 
-            mbAbortBA = false;
+                if (!CheckNewKeyFrames() && !stopRequested())
+                {
+                    // Local BA
+
+                    // BAR
+                    auto start = get_time2();
+                    if (mpMap->KeyFramesInMap() > 2)
+                        Optimizer::LocalBundleAdjustment(mpCurrentKeyFrame, &mbAbortBA, mpMap);
+                    auto end = get_time2();
+                    // std::cout << "Bundle Adjustment time: " << get_time_diff2(start, end) << std::endl;
+
+                    // Check redundant local Keyframes
+                    // BAR
+                    KeyFrameCulling();
+                }
 
-            if(!CheckNewKeyFrames() && !stopRequested())
-            {
-                // Local BA
-                
-                //BAR
-                auto start = get_time2();
-                if(mpMap->KeyFramesInMap()>2)
-                    Optimizer::LocalBundleAdjustment(mpCurrentKeyFrame,&mbAbortBA, mpMap);
-                auto end = get_time2();
-                //std::cout << "Bundle Adjustment time: " << get_time_diff2(start, end) << std::endl;
-                
-                
-                // Check redundant local Keyframes
-                //BAR
-                KeyFrameCulling();
+                mpLoopCloser->InsertKeyFrame(mpCurrentKeyFrame);
             }
-
-            mpLoopCloser->InsertKeyFrame(mpCurrentKeyFrame);
-        }
-        else if(Stop())
-        {
-            // Safe area to stop
-            while(isStopped() && !CheckFinish())
+            else if (Stop())
             {
-                usleep(5000);
+                // Safe area to stop
+                while (isStopped() && !CheckFinish())
+                {
+                    Sleep(5);
+                }
+                if (CheckFinish())
+                    break;
             }
-            if(CheckFinish())
-                break;
-        }
-
-        ResetIfRequested();
 
-        // Tracking will see that Local Mapping is busy
-        SetAcceptKeyFrames(true);
+            ResetIfRequested();
 
-        if(CheckFinish())
-            break;
+            // Tracking will see that Local Mapping is busy
+            SetAcceptKeyFrames(true);
 
-        usleep(3000);
-    }
-
-    SetFinish();
-}
+            if (CheckFinish())
+                break;
 
-void LocalMapping::InsertKeyFrame(KeyFrame *pKF)
-{
-    unique_lock<mutex> lock(mMutexNewKFs);
-    mlNewKeyFrames.push_back(pKF);
-    mbAbortBA=true;
-}
+            Sleep(3);
+        }
 
+        SetFinish();
+    }
 
-bool LocalMapping::CheckNewKeyFrames()
-{
-    unique_lock<mutex> lock(mMutexNewKFs);
-    return(!mlNewKeyFrames.empty());
-}
+    void LocalMapping::InsertKeyFrame(KeyFrame *pKF)
+    {
+        unique_lock<mutex> lock(mMutexNewKFs);
+        mlNewKeyFrames.push_back(pKF);
+        mbAbortBA = true;
+    }
 
-void LocalMapping::ProcessNewKeyFrame()
-{
+    bool LocalMapping::CheckNewKeyFrames()
     {
         unique_lock<mutex> lock(mMutexNewKFs);
-        mpCurrentKeyFrame = mlNewKeyFrames.front();
-        mlNewKeyFrames.pop_front();
+        return (!mlNewKeyFrames.empty());
     }
 
-    // Compute Bags of Words structures
-    mpCurrentKeyFrame->ComputeBoW();
+    void LocalMapping::ProcessNewKeyFrame()
+    {
+        {
+            unique_lock<mutex> lock(mMutexNewKFs);
+            mpCurrentKeyFrame = mlNewKeyFrames.front();
+            mlNewKeyFrames.pop_front();
+        }
 
-    // Associate MapPoints to the new keyframe and update normal and descriptor
-    const vector<MapPoint*> vpMapPointMatches = mpCurrentKeyFrame->GetMapPointMatches();
+        // Compute Bags of Words structures
+        mpCurrentKeyFrame->ComputeBoW();
 
-    for(size_t i=0; i<vpMapPointMatches.size(); i++)
-    {
-        MapPoint* pMP = vpMapPointMatches[i];
-        if(pMP)
+        // Associate MapPoints to the new keyframe and update normal and descriptor
+        const vector<MapPoint *> vpMapPointMatches = mpCurrentKeyFrame->GetMapPointMatches();
+
+        for (size_t i = 0; i < vpMapPointMatches.size(); i++)
         {
-            if(!pMP->isBad())
+            MapPoint *pMP = vpMapPointMatches[i];
+            if (pMP)
             {
-                if(!pMP->IsInKeyFrame(mpCurrentKeyFrame))
-                {
-                    pMP->AddObservation(mpCurrentKeyFrame, i);
-                    pMP->UpdateNormalAndDepth();
-                    pMP->ComputeDistinctiveDescriptors();
-                }
-                else // this can only happen for new stereo points inserted by the Tracking
+                if (!pMP->isBad())
                 {
-                    mlpRecentAddedMapPoints.push_back(pMP);
+                    if (!pMP->IsInKeyFrame(mpCurrentKeyFrame))
+                    {
+                        pMP->AddObservation(mpCurrentKeyFrame, i);
+                        pMP->UpdateNormalAndDepth();
+                        pMP->ComputeDistinctiveDescriptors();
+                    }
+                    else // this can only happen for new stereo points inserted by the Tracking
+                    {
+                        mlpRecentAddedMapPoints.push_back(pMP);
+                    }
                 }
             }
         }
-    }    
 
-    // Update links in the Covisibility Graph
-    mpCurrentKeyFrame->UpdateConnections();
+        // Update links in the Covisibility Graph
+        mpCurrentKeyFrame->UpdateConnections();
 
-    // Insert Keyframe in Map
-    mpMap->AddKeyFrame(mpCurrentKeyFrame);
-}
-
-void LocalMapping::MapPointCulling()
-{
-    // Check Recent Added MapPoints
-    list<MapPoint*>::iterator lit = mlpRecentAddedMapPoints.begin();
-    const unsigned long int nCurrentKFid = mpCurrentKeyFrame->mnId;
-
-    int nThObs;
-    if(mbMonocular)
-        nThObs = 2;
-    else
-        nThObs = 3;
-    const int cnThObs = nThObs;
-
-    while(lit!=mlpRecentAddedMapPoints.end())
-    {
-        MapPoint* pMP = *lit;
-        if(pMP->isBad())
-        {
-            lit = mlpRecentAddedMapPoints.erase(lit);
-        }
-        else if(pMP->GetFoundRatio()<0.25f )
-        {
-            pMP->SetBadFlag();
-            lit = mlpRecentAddedMapPoints.erase(lit);
-        }
-        else if(((int)nCurrentKFid-(int)pMP->mnFirstKFid)>=2 && pMP->Observations()<=cnThObs)
-        {
-            pMP->SetBadFlag();
-            lit = mlpRecentAddedMapPoints.erase(lit);
-        }
-        else if(((int)nCurrentKFid-(int)pMP->mnFirstKFid)>=3)
-            lit = mlpRecentAddedMapPoints.erase(lit);
-        else
-            lit++;
+        // Insert Keyframe in Map
+        mpMap->AddKeyFrame(mpCurrentKeyFrame);
     }
-}
 
-void LocalMapping::CreateNewMapPoints()
-{
-    // Retrieve neighbor keyframes in covisibility graph
-    int nn = 10;
-    if(mbMonocular)
-        nn=20;
-    const vector<KeyFrame*> vpNeighKFs = mpCurrentKeyFrame->GetBestCovisibilityKeyFrames(nn);
-
-    ORBmatcher matcher(0.6,false);
-
-    cv::Mat Rcw1 = mpCurrentKeyFrame->GetRotation();
-    cv::Mat Rwc1 = Rcw1.t();
-    cv::Mat tcw1 = mpCurrentKeyFrame->GetTranslation();
-    cv::Mat Tcw1(3,4,CV_32F);
-    Rcw1.copyTo(Tcw1.colRange(0,3));
-    tcw1.copyTo(Tcw1.col(3));
-    cv::Mat Ow1 = mpCurrentKeyFrame->GetCameraCenter();
-
-    const float &fx1 = mpCurrentKeyFrame->fx;
-    const float &fy1 = mpCurrentKeyFrame->fy;
-    const float &cx1 = mpCurrentKeyFrame->cx;
-    const float &cy1 = mpCurrentKeyFrame->cy;
-    const float &invfx1 = mpCurrentKeyFrame->invfx;
-    const float &invfy1 = mpCurrentKeyFrame->invfy;
-
-    const float ratioFactor = 1.5f*mpCurrentKeyFrame->mfScaleFactor;
-
-    int nnew=0;
-
-    // Search matches with epipolar restriction and triangulate
-    for(size_t i=0; i<vpNeighKFs.size(); i++)
+    void LocalMapping::MapPointCulling()
     {
-        if(i>0 && CheckNewKeyFrames())
-            return;
-
-        KeyFrame* pKF2 = vpNeighKFs[i];
+        // Check Recent Added MapPoints
+        list<MapPoint *>::iterator lit = mlpRecentAddedMapPoints.begin();
+        const unsigned long int nCurrentKFid = mpCurrentKeyFrame->mnId;
 
-        // Check first that baseline is not too short
-        cv::Mat Ow2 = pKF2->GetCameraCenter();
-        cv::Mat vBaseline = Ow2-Ow1;
-        const float baseline = cv::norm(vBaseline);
-
-        if(!mbMonocular)
-        {
-            if(baseline<pKF2->mb)
-            continue;
-        }
+        int nThObs;
+        if (mbMonocular)
+            nThObs = 2;
         else
-        {
-            const float medianDepthKF2 = pKF2->ComputeSceneMedianDepth(2);
-            const float ratioBaselineDepth = baseline/medianDepthKF2;
+            nThObs = 3;
+        const int cnThObs = nThObs;
 
-            if(ratioBaselineDepth<0.01)
-                continue;
+        while (lit != mlpRecentAddedMapPoints.end())
+        {
+            MapPoint *pMP = *lit;
+            if (pMP->isBad())
+            {
+                lit = mlpRecentAddedMapPoints.erase(lit);
+            }
+            else if (pMP->GetFoundRatio() < 0.25f)
+            {
+                pMP->SetBadFlag();
+                lit = mlpRecentAddedMapPoints.erase(lit);
+            }
+            else if (((int)nCurrentKFid - (int)pMP->mnFirstKFid) >= 2 && pMP->Observations() <= cnThObs)
+            {
+                pMP->SetBadFlag();
+                lit = mlpRecentAddedMapPoints.erase(lit);
+            }
+            else if (((int)nCurrentKFid - (int)pMP->mnFirstKFid) >= 3)
+                lit = mlpRecentAddedMapPoints.erase(lit);
+            else
+                lit++;
         }
+    }
 
-        // Compute Fundamental Matrix
-        cv::Mat F12 = ComputeF12(mpCurrentKeyFrame,pKF2);
-
-        // Search matches that fullfil epipolar constraint
-        vector<pair<size_t,size_t> > vMatchedIndices;
-        matcher.SearchForTriangulation(mpCurrentKeyFrame,pKF2,F12,vMatchedIndices,false);
-
-        cv::Mat Rcw2 = pKF2->GetRotation();
-        cv::Mat Rwc2 = Rcw2.t();
-        cv::Mat tcw2 = pKF2->GetTranslation();
-        cv::Mat Tcw2(3,4,CV_32F);
-        Rcw2.copyTo(Tcw2.colRange(0,3));
-        tcw2.copyTo(Tcw2.col(3));
-
-        const float &fx2 = pKF2->fx;
-        const float &fy2 = pKF2->fy;
-        const float &cx2 = pKF2->cx;
-        const float &cy2 = pKF2->cy;
-        const float &invfx2 = pKF2->invfx;
-        const float &invfy2 = pKF2->invfy;
-
-        // Triangulate each match
-        const int nmatches = vMatchedIndices.size();
-        for(int ikp=0; ikp<nmatches; ikp++)
+    void LocalMapping::CreateNewMapPoints()
+    {
+        // Retrieve neighbor keyframes in covisibility graph
+        int nn = 10;
+        if (mbMonocular)
+            nn = 20;
+        const vector<KeyFrame *> vpNeighKFs = mpCurrentKeyFrame->GetBestCovisibilityKeyFrames(nn);
+
+        ORBmatcher matcher(0.6, false);
+
+        cv::Mat Rcw1 = mpCurrentKeyFrame->GetRotation();
+        cv::Mat Rwc1 = Rcw1.t();
+        cv::Mat tcw1 = mpCurrentKeyFrame->GetTranslation();
+        cv::Mat Tcw1(3, 4, CV_32F);
+        Rcw1.copyTo(Tcw1.colRange(0, 3));
+        tcw1.copyTo(Tcw1.col(3));
+        cv::Mat Ow1 = mpCurrentKeyFrame->GetCameraCenter();
+
+        const float &fx1 = mpCurrentKeyFrame->fx;
+        const float &fy1 = mpCurrentKeyFrame->fy;
+        const float &cx1 = mpCurrentKeyFrame->cx;
+        const float &cy1 = mpCurrentKeyFrame->cy;
+        const float &invfx1 = mpCurrentKeyFrame->invfx;
+        const float &invfy1 = mpCurrentKeyFrame->invfy;
+
+        const float ratioFactor = 1.5f * mpCurrentKeyFrame->mfScaleFactor;
+
+        int nnew = 0;
+
+        // Search matches with epipolar restriction and triangulate
+        for (size_t i = 0; i < vpNeighKFs.size(); i++)
         {
-            const int &idx1 = vMatchedIndices[ikp].first;
-            const int &idx2 = vMatchedIndices[ikp].second;
+            if (i > 0 && CheckNewKeyFrames())
+                return;
+
+            KeyFrame *pKF2 = vpNeighKFs[i];
 
-            const cv::KeyPoint &kp1 = mpCurrentKeyFrame->mvKeysUn[idx1];
-            const float kp1_ur=mpCurrentKeyFrame->mvuRight[idx1];
-            bool bStereo1 = kp1_ur>=0;
+            // Check first that baseline is not too short
+            cv::Mat Ow2 = pKF2->GetCameraCenter();
+            cv::Mat vBaseline = Ow2 - Ow1;
+            const float baseline = cv::norm(vBaseline);
 
-            const cv::KeyPoint &kp2 = pKF2->mvKeysUn[idx2];
-            const float kp2_ur = pKF2->mvuRight[idx2];
-            bool bStereo2 = kp2_ur>=0;
+            if (!mbMonocular)
+            {
+                if (baseline < pKF2->mb)
+                    continue;
+            }
+            else
+            {
+                const float medianDepthKF2 = pKF2->ComputeSceneMedianDepth(2);
+                const float ratioBaselineDepth = baseline / medianDepthKF2;
 
-            // Check parallax between rays
-            cv::Mat xn1 = (cv::Mat_<float>(3,1) << (kp1.pt.x-cx1)*invfx1, (kp1.pt.y-cy1)*invfy1, 1.0);
-            cv::Mat xn2 = (cv::Mat_<float>(3,1) << (kp2.pt.x-cx2)*invfx2, (kp2.pt.y-cy2)*invfy2, 1.0);
+                if (ratioBaselineDepth < 0.01)
+                    continue;
+            }
 
-            cv::Mat ray1 = Rwc1*xn1;
-            cv::Mat ray2 = Rwc2*xn2;
-            const float cosParallaxRays = ray1.dot(ray2)/(cv::norm(ray1)*cv::norm(ray2));
+            // Compute Fundamental Matrix
+            cv::Mat F12 = ComputeF12(mpCurrentKeyFrame, pKF2);
+
+            // Search matches that fullfil epipolar constraint
+            vector<pair<size_t, size_t>> vMatchedIndices;
+            matcher.SearchForTriangulation(mpCurrentKeyFrame, pKF2, F12, vMatchedIndices, false);
+
+            cv::Mat Rcw2 = pKF2->GetRotation();
+            cv::Mat Rwc2 = Rcw2.t();
+            cv::Mat tcw2 = pKF2->GetTranslation();
+            cv::Mat Tcw2(3, 4, CV_32F);
+            Rcw2.copyTo(Tcw2.colRange(0, 3));
+            tcw2.copyTo(Tcw2.col(3));
+
+            const float &fx2 = pKF2->fx;
+            const float &fy2 = pKF2->fy;
+            const float &cx2 = pKF2->cx;
+            const float &cy2 = pKF2->cy;
+            const float &invfx2 = pKF2->invfx;
+            const float &invfy2 = pKF2->invfy;
+
+            // Triangulate each match
+            const int nmatches = vMatchedIndices.size();
+            for (int ikp = 0; ikp < nmatches; ikp++)
+            {
+                const int &idx1 = vMatchedIndices[ikp].first;
+                const int &idx2 = vMatchedIndices[ikp].second;
 
-            float cosParallaxStereo = cosParallaxRays+1;
-            float cosParallaxStereo1 = cosParallaxStereo;
-            float cosParallaxStereo2 = cosParallaxStereo;
+                const cv::KeyPoint &kp1 = mpCurrentKeyFrame->mvKeysUn[idx1];
+                const float kp1_ur = mpCurrentKeyFrame->mvuRight[idx1];
+                bool bStereo1 = kp1_ur >= 0;
 
-            if(bStereo1)
-                cosParallaxStereo1 = cos(2*atan2(mpCurrentKeyFrame->mb/2,mpCurrentKeyFrame->mvDepth[idx1]));
-            else if(bStereo2)
-                cosParallaxStereo2 = cos(2*atan2(pKF2->mb/2,pKF2->mvDepth[idx2]));
+                const cv::KeyPoint &kp2 = pKF2->mvKeysUn[idx2];
+                const float kp2_ur = pKF2->mvuRight[idx2];
+                bool bStereo2 = kp2_ur >= 0;
 
-            cosParallaxStereo = min(cosParallaxStereo1,cosParallaxStereo2);
+                // Check parallax between rays
+                cv::Mat xn1 = (cv::Mat_<float>(3, 1) << (kp1.pt.x - cx1) * invfx1, (kp1.pt.y - cy1) * invfy1, 1.0);
+                cv::Mat xn2 = (cv::Mat_<float>(3, 1) << (kp2.pt.x - cx2) * invfx2, (kp2.pt.y - cy2) * invfy2, 1.0);
 
-            cv::Mat x3D;
-            if(cosParallaxRays<cosParallaxStereo && cosParallaxRays>0 && (bStereo1 || bStereo2 || cosParallaxRays<0.9998))
-            {
-                // Linear Triangulation Method
-                cv::Mat A(4,4,CV_32F);
-                A.row(0) = xn1.at<float>(0)*Tcw1.row(2)-Tcw1.row(0);
-                A.row(1) = xn1.at<float>(1)*Tcw1.row(2)-Tcw1.row(1);
-                A.row(2) = xn2.at<float>(0)*Tcw2.row(2)-Tcw2.row(0);
-                A.row(3) = xn2.at<float>(1)*Tcw2.row(2)-Tcw2.row(1);
+                cv::Mat ray1 = Rwc1 * xn1;
+                cv::Mat ray2 = Rwc2 * xn2;
+                const float cosParallaxRays = ray1.dot(ray2) / (cv::norm(ray1) * cv::norm(ray2));
 
-                cv::Mat w,u,vt;
-                cv::SVD::compute(A,w,u,vt,cv::SVD::MODIFY_A| cv::SVD::FULL_UV);
+                float cosParallaxStereo = cosParallaxRays + 1;
+                float cosParallaxStereo1 = cosParallaxStereo;
+                float cosParallaxStereo2 = cosParallaxStereo;
 
-                x3D = vt.row(3).t();
+                if (bStereo1)
+                    cosParallaxStereo1 = cos(2 * atan2(mpCurrentKeyFrame->mb / 2, mpCurrentKeyFrame->mvDepth[idx1]));
+                else if (bStereo2)
+                    cosParallaxStereo2 = cos(2 * atan2(pKF2->mb / 2, pKF2->mvDepth[idx2]));
 
-                if(x3D.at<float>(3)==0)
-                    continue;
+                cosParallaxStereo = min(cosParallaxStereo1, cosParallaxStereo2);
 
-                // Euclidean coordinates
-                x3D = x3D.rowRange(0,3)/x3D.at<float>(3);
+                cv::Mat x3D;
+                if (cosParallaxRays < cosParallaxStereo && cosParallaxRays > 0 && (bStereo1 || bStereo2 || cosParallaxRays < 0.9998))
+                {
+                    // Linear Triangulation Method
+                    cv::Mat A(4, 4, CV_32F);
+                    A.row(0) = xn1.at<float>(0) * Tcw1.row(2) - Tcw1.row(0);
+                    A.row(1) = xn1.at<float>(1) * Tcw1.row(2) - Tcw1.row(1);
+                    A.row(2) = xn2.at<float>(0) * Tcw2.row(2) - Tcw2.row(0);
+                    A.row(3) = xn2.at<float>(1) * Tcw2.row(2) - Tcw2.row(1);
 
-            }
-            else if(bStereo1 && cosParallaxStereo1<cosParallaxStereo2)
-            {
-                x3D = mpCurrentKeyFrame->UnprojectStereo(idx1);                
-            }
-            else if(bStereo2 && cosParallaxStereo2<cosParallaxStereo1)
-            {
-                x3D = pKF2->UnprojectStereo(idx2);
-            }
-            else
-                continue; //No stereo and very low parallax
+                    cv::Mat w, u, vt;
+                    cv::SVD::compute(A, w, u, vt, cv::SVD::MODIFY_A | cv::SVD::FULL_UV);
 
-            cv::Mat x3Dt = x3D.t();
+                    x3D = vt.row(3).t();
 
-            //Check triangulation in front of cameras
-            float z1 = Rcw1.row(2).dot(x3Dt)+tcw1.at<float>(2);
-            if(z1<=0)
-                continue;
+                    if (x3D.at<float>(3) == 0)
+                        continue;
 
-            float z2 = Rcw2.row(2).dot(x3Dt)+tcw2.at<float>(2);
-            if(z2<=0)
-                continue;
+                    // Euclidean coordinates
+                    x3D = x3D.rowRange(0, 3) / x3D.at<float>(3);
+                }
+                else if (bStereo1 && cosParallaxStereo1 < cosParallaxStereo2)
+                {
+                    x3D = mpCurrentKeyFrame->UnprojectStereo(idx1);
+                }
+                else if (bStereo2 && cosParallaxStereo2 < cosParallaxStereo1)
+                {
+                    x3D = pKF2->UnprojectStereo(idx2);
+                }
+                else
+                    continue; // No stereo and very low parallax
 
-            //Check reprojection error in first keyframe
-            const float &sigmaSquare1 = mpCurrentKeyFrame->mvLevelSigma2[kp1.octave];
-            const float x1 = Rcw1.row(0).dot(x3Dt)+tcw1.at<float>(0);
-            const float y1 = Rcw1.row(1).dot(x3Dt)+tcw1.at<float>(1);
-            const float invz1 = 1.0/z1;
+                cv::Mat x3Dt = x3D.t();
 
-            if(!bStereo1)
-            {
-                float u1 = fx1*x1*invz1+cx1;
-                float v1 = fy1*y1*invz1+cy1;
-                float errX1 = u1 - kp1.pt.x;
-                float errY1 = v1 - kp1.pt.y;
-                if((errX1*errX1+errY1*errY1)>5.991*sigmaSquare1)
-                    continue;
-            }
-            else
-            {
-                float u1 = fx1*x1*invz1+cx1;
-                float u1_r = u1 - mpCurrentKeyFrame->mbf*invz1;
-                float v1 = fy1*y1*invz1+cy1;
-                float errX1 = u1 - kp1.pt.x;
-                float errY1 = v1 - kp1.pt.y;
-                float errX1_r = u1_r - kp1_ur;
-                if((errX1*errX1+errY1*errY1+errX1_r*errX1_r)>7.8*sigmaSquare1)
+                // Check triangulation in front of cameras
+                float z1 = Rcw1.row(2).dot(x3Dt) + tcw1.at<float>(2);
+                if (z1 <= 0)
                     continue;
-            }
 
-            //Check reprojection error in second keyframe
-            const float sigmaSquare2 = pKF2->mvLevelSigma2[kp2.octave];
-            const float x2 = Rcw2.row(0).dot(x3Dt)+tcw2.at<float>(0);
-            const float y2 = Rcw2.row(1).dot(x3Dt)+tcw2.at<float>(1);
-            const float invz2 = 1.0/z2;
-            if(!bStereo2)
-            {
-                float u2 = fx2*x2*invz2+cx2;
-                float v2 = fy2*y2*invz2+cy2;
-                float errX2 = u2 - kp2.pt.x;
-                float errY2 = v2 - kp2.pt.y;
-                if((errX2*errX2+errY2*errY2)>5.991*sigmaSquare2)
+                float z2 = Rcw2.row(2).dot(x3Dt) + tcw2.at<float>(2);
+                if (z2 <= 0)
                     continue;
-            }
-            else
-            {
-                float u2 = fx2*x2*invz2+cx2;
-                float u2_r = u2 - mpCurrentKeyFrame->mbf*invz2;
-                float v2 = fy2*y2*invz2+cy2;
-                float errX2 = u2 - kp2.pt.x;
-                float errY2 = v2 - kp2.pt.y;
-                float errX2_r = u2_r - kp2_ur;
-                if((errX2*errX2+errY2*errY2+errX2_r*errX2_r)>7.8*sigmaSquare2)
-                    continue;
-            }
 
-            //Check scale consistency
-            cv::Mat normal1 = x3D-Ow1;
-            float dist1 = cv::norm(normal1);
+                // Check reprojection error in first keyframe
+                const float &sigmaSquare1 = mpCurrentKeyFrame->mvLevelSigma2[kp1.octave];
+                const float x1 = Rcw1.row(0).dot(x3Dt) + tcw1.at<float>(0);
+                const float y1 = Rcw1.row(1).dot(x3Dt) + tcw1.at<float>(1);
+                const float invz1 = 1.0 / z1;
 
-            cv::Mat normal2 = x3D-Ow2;
-            float dist2 = cv::norm(normal2);
+                if (!bStereo1)
+                {
+                    float u1 = fx1 * x1 * invz1 + cx1;
+                    float v1 = fy1 * y1 * invz1 + cy1;
+                    float errX1 = u1 - kp1.pt.x;
+                    float errY1 = v1 - kp1.pt.y;
+                    if ((errX1 * errX1 + errY1 * errY1) > 5.991 * sigmaSquare1)
+                        continue;
+                }
+                else
+                {
+                    float u1 = fx1 * x1 * invz1 + cx1;
+                    float u1_r = u1 - mpCurrentKeyFrame->mbf * invz1;
+                    float v1 = fy1 * y1 * invz1 + cy1;
+                    float errX1 = u1 - kp1.pt.x;
+                    float errY1 = v1 - kp1.pt.y;
+                    float errX1_r = u1_r - kp1_ur;
+                    if ((errX1 * errX1 + errY1 * errY1 + errX1_r * errX1_r) > 7.8 * sigmaSquare1)
+                        continue;
+                }
 
-            if(dist1==0 || dist2==0)
-                continue;
+                // Check reprojection error in second keyframe
+                const float sigmaSquare2 = pKF2->mvLevelSigma2[kp2.octave];
+                const float x2 = Rcw2.row(0).dot(x3Dt) + tcw2.at<float>(0);
+                const float y2 = Rcw2.row(1).dot(x3Dt) + tcw2.at<float>(1);
+                const float invz2 = 1.0 / z2;
+                if (!bStereo2)
+                {
+                    float u2 = fx2 * x2 * invz2 + cx2;
+                    float v2 = fy2 * y2 * invz2 + cy2;
+                    float errX2 = u2 - kp2.pt.x;
+                    float errY2 = v2 - kp2.pt.y;
+                    if ((errX2 * errX2 + errY2 * errY2) > 5.991 * sigmaSquare2)
+                        continue;
+                }
+                else
+                {
+                    float u2 = fx2 * x2 * invz2 + cx2;
+                    float u2_r = u2 - mpCurrentKeyFrame->mbf * invz2;
+                    float v2 = fy2 * y2 * invz2 + cy2;
+                    float errX2 = u2 - kp2.pt.x;
+                    float errY2 = v2 - kp2.pt.y;
+                    float errX2_r = u2_r - kp2_ur;
+                    if ((errX2 * errX2 + errY2 * errY2 + errX2_r * errX2_r) > 7.8 * sigmaSquare2)
+                        continue;
+                }
 
-            const float ratioDist = dist2/dist1;
-            const float ratioOctave = mpCurrentKeyFrame->mvScaleFactors[kp1.octave]/pKF2->mvScaleFactors[kp2.octave];
+                // Check scale consistency
+                cv::Mat normal1 = x3D - Ow1;
+                float dist1 = cv::norm(normal1);
 
-            /*if(fabs(ratioDist-ratioOctave)>ratioFactor)
-                continue;*/
-            if(ratioDist*ratioFactor<ratioOctave || ratioDist>ratioOctave*ratioFactor)
-                continue;
+                cv::Mat normal2 = x3D - Ow2;
+                float dist2 = cv::norm(normal2);
+
+                if (dist1 == 0 || dist2 == 0)
+                    continue;
 
-            // Triangulation is succesfull
-            MapPoint* pMP = new MapPoint(x3D,mpCurrentKeyFrame,mpMap);
+                const float ratioDist = dist2 / dist1;
+                const float ratioOctave = mpCurrentKeyFrame->mvScaleFactors[kp1.octave] / pKF2->mvScaleFactors[kp2.octave];
 
-            pMP->AddObservation(mpCurrentKeyFrame,idx1);            
-            pMP->AddObservation(pKF2,idx2);
+                /*if(fabs(ratioDist-ratioOctave)>ratioFactor)
+                    continue;*/
+                if (ratioDist * ratioFactor < ratioOctave || ratioDist > ratioOctave * ratioFactor)
+                    continue;
+
+                // Triangulation is succesfull
+                MapPoint *pMP = new MapPoint(x3D, mpCurrentKeyFrame, mpMap);
 
-            mpCurrentKeyFrame->AddMapPoint(pMP,idx1);
-            pKF2->AddMapPoint(pMP,idx2);
+                pMP->AddObservation(mpCurrentKeyFrame, idx1);
+                pMP->AddObservation(pKF2, idx2);
 
-            pMP->ComputeDistinctiveDescriptors();
+                mpCurrentKeyFrame->AddMapPoint(pMP, idx1);
+                pKF2->AddMapPoint(pMP, idx2);
+
+                pMP->ComputeDistinctiveDescriptors();
 
-            pMP->UpdateNormalAndDepth();
+                pMP->UpdateNormalAndDepth();
 
-            mpMap->AddMapPoint(pMP);
-            mlpRecentAddedMapPoints.push_back(pMP);
+                mpMap->AddMapPoint(pMP);
+                mlpRecentAddedMapPoints.push_back(pMP);
 
-            nnew++;
+                nnew++;
+            }
         }
     }
-}
 
-void LocalMapping::SearchInNeighbors()
-{
-    // Retrieve neighbor keyframes
-    int nn = 10;
-    if(mbMonocular)
-        nn=20;
-    const vector<KeyFrame*> vpNeighKFs = mpCurrentKeyFrame->GetBestCovisibilityKeyFrames(nn);
-    vector<KeyFrame*> vpTargetKFs;
-    for(vector<KeyFrame*>::const_iterator vit=vpNeighKFs.begin(), vend=vpNeighKFs.end(); vit!=vend; vit++)
+    void LocalMapping::SearchInNeighbors()
     {
-        KeyFrame* pKFi = *vit;
-        if(pKFi->isBad() || pKFi->mnFuseTargetForKF == mpCurrentKeyFrame->mnId)
-            continue;
-        vpTargetKFs.push_back(pKFi);
-        pKFi->mnFuseTargetForKF = mpCurrentKeyFrame->mnId;
-
-        // Extend to some second neighbors
-        const vector<KeyFrame*> vpSecondNeighKFs = pKFi->GetBestCovisibilityKeyFrames(5);
-        for(vector<KeyFrame*>::const_iterator vit2=vpSecondNeighKFs.begin(), vend2=vpSecondNeighKFs.end(); vit2!=vend2; vit2++)
+        // Retrieve neighbor keyframes
+        int nn = 10;
+        if (mbMonocular)
+            nn = 20;
+        const vector<KeyFrame *> vpNeighKFs = mpCurrentKeyFrame->GetBestCovisibilityKeyFrames(nn);
+        vector<KeyFrame *> vpTargetKFs;
+        for (vector<KeyFrame *>::const_iterator vit = vpNeighKFs.begin(), vend = vpNeighKFs.end(); vit != vend; vit++)
         {
-            KeyFrame* pKFi2 = *vit2;
-            if(pKFi2->isBad() || pKFi2->mnFuseTargetForKF==mpCurrentKeyFrame->mnId || pKFi2->mnId==mpCurrentKeyFrame->mnId)
+            KeyFrame *pKFi = *vit;
+            if (pKFi->isBad() || pKFi->mnFuseTargetForKF == mpCurrentKeyFrame->mnId)
                 continue;
-            vpTargetKFs.push_back(pKFi2);
-        }
-    }
+            vpTargetKFs.push_back(pKFi);
+            pKFi->mnFuseTargetForKF = mpCurrentKeyFrame->mnId;
 
+            // Extend to some second neighbors
+            const vector<KeyFrame *> vpSecondNeighKFs = pKFi->GetBestCovisibilityKeyFrames(5);
+            for (vector<KeyFrame *>::const_iterator vit2 = vpSecondNeighKFs.begin(), vend2 = vpSecondNeighKFs.end(); vit2 != vend2; vit2++)
+            {
+                KeyFrame *pKFi2 = *vit2;
+                if (pKFi2->isBad() || pKFi2->mnFuseTargetForKF == mpCurrentKeyFrame->mnId || pKFi2->mnId == mpCurrentKeyFrame->mnId)
+                    continue;
+                vpTargetKFs.push_back(pKFi2);
+            }
+        }
 
-    // Search matches by projection from current KF in target KFs
-    ORBmatcher matcher;
-    vector<MapPoint*> vpMapPointMatches = mpCurrentKeyFrame->GetMapPointMatches();
-    for(vector<KeyFrame*>::iterator vit=vpTargetKFs.begin(), vend=vpTargetKFs.end(); vit!=vend; vit++)
-    {
-        KeyFrame* pKFi = *vit;
+        // Search matches by projection from current KF in target KFs
+        ORBmatcher matcher;
+        vector<MapPoint *> vpMapPointMatches = mpCurrentKeyFrame->GetMapPointMatches();
+        for (vector<KeyFrame *>::iterator vit = vpTargetKFs.begin(), vend = vpTargetKFs.end(); vit != vend; vit++)
+        {
+            KeyFrame *pKFi = *vit;
 
-        matcher.Fuse(pKFi,vpMapPointMatches);
-    }
+            matcher.Fuse(pKFi, vpMapPointMatches);
+        }
 
-    // Search matches by projection from target KFs in current KF
-    vector<MapPoint*> vpFuseCandidates;
-    vpFuseCandidates.reserve(vpTargetKFs.size()*vpMapPointMatches.size());
+        // Search matches by projection from target KFs in current KF
+        vector<MapPoint *> vpFuseCandidates;
+        vpFuseCandidates.reserve(vpTargetKFs.size() * vpMapPointMatches.size());
 
-    for(vector<KeyFrame*>::iterator vitKF=vpTargetKFs.begin(), vendKF=vpTargetKFs.end(); vitKF!=vendKF; vitKF++)
-    {
-        KeyFrame* pKFi = *vitKF;
+        for (vector<KeyFrame *>::iterator vitKF = vpTargetKFs.begin(), vendKF = vpTargetKFs.end(); vitKF != vendKF; vitKF++)
+        {
+            KeyFrame *pKFi = *vitKF;
 
-        vector<MapPoint*> vpMapPointsKFi = pKFi->GetMapPointMatches();
+            vector<MapPoint *> vpMapPointsKFi = pKFi->GetMapPointMatches();
 
-        for(vector<MapPoint*>::iterator vitMP=vpMapPointsKFi.begin(), vendMP=vpMapPointsKFi.end(); vitMP!=vendMP; vitMP++)
-        {
-            MapPoint* pMP = *vitMP;
-            if(!pMP)
-                continue;
-            if(pMP->isBad() || pMP->mnFuseCandidateForKF == mpCurrentKeyFrame->mnId)
-                continue;
-            pMP->mnFuseCandidateForKF = mpCurrentKeyFrame->mnId;
-            vpFuseCandidates.push_back(pMP);
+            for (vector<MapPoint *>::iterator vitMP = vpMapPointsKFi.begin(), vendMP = vpMapPointsKFi.end(); vitMP != vendMP; vitMP++)
+            {
+                MapPoint *pMP = *vitMP;
+                if (!pMP)
+                    continue;
+                if (pMP->isBad() || pMP->mnFuseCandidateForKF == mpCurrentKeyFrame->mnId)
+                    continue;
+                pMP->mnFuseCandidateForKF = mpCurrentKeyFrame->mnId;
+                vpFuseCandidates.push_back(pMP);
+            }
         }
-    }
-
-    matcher.Fuse(mpCurrentKeyFrame,vpFuseCandidates);
 
+        matcher.Fuse(mpCurrentKeyFrame, vpFuseCandidates);
 
-    // Update points
-    vpMapPointMatches = mpCurrentKeyFrame->GetMapPointMatches();
-    for(size_t i=0, iend=vpMapPointMatches.size(); i<iend; i++)
-    {
-        MapPoint* pMP=vpMapPointMatches[i];
-        if(pMP)
+        // Update points
+        vpMapPointMatches = mpCurrentKeyFrame->GetMapPointMatches();
+        for (size_t i = 0, iend = vpMapPointMatches.size(); i < iend; i++)
         {
-            if(!pMP->isBad())
+            MapPoint *pMP = vpMapPointMatches[i];
+            if (pMP)
             {
-                pMP->ComputeDistinctiveDescriptors();
-                pMP->UpdateNormalAndDepth();
+                if (!pMP->isBad())
+                {
+                    pMP->ComputeDistinctiveDescriptors();
+                    pMP->UpdateNormalAndDepth();
+                }
             }
         }
+
+        // Update connections in covisibility graph
+        mpCurrentKeyFrame->UpdateConnections();
     }
 
-    // Update connections in covisibility graph
-    mpCurrentKeyFrame->UpdateConnections();
-}
+    cv::Mat LocalMapping::ComputeF12(KeyFrame *&pKF1, KeyFrame *&pKF2)
+    {
+        cv::Mat R1w = pKF1->GetRotation();
+        cv::Mat t1w = pKF1->GetTranslation();
+        cv::Mat R2w = pKF2->GetRotation();
+        cv::Mat t2w = pKF2->GetTranslation();
 
-cv::Mat LocalMapping::ComputeF12(KeyFrame *&pKF1, KeyFrame *&pKF2)
-{
-    cv::Mat R1w = pKF1->GetRotation();
-    cv::Mat t1w = pKF1->GetTranslation();
-    cv::Mat R2w = pKF2->GetRotation();
-    cv::Mat t2w = pKF2->GetTranslation();
+        cv::Mat R12 = R1w * R2w.t();
+        cv::Mat t12 = -R1w * R2w.t() * t2w + t1w;
 
-    cv::Mat R12 = R1w*R2w.t();
-    cv::Mat t12 = -R1w*R2w.t()*t2w+t1w;
+        cv::Mat t12x = SkewSymmetricMatrix(t12);
 
-    cv::Mat t12x = SkewSymmetricMatrix(t12);
+        const cv::Mat &K1 = pKF1->mK;
+        const cv::Mat &K2 = pKF2->mK;
 
-    const cv::Mat &K1 = pKF1->mK;
-    const cv::Mat &K2 = pKF2->mK;
+        return K1.t().inv() * t12x * R12 * K2.inv();
+    }
 
+    void LocalMapping::RequestStop()
+    {
+        unique_lock<mutex> lock(mMutexStop);
+        mbStopRequested = true;
+        unique_lock<mutex> lock2(mMutexNewKFs);
+        mbAbortBA = true;
+    }
 
-    return K1.t().inv()*t12x*R12*K2.inv();
-}
+    bool LocalMapping::Stop()
+    {
+        unique_lock<mutex> lock(mMutexStop);
+        if (mbStopRequested && !mbNotStop)
+        {
+            mbStopped = true;
+            cout << "Local Mapping STOP" << endl;
+            return true;
+        }
 
-void LocalMapping::RequestStop()
-{
-    unique_lock<mutex> lock(mMutexStop);
-    mbStopRequested = true;
-    unique_lock<mutex> lock2(mMutexNewKFs);
-    mbAbortBA = true;
-}
+        return false;
+    }
 
-bool LocalMapping::Stop()
-{
-    unique_lock<mutex> lock(mMutexStop);
-    if(mbStopRequested && !mbNotStop)
+    bool LocalMapping::isStopped()
     {
-        mbStopped = true;
-        cout << "Local Mapping STOP" << endl;
-        return true;
+        unique_lock<mutex> lock(mMutexStop);
+        return mbStopped;
     }
 
-    return false;
-}
+    bool LocalMapping::stopRequested()
+    {
+        unique_lock<mutex> lock(mMutexStop);
+        return mbStopRequested;
+    }
 
-bool LocalMapping::isStopped()
-{
-    unique_lock<mutex> lock(mMutexStop);
-    return mbStopped;
-}
+    void LocalMapping::Release()
+    {
+        unique_lock<mutex> lock(mMutexStop);
+        unique_lock<mutex> lock2(mMutexFinish);
+        if (mbFinished)
+            return;
+        mbStopped = false;
+        mbStopRequested = false;
+        for (list<KeyFrame *>::iterator lit = mlNewKeyFrames.begin(), lend = mlNewKeyFrames.end(); lit != lend; lit++)
+            delete *lit;
+        mlNewKeyFrames.clear();
 
-bool LocalMapping::stopRequested()
-{
-    unique_lock<mutex> lock(mMutexStop);
-    return mbStopRequested;
-}
+        cout << "Local Mapping RELEASE" << endl;
+    }
 
-void LocalMapping::Release()
-{
-    unique_lock<mutex> lock(mMutexStop);
-    unique_lock<mutex> lock2(mMutexFinish);
-    if(mbFinished)
-        return;
-    mbStopped = false;
-    mbStopRequested = false;
-    for(list<KeyFrame*>::iterator lit = mlNewKeyFrames.begin(), lend=mlNewKeyFrames.end(); lit!=lend; lit++)
-        delete *lit;
-    mlNewKeyFrames.clear();
-
-    cout << "Local Mapping RELEASE" << endl;
-}
-
-bool LocalMapping::AcceptKeyFrames()
-{
-    unique_lock<mutex> lock(mMutexAccept);
-    return mbAcceptKeyFrames;
-}
+    bool LocalMapping::AcceptKeyFrames()
+    {
+        unique_lock<mutex> lock(mMutexAccept);
+        return mbAcceptKeyFrames;
+    }
 
-void LocalMapping::SetAcceptKeyFrames(bool flag)
-{
-    unique_lock<mutex> lock(mMutexAccept);
-    mbAcceptKeyFrames=flag;
-}
+    void LocalMapping::SetAcceptKeyFrames(bool flag)
+    {
+        unique_lock<mutex> lock(mMutexAccept);
+        mbAcceptKeyFrames = flag;
+    }
 
-bool LocalMapping::SetNotStop(bool flag)
-{
-    unique_lock<mutex> lock(mMutexStop);
+    bool LocalMapping::SetNotStop(bool flag)
+    {
+        unique_lock<mutex> lock(mMutexStop);
 
-    if(flag && mbStopped)
-        return false;
+        if (flag && mbStopped)
+            return false;
 
-    mbNotStop = flag;
+        mbNotStop = flag;
 
-    return true;
-}
+        return true;
+    }
 
-void LocalMapping::InterruptBA()
-{
-    mbAbortBA = true;
-}
+    void LocalMapping::InterruptBA()
+    {
+        mbAbortBA = true;
+    }
 
-void LocalMapping::KeyFrameCulling()
-{
-    // Check redundant keyframes (only local keyframes)
-    // A keyframe is considered redundant if the 90% of the MapPoints it sees, are seen
-    // in at least other 3 keyframes (in the same or finer scale)
-    // We only consider close stereo points
-    vector<KeyFrame*> vpLocalKeyFrames = mpCurrentKeyFrame->GetVectorCovisibleKeyFrames();
-    cv::Point3f current_pos(mpCurrentKeyFrame->GetCameraCenter());
-
-    for(vector<KeyFrame*>::iterator vit=vpLocalKeyFrames.begin(), vend=vpLocalKeyFrames.end(); vit!=vend; vit++)
+    void LocalMapping::KeyFrameCulling()
     {
-        KeyFrame* pKF = *vit;
-        // cv::Point3f pkf_pos(pKF->GetCameraCenter());
-
-        // double dist_x = (current_pos.x - pkf_pos.x);
-        // double dist_y = (current_pos.y - pkf_pos.y);
-        // double dist_z = (current_pos.z - pkf_pos.z);
-
-        // double dist = dist_x*dist_x + dist_y*dist_y + dist_z*dist_z;
-        // std::cout << "dist: "<< dist << std::endl;
-        // if(dist < 0.001){
-        //     mpCurrentKeyFrame->SetBadFlag();
-        //     break;
-        // }
-        // continue;
-        if(pKF->mnId==0)
-            continue;
-        const vector<MapPoint*> vpMapPoints = pKF->GetMapPointMatches();
-
-        int /*nObs = 2;
-        if(mbMonocular)*/
-            nObs = 3;
-        const int thObs=nObs;
-        int nRedundantObservations=0;
-        int nMPs=0;
-        for(size_t i=0, iend=vpMapPoints.size(); i<iend; i++)
+        // Check redundant keyframes (only local keyframes)
+        // A keyframe is considered redundant if the 90% of the MapPoints it sees, are seen
+        // in at least other 3 keyframes (in the same or finer scale)
+        // We only consider close stereo points
+        vector<KeyFrame *> vpLocalKeyFrames = mpCurrentKeyFrame->GetVectorCovisibleKeyFrames();
+        cv::Point3f current_pos(mpCurrentKeyFrame->GetCameraCenter());
+
+        for (vector<KeyFrame *>::iterator vit = vpLocalKeyFrames.begin(), vend = vpLocalKeyFrames.end(); vit != vend; vit++)
         {
-            MapPoint* pMP = vpMapPoints[i];
-            if(pMP)
+            KeyFrame *pKF = *vit;
+            // cv::Point3f pkf_pos(pKF->GetCameraCenter());
+
+            // double dist_x = (current_pos.x - pkf_pos.x);
+            // double dist_y = (current_pos.y - pkf_pos.y);
+            // double dist_z = (current_pos.z - pkf_pos.z);
+
+            // double dist = dist_x*dist_x + dist_y*dist_y + dist_z*dist_z;
+            // std::cout << "dist: "<< dist << std::endl;
+            // if(dist < 0.001){
+            //     mpCurrentKeyFrame->SetBadFlag();
+            //     break;
+            // }
+            // continue;
+            if (pKF->mnId == 0)
+                continue;
+            const vector<MapPoint *> vpMapPoints = pKF->GetMapPointMatches();
+
+            int /*nObs = 2;
+            if(mbMonocular)*/
+                nObs = 3;
+            const int thObs = nObs;
+            int nRedundantObservations = 0;
+            int nMPs = 0;
+            for (size_t i = 0, iend = vpMapPoints.size(); i < iend; i++)
             {
-                if(!pMP->isBad())
+                MapPoint *pMP = vpMapPoints[i];
+                if (pMP)
                 {
-                    if(!mbMonocular)
+                    if (!pMP->isBad())
                     {
-                        if(pKF->mvDepth[i]>pKF->mThDepth || pKF->mvDepth[i]<0)
-                            continue;
-                    }
-
-                    nMPs++;
-                    if(pMP->Observations()>thObs)
-                    {
-                        const int &scaleLevel = pKF->mvKeysUn[i].octave;
-                        const map<KeyFrame*, size_t> observations = pMP->GetObservations();
-                        int nObs=0;
-                        for(map<KeyFrame*, size_t>::const_iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)
+                        if (!mbMonocular)
                         {
-                            KeyFrame* pKFi = mit->first;
-                            if(pKFi==pKF)
+                            if (pKF->mvDepth[i] > pKF->mThDepth || pKF->mvDepth[i] < 0)
                                 continue;
-                            const int &scaleLeveli = pKFi->mvKeysUn[mit->second].octave;
+                        }
 
-                            if(scaleLeveli<=scaleLevel+1)
+                        nMPs++;
+                        if (pMP->Observations() > thObs)
+                        {
+                            const int &scaleLevel = pKF->mvKeysUn[i].octave;
+                            const map<KeyFrame *, size_t> observations = pMP->GetObservations();
+                            int nObs = 0;
+                            for (map<KeyFrame *, size_t>::const_iterator mit = observations.begin(), mend = observations.end(); mit != mend; mit++)
                             {
-                                nObs++;
-                                if(nObs>=thObs)
-                                    break;
+                                KeyFrame *pKFi = mit->first;
+                                if (pKFi == pKF)
+                                    continue;
+                                const int &scaleLeveli = pKFi->mvKeysUn[mit->second].octave;
+
+                                if (scaleLeveli <= scaleLevel + 1)
+                                {
+                                    nObs++;
+                                    if (nObs >= thObs)
+                                        break;
+                                }
+                            }
+                            if (nObs >= thObs)
+                            {
+                                nRedundantObservations++;
                             }
-                        }
-                        if(nObs>=thObs)
-                        {
-                            nRedundantObservations++;
                         }
                     }
                 }
             }
-        }  
 
-        if(nRedundantObservations>0.9*nMPs)
-            pKF->SetBadFlag();
+            if (nRedundantObservations > 0.9 * nMPs)
+                pKF->SetBadFlag();
+        }
     }
-}
-
-cv::Mat LocalMapping::SkewSymmetricMatrix(const cv::Mat &v)
-{
-    return (cv::Mat_<float>(3,3) <<             0, -v.at<float>(2), v.at<float>(1),
-            v.at<float>(2),               0,-v.at<float>(0),
-            -v.at<float>(1),  v.at<float>(0),              0);
-}
 
-void LocalMapping::RequestReset()
-{
+    cv::Mat LocalMapping::SkewSymmetricMatrix(const cv::Mat &v)
     {
-        unique_lock<mutex> lock(mMutexReset);
-        mbResetRequested = true;
+        return (cv::Mat_<float>(3, 3) << 0, -v.at<float>(2), v.at<float>(1),
+                v.at<float>(2), 0, -v.at<float>(0),
+                -v.at<float>(1), v.at<float>(0), 0);
     }
 
-    while(1)
+    void LocalMapping::RequestReset()
     {
         {
-            unique_lock<mutex> lock2(mMutexReset);
-            if(!mbResetRequested)
-                break;
+            unique_lock<mutex> lock(mMutexReset);
+            mbResetRequested = true;
+        }
+
+        while (1)
+        {
+            {
+                unique_lock<mutex> lock2(mMutexReset);
+                if (!mbResetRequested)
+                    break;
+            }
+            Sleep(3);
         }
-        usleep(3000);
     }
-}
 
-void LocalMapping::ResetIfRequested()
-{
-    unique_lock<mutex> lock(mMutexReset);
-    if(mbResetRequested)
+    void LocalMapping::ResetIfRequested()
     {
-        mlNewKeyFrames.clear();
-        mlpRecentAddedMapPoints.clear();
-        mbResetRequested=false;
+        unique_lock<mutex> lock(mMutexReset);
+        if (mbResetRequested)
+        {
+            mlNewKeyFrames.clear();
+            mlpRecentAddedMapPoints.clear();
+            mbResetRequested = false;
+        }
     }
-}
 
-void LocalMapping::RequestFinish()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    mbFinishRequested = true;
-}
+    void LocalMapping::RequestFinish()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        mbFinishRequested = true;
+    }
 
-bool LocalMapping::CheckFinish()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    return mbFinishRequested;
-}
+    bool LocalMapping::CheckFinish()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        return mbFinishRequested;
+    }
 
-void LocalMapping::SetFinish()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    mbFinished = true;    
-    unique_lock<mutex> lock2(mMutexStop);
-    mbStopped = true;
-}
+    void LocalMapping::SetFinish()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        mbFinished = true;
+        unique_lock<mutex> lock2(mMutexStop);
+        mbStopped = true;
+    }
 
-bool LocalMapping::isFinished()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    return mbFinished;
-}
+    bool LocalMapping::isFinished()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        return mbFinished;
+    }
 
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/LoopClosing.cc b/slam/src/LoopClosing.cc
index 79b7570..5b3473c 100644
--- a/slam/src/LoopClosing.cc
+++ b/slam/src/LoopClosing.cc
@@ -1,22 +1,22 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "LoopClosing.h"
 
@@ -28,787 +28,761 @@
 
 #include "ORBmatcher.h"
 
-#include<mutex>
-#include<thread>
-
+#include <mutex>
+#include <thread>
 
 namespace ORB_SLAM2
 {
 
-LoopClosing::LoopClosing(Map *pMap, KeyFrameDatabase *pDB, ORBVocabulary *pVoc, const bool bFixScale):
-    mbResetRequested(false), mbFinishRequested(false), mbFinished(true), mpMap(pMap),
-    mpKeyFrameDB(pDB), mpORBVocabulary(pVoc), mLastLoopKFid(0), mbRunningGBA(false), mbFinishedGBA(true),
-    mbStopGBA(false), mbFixScale(bFixScale)
-{
-    mnCovisibilityConsistencyTh = 3;
-    mpMatchedKF = NULL;
-}
-
-void LoopClosing::SetTracker(Tracking *pTracker)
-{
-    mpTracker=pTracker;
-}
-
-void LoopClosing::SetLocalMapper(LocalMapping *pLocalMapper)
-{
-    mpLocalMapper=pLocalMapper;
-}
+    LoopClosing::LoopClosing(Map *pMap, KeyFrameDatabase *pDB, ORBVocabulary *pVoc, const bool bFixScale) : mbResetRequested(false), mbFinishRequested(false), mbFinished(true), mpMap(pMap),
+                                                                                                            mpKeyFrameDB(pDB), mpORBVocabulary(pVoc), mLastLoopKFid(0), mbRunningGBA(false), mbFinishedGBA(true),
+                                                                                                            mbStopGBA(false), mbFixScale(bFixScale)
+    {
+        mnCovisibilityConsistencyTh = 3;
+        mpMatchedKF = NULL;
+    }
 
+    void LoopClosing::SetTracker(Tracking *pTracker)
+    {
+        mpTracker = pTracker;
+    }
 
-void LoopClosing::Run()
-{
-    mbFinished =false;
+    void LoopClosing::SetLocalMapper(LocalMapping *pLocalMapper)
+    {
+        mpLocalMapper = pLocalMapper;
+    }
 
-    while(1)
+    void LoopClosing::Run()
     {
-        // Check if there are keyframes in the queue
-        if(CheckNewKeyFrames())
+        mbFinished = false;
+
+        while (1)
         {
-            // Detect loop candidates and check covisibility consistency
-            if(DetectLoop())
+            // Check if there are keyframes in the queue
+            if (CheckNewKeyFrames())
             {
-               // Compute similarity transformation [sR|t]
-               // In the stereo/RGBD case s=1
-               if(ComputeSim3())
-               {
-                   // Perform loop fusion and pose graph optimization
-                   CorrectLoop();
-               }
+                // Detect loop candidates and check covisibility consistency
+                if (DetectLoop())
+                {
+                    // Compute similarity transformation [sR|t]
+                    // In the stereo/RGBD case s=1
+                    if (ComputeSim3())
+                    {
+                        // Perform loop fusion and pose graph optimization
+                        CorrectLoop();
+                    }
+                }
             }
-        }       
-
-        ResetIfRequested();
 
-        if(CheckFinish())
-            break;
-
-        usleep(5000);
-    }
+            ResetIfRequested();
 
-    SetFinish();
-}
+            if (CheckFinish())
+                break;
 
-void LoopClosing::InsertKeyFrame(KeyFrame *pKF)
-{
-    unique_lock<mutex> lock(mMutexLoopQueue);
-    if(pKF->mnId!=0)
-        mlpLoopKeyFrameQueue.push_back(pKF);
-}
+            Sleep(5);
+        }
 
-bool LoopClosing::CheckNewKeyFrames()
-{
-    unique_lock<mutex> lock(mMutexLoopQueue);
-    return(!mlpLoopKeyFrameQueue.empty());
-}
+        SetFinish();
+    }
 
-bool LoopClosing::DetectLoop()
-{
+    void LoopClosing::InsertKeyFrame(KeyFrame *pKF)
     {
         unique_lock<mutex> lock(mMutexLoopQueue);
-        mpCurrentKF = mlpLoopKeyFrameQueue.front();
-        mlpLoopKeyFrameQueue.pop_front();
-        // Avoid that a keyframe can be erased while it is being process by this thread
-        mpCurrentKF->SetNotErase();
+        if (pKF->mnId != 0)
+            mlpLoopKeyFrameQueue.push_back(pKF);
     }
 
-    //If the map contains less than 10 KF or less than 10 KF have passed from last loop detection
-    if(mpCurrentKF->mnId<mLastLoopKFid+10)
+    bool LoopClosing::CheckNewKeyFrames()
     {
-        mpKeyFrameDB->add(mpCurrentKF);
-        mpCurrentKF->SetErase();
-        return false;
+        unique_lock<mutex> lock(mMutexLoopQueue);
+        return (!mlpLoopKeyFrameQueue.empty());
     }
 
-    // Compute reference BoW similarity score
-    // This is the lowest score to a connected keyframe in the covisibility graph
-    // We will impose loop candidates to have a higher similarity than this
-    const vector<KeyFrame*> vpConnectedKeyFrames = mpCurrentKF->GetVectorCovisibleKeyFrames();
-    const DBoW2::BowVector &CurrentBowVec = mpCurrentKF->mBowVec;
-    float minScore = 1;
-    for(size_t i=0; i<vpConnectedKeyFrames.size(); i++)
+    bool LoopClosing::DetectLoop()
     {
-        KeyFrame* pKF = vpConnectedKeyFrames[i];
-        if(pKF->isBad())
-            continue;
-        const DBoW2::BowVector &BowVec = pKF->mBowVec;
+        {
+            unique_lock<mutex> lock(mMutexLoopQueue);
+            mpCurrentKF = mlpLoopKeyFrameQueue.front();
+            mlpLoopKeyFrameQueue.pop_front();
+            // Avoid that a keyframe can be erased while it is being process by this thread
+            mpCurrentKF->SetNotErase();
+        }
 
-        float score = mpORBVocabulary->score(CurrentBowVec, BowVec);
+        // If the map contains less than 10 KF or less than 10 KF have passed from last loop detection
+        if (mpCurrentKF->mnId < mLastLoopKFid + 10)
+        {
+            mpKeyFrameDB->add(mpCurrentKF);
+            mpCurrentKF->SetErase();
+            return false;
+        }
 
-        if(score<minScore)
-            minScore = score;
-    }
+        // Compute reference BoW similarity score
+        // This is the lowest score to a connected keyframe in the covisibility graph
+        // We will impose loop candidates to have a higher similarity than this
+        const vector<KeyFrame *> vpConnectedKeyFrames = mpCurrentKF->GetVectorCovisibleKeyFrames();
+        const DBoW2::BowVector &CurrentBowVec = mpCurrentKF->mBowVec;
+        float minScore = 1;
+        for (size_t i = 0; i < vpConnectedKeyFrames.size(); i++)
+        {
+            KeyFrame *pKF = vpConnectedKeyFrames[i];
+            if (pKF->isBad())
+                continue;
+            const DBoW2::BowVector &BowVec = pKF->mBowVec;
 
-    // Query the database imposing the minimum score
-    vector<KeyFrame*> vpCandidateKFs = mpKeyFrameDB->DetectLoopCandidates(mpCurrentKF, minScore);
+            float score = mpORBVocabulary->score(CurrentBowVec, BowVec);
 
-    // If there are no loop candidates, just add new keyframe and return false
-    // BAR
-    if(vpCandidateKFs.empty())
-    {
-        mpKeyFrameDB->add(mpCurrentKF);
-        mvConsistentGroups.clear();
-        mpCurrentKF->SetErase();
-        return false;
-    }
+            if (score < minScore)
+                minScore = score;
+        }
 
-    // For each loop candidate check consistency with previous loop candidates
-    // Each candidate expands a covisibility group (keyframes connected to the loop candidate in the covisibility graph)
-    // A group is consistent with a previous group if they share at least a keyframe
-    // We must detect a consistent loop in several consecutive keyframes to accept it
-    mvpEnoughConsistentCandidates.clear();
+        // Query the database imposing the minimum score
+        vector<KeyFrame *> vpCandidateKFs = mpKeyFrameDB->DetectLoopCandidates(mpCurrentKF, minScore);
 
-    vector<ConsistentGroup> vCurrentConsistentGroups;
-    vector<bool> vbConsistentGroup(mvConsistentGroups.size(),false);
-    for(size_t i=0, iend=vpCandidateKFs.size(); i<iend; i++)
-    {
-        KeyFrame* pCandidateKF = vpCandidateKFs[i];
+        // If there are no loop candidates, just add new keyframe and return false
+        // BAR
+        if (vpCandidateKFs.empty())
+        {
+            mpKeyFrameDB->add(mpCurrentKF);
+            mvConsistentGroups.clear();
+            mpCurrentKF->SetErase();
+            return false;
+        }
 
-        set<KeyFrame*> spCandidateGroup = pCandidateKF->GetConnectedKeyFrames();
-        spCandidateGroup.insert(pCandidateKF);
+        // For each loop candidate check consistency with previous loop candidates
+        // Each candidate expands a covisibility group (keyframes connected to the loop candidate in the covisibility graph)
+        // A group is consistent with a previous group if they share at least a keyframe
+        // We must detect a consistent loop in several consecutive keyframes to accept it
+        mvpEnoughConsistentCandidates.clear();
 
-        bool bEnoughConsistent = false;
-        bool bConsistentForSomeGroup = false;
-        for(size_t iG=0, iendG=mvConsistentGroups.size(); iG<iendG; iG++)
+        vector<ConsistentGroup> vCurrentConsistentGroups;
+        vector<bool> vbConsistentGroup(mvConsistentGroups.size(), false);
+        for (size_t i = 0, iend = vpCandidateKFs.size(); i < iend; i++)
         {
-            set<KeyFrame*> sPreviousGroup = mvConsistentGroups[iG].first;
+            KeyFrame *pCandidateKF = vpCandidateKFs[i];
 
-            bool bConsistent = false;
-            for(set<KeyFrame*>::iterator sit=spCandidateGroup.begin(), send=spCandidateGroup.end(); sit!=send;sit++)
-            {
-                if(sPreviousGroup.count(*sit))
-                {
-                    bConsistent=true;
-                    bConsistentForSomeGroup=true;
-                    break;
-                }
-            }
+            set<KeyFrame *> spCandidateGroup = pCandidateKF->GetConnectedKeyFrames();
+            spCandidateGroup.insert(pCandidateKF);
 
-            if(bConsistent)
+            bool bEnoughConsistent = false;
+            bool bConsistentForSomeGroup = false;
+            for (size_t iG = 0, iendG = mvConsistentGroups.size(); iG < iendG; iG++)
             {
-                int nPreviousConsistency = mvConsistentGroups[iG].second;
-                int nCurrentConsistency = nPreviousConsistency + 1;
-                if(!vbConsistentGroup[iG])
+                set<KeyFrame *> sPreviousGroup = mvConsistentGroups[iG].first;
+
+                bool bConsistent = false;
+                for (set<KeyFrame *>::iterator sit = spCandidateGroup.begin(), send = spCandidateGroup.end(); sit != send; sit++)
                 {
-                    ConsistentGroup cg = make_pair(spCandidateGroup,nCurrentConsistency);
-                    vCurrentConsistentGroups.push_back(cg);
-                    vbConsistentGroup[iG]=true; //this avoid to include the same group more than once
+                    if (sPreviousGroup.count(*sit))
+                    {
+                        bConsistent = true;
+                        bConsistentForSomeGroup = true;
+                        break;
+                    }
                 }
-                if(nCurrentConsistency>=mnCovisibilityConsistencyTh && !bEnoughConsistent)
+
+                if (bConsistent)
                 {
-                    mvpEnoughConsistentCandidates.push_back(pCandidateKF);
-                    bEnoughConsistent=true; //this avoid to insert the same candidate more than once
+                    int nPreviousConsistency = mvConsistentGroups[iG].second;
+                    int nCurrentConsistency = nPreviousConsistency + 1;
+                    if (!vbConsistentGroup[iG])
+                    {
+                        ConsistentGroup cg = make_pair(spCandidateGroup, nCurrentConsistency);
+                        vCurrentConsistentGroups.push_back(cg);
+                        vbConsistentGroup[iG] = true; // this avoid to include the same group more than once
+                    }
+                    if (nCurrentConsistency >= mnCovisibilityConsistencyTh && !bEnoughConsistent)
+                    {
+                        mvpEnoughConsistentCandidates.push_back(pCandidateKF);
+                        bEnoughConsistent = true; // this avoid to insert the same candidate more than once
+                    }
                 }
             }
-        }
 
-        // If the group is not consistent with any previous group insert with consistency counter set to zero
-        if(!bConsistentForSomeGroup)
-        {
-            ConsistentGroup cg = make_pair(spCandidateGroup,0);
-            vCurrentConsistentGroups.push_back(cg);
+            // If the group is not consistent with any previous group insert with consistency counter set to zero
+            if (!bConsistentForSomeGroup)
+            {
+                ConsistentGroup cg = make_pair(spCandidateGroup, 0);
+                vCurrentConsistentGroups.push_back(cg);
+            }
         }
-    }
 
-    // Update Covisibility Consistent Groups
-    mvConsistentGroups = vCurrentConsistentGroups;
+        // Update Covisibility Consistent Groups
+        mvConsistentGroups = vCurrentConsistentGroups;
 
+        // Add Current Keyframe to database
+        mpKeyFrameDB->add(mpCurrentKF);
 
-    // Add Current Keyframe to database
-    mpKeyFrameDB->add(mpCurrentKF);
+        if (mvpEnoughConsistentCandidates.empty())
+        {
+            mpCurrentKF->SetErase();
+            return false;
+        }
+        else
+        {
+            return true;
+        }
 
-    if(mvpEnoughConsistentCandidates.empty())
-    {
         mpCurrentKF->SetErase();
         return false;
     }
-    else
+
+    bool LoopClosing::ComputeSim3()
     {
-        return true;
-    }
+        // For each consistent loop candidate we try to compute a Sim3
 
-    mpCurrentKF->SetErase();
-    return false;
-}
+        const int nInitialCandidates = mvpEnoughConsistentCandidates.size();
 
-bool LoopClosing::ComputeSim3()
-{
-    // For each consistent loop candidate we try to compute a Sim3
+        // We compute first ORB matches for each candidate
+        // If enough matches are found, we setup a Sim3Solver
+        ORBmatcher matcher(0.75, true);
 
-    const int nInitialCandidates = mvpEnoughConsistentCandidates.size();
+        vector<Sim3Solver *> vpSim3Solvers;
+        vpSim3Solvers.resize(nInitialCandidates);
 
-    // We compute first ORB matches for each candidate
-    // If enough matches are found, we setup a Sim3Solver
-    ORBmatcher matcher(0.75,true);
+        vector<vector<MapPoint *>> vvpMapPointMatches;
+        vvpMapPointMatches.resize(nInitialCandidates);
 
-    vector<Sim3Solver*> vpSim3Solvers;
-    vpSim3Solvers.resize(nInitialCandidates);
+        vector<bool> vbDiscarded;
+        vbDiscarded.resize(nInitialCandidates);
 
-    vector<vector<MapPoint*> > vvpMapPointMatches;
-    vvpMapPointMatches.resize(nInitialCandidates);
+        int nCandidates = 0; // candidates with enough matches
 
-    vector<bool> vbDiscarded;
-    vbDiscarded.resize(nInitialCandidates);
-
-    int nCandidates=0; //candidates with enough matches
+        for (int i = 0; i < nInitialCandidates; i++)
+        {
+            KeyFrame *pKF = mvpEnoughConsistentCandidates[i];
 
-    for(int i=0; i<nInitialCandidates; i++)
-    {
-        KeyFrame* pKF = mvpEnoughConsistentCandidates[i];
+            // avoid that local mapping erase it while it is being processed in this thread
+            pKF->SetNotErase();
 
-        // avoid that local mapping erase it while it is being processed in this thread
-        pKF->SetNotErase();
+            if (pKF->isBad())
+            {
+                vbDiscarded[i] = true;
+                continue;
+            }
 
-        if(pKF->isBad())
-        {
-            vbDiscarded[i] = true;
-            continue;
-        }
+            int nmatches = matcher.SearchByBoW(mpCurrentKF, pKF, vvpMapPointMatches[i]);
 
-        int nmatches = matcher.SearchByBoW(mpCurrentKF,pKF,vvpMapPointMatches[i]);
+            if (nmatches < 20)
+            {
+                vbDiscarded[i] = true;
+                continue;
+            }
+            else
+            {
+                Sim3Solver *pSolver = new Sim3Solver(mpCurrentKF, pKF, vvpMapPointMatches[i], mbFixScale);
+                pSolver->SetRansacParameters(0.99, 20, 300);
+                vpSim3Solvers[i] = pSolver;
+            }
 
-        if(nmatches<20)
-        {
-            vbDiscarded[i] = true;
-            continue;
-        }
-        else
-        {
-            Sim3Solver* pSolver = new Sim3Solver(mpCurrentKF,pKF,vvpMapPointMatches[i],mbFixScale);
-            pSolver->SetRansacParameters(0.99,20,300);
-            vpSim3Solvers[i] = pSolver;
+            nCandidates++;
         }
 
-        nCandidates++;
-    }
-
-    bool bMatch = false;
+        bool bMatch = false;
 
-    // Perform alternatively RANSAC iterations for each candidate
-    // until one is succesful or all fail
-    while(nCandidates>0 && !bMatch)
-    {
-        for(int i=0; i<nInitialCandidates; i++)
+        // Perform alternatively RANSAC iterations for each candidate
+        // until one is succesful or all fail
+        while (nCandidates > 0 && !bMatch)
         {
-            if(vbDiscarded[i])
-                continue;
+            for (int i = 0; i < nInitialCandidates; i++)
+            {
+                if (vbDiscarded[i])
+                    continue;
 
-            KeyFrame* pKF = mvpEnoughConsistentCandidates[i];
+                KeyFrame *pKF = mvpEnoughConsistentCandidates[i];
 
-            // Perform 5 Ransac Iterations
-            vector<bool> vbInliers;
-            int nInliers;
-            bool bNoMore;
+                // Perform 5 Ransac Iterations
+                vector<bool> vbInliers;
+                int nInliers;
+                bool bNoMore;
 
-            Sim3Solver* pSolver = vpSim3Solvers[i];
-            cv::Mat Scm  = pSolver->iterate(5,bNoMore,vbInliers,nInliers);
+                Sim3Solver *pSolver = vpSim3Solvers[i];
+                cv::Mat Scm = pSolver->iterate(5, bNoMore, vbInliers, nInliers);
 
-            // If Ransac reachs max. iterations discard keyframe
-            if(bNoMore)
-            {
-                vbDiscarded[i]=true;
-                nCandidates--;
-            }
-
-            // If RANSAC returns a Sim3, perform a guided matching and optimize with all correspondences
-            if(!Scm.empty())
-            {
-                vector<MapPoint*> vpMapPointMatches(vvpMapPointMatches[i].size(), static_cast<MapPoint*>(NULL));
-                for(size_t j=0, jend=vbInliers.size(); j<jend; j++)
+                // If Ransac reachs max. iterations discard keyframe
+                if (bNoMore)
                 {
-                    if(vbInliers[j])
-                       vpMapPointMatches[j]=vvpMapPointMatches[i][j];
+                    vbDiscarded[i] = true;
+                    nCandidates--;
                 }
 
-                cv::Mat R = pSolver->GetEstimatedRotation();
-                cv::Mat t = pSolver->GetEstimatedTranslation();
-                const float s = pSolver->GetEstimatedScale();
-                matcher.SearchBySim3(mpCurrentKF,pKF,vpMapPointMatches,s,R,t,7.5);
+                // If RANSAC returns a Sim3, perform a guided matching and optimize with all correspondences
+                if (!Scm.empty())
+                {
+                    vector<MapPoint *> vpMapPointMatches(vvpMapPointMatches[i].size(), static_cast<MapPoint *>(NULL));
+                    for (size_t j = 0, jend = vbInliers.size(); j < jend; j++)
+                    {
+                        if (vbInliers[j])
+                            vpMapPointMatches[j] = vvpMapPointMatches[i][j];
+                    }
 
-                g2o::Sim3 gScm(Converter::toMatrix3d(R),Converter::toVector3d(t),s);
-                const int nInliers = Optimizer::OptimizeSim3(mpCurrentKF, pKF, vpMapPointMatches, gScm, 10, mbFixScale);
+                    cv::Mat R = pSolver->GetEstimatedRotation();
+                    cv::Mat t = pSolver->GetEstimatedTranslation();
+                    const float s = pSolver->GetEstimatedScale();
+                    matcher.SearchBySim3(mpCurrentKF, pKF, vpMapPointMatches, s, R, t, 7.5);
 
-                // If optimization is succesful stop ransacs and continue
-                if(nInliers>=20)
-                {
-                    bMatch = true;
-                    mpMatchedKF = pKF;
-                    g2o::Sim3 gSmw(Converter::toMatrix3d(pKF->GetRotation()),Converter::toVector3d(pKF->GetTranslation()),1.0);
-                    mg2oScw = gScm*gSmw;
-                    mScw = Converter::toCvMat(mg2oScw);
+                    g2o::Sim3 gScm(Converter::toMatrix3d(R), Converter::toVector3d(t), s);
+                    const int nInliers = Optimizer::OptimizeSim3(mpCurrentKF, pKF, vpMapPointMatches, gScm, 10, mbFixScale);
 
-                    mvpCurrentMatchedPoints = vpMapPointMatches;
-                    break;
+                    // If optimization is succesful stop ransacs and continue
+                    if (nInliers >= 20)
+                    {
+                        bMatch = true;
+                        mpMatchedKF = pKF;
+                        g2o::Sim3 gSmw(Converter::toMatrix3d(pKF->GetRotation()), Converter::toVector3d(pKF->GetTranslation()), 1.0);
+                        mg2oScw = gScm * gSmw;
+                        mScw = Converter::toCvMat(mg2oScw);
+
+                        mvpCurrentMatchedPoints = vpMapPointMatches;
+                        break;
+                    }
                 }
             }
         }
-    }
 
-    if(!bMatch)
-    {
-        for(int i=0; i<nInitialCandidates; i++)
-             mvpEnoughConsistentCandidates[i]->SetErase();
-        mpCurrentKF->SetErase();
-        return false;
-    }
+        if (!bMatch)
+        {
+            for (int i = 0; i < nInitialCandidates; i++)
+                mvpEnoughConsistentCandidates[i]->SetErase();
+            mpCurrentKF->SetErase();
+            return false;
+        }
 
-    // Retrieve MapPoints seen in Loop Keyframe and neighbors
-    vector<KeyFrame*> vpLoopConnectedKFs = mpMatchedKF->GetVectorCovisibleKeyFrames();
-    vpLoopConnectedKFs.push_back(mpMatchedKF);
-    mvpLoopMapPoints.clear();
-    for(vector<KeyFrame*>::iterator vit=vpLoopConnectedKFs.begin(); vit!=vpLoopConnectedKFs.end(); vit++)
-    {
-        KeyFrame* pKF = *vit;
-        vector<MapPoint*> vpMapPoints = pKF->GetMapPointMatches();
-        for(size_t i=0, iend=vpMapPoints.size(); i<iend; i++)
+        // Retrieve MapPoints seen in Loop Keyframe and neighbors
+        vector<KeyFrame *> vpLoopConnectedKFs = mpMatchedKF->GetVectorCovisibleKeyFrames();
+        vpLoopConnectedKFs.push_back(mpMatchedKF);
+        mvpLoopMapPoints.clear();
+        for (vector<KeyFrame *>::iterator vit = vpLoopConnectedKFs.begin(); vit != vpLoopConnectedKFs.end(); vit++)
         {
-            MapPoint* pMP = vpMapPoints[i];
-            if(pMP)
+            KeyFrame *pKF = *vit;
+            vector<MapPoint *> vpMapPoints = pKF->GetMapPointMatches();
+            for (size_t i = 0, iend = vpMapPoints.size(); i < iend; i++)
             {
-                if(!pMP->isBad() && pMP->mnLoopPointForKF!=mpCurrentKF->mnId)
+                MapPoint *pMP = vpMapPoints[i];
+                if (pMP)
                 {
-                    mvpLoopMapPoints.push_back(pMP);
-                    pMP->mnLoopPointForKF=mpCurrentKF->mnId;
+                    if (!pMP->isBad() && pMP->mnLoopPointForKF != mpCurrentKF->mnId)
+                    {
+                        mvpLoopMapPoints.push_back(pMP);
+                        pMP->mnLoopPointForKF = mpCurrentKF->mnId;
+                    }
                 }
             }
         }
-    }
 
-    // Find more matches projecting with the computed Sim3
-    matcher.SearchByProjection(mpCurrentKF, mScw, mvpLoopMapPoints, mvpCurrentMatchedPoints,10);
+        // Find more matches projecting with the computed Sim3
+        matcher.SearchByProjection(mpCurrentKF, mScw, mvpLoopMapPoints, mvpCurrentMatchedPoints, 10);
 
-    // If enough matches accept Loop
-    int nTotalMatches = 0;
-    for(size_t i=0; i<mvpCurrentMatchedPoints.size(); i++)
-    {
-        if(mvpCurrentMatchedPoints[i])
-            nTotalMatches++;
-    }
+        // If enough matches accept Loop
+        int nTotalMatches = 0;
+        for (size_t i = 0; i < mvpCurrentMatchedPoints.size(); i++)
+        {
+            if (mvpCurrentMatchedPoints[i])
+                nTotalMatches++;
+        }
 
-    if(nTotalMatches>=40)
-    {
-        for(int i=0; i<nInitialCandidates; i++)
-            if(mvpEnoughConsistentCandidates[i]!=mpMatchedKF)
+        if (nTotalMatches >= 40)
+        {
+            for (int i = 0; i < nInitialCandidates; i++)
+                if (mvpEnoughConsistentCandidates[i] != mpMatchedKF)
+                    mvpEnoughConsistentCandidates[i]->SetErase();
+            return true;
+        }
+        else
+        {
+            for (int i = 0; i < nInitialCandidates; i++)
                 mvpEnoughConsistentCandidates[i]->SetErase();
-        return true;
-    }
-    else
-    {
-        for(int i=0; i<nInitialCandidates; i++)
-            mvpEnoughConsistentCandidates[i]->SetErase();
-        mpCurrentKF->SetErase();
-        return false;
+            mpCurrentKF->SetErase();
+            return false;
+        }
     }
 
-}
-
-void LoopClosing::CorrectLoop()
-{
-    cout << "Loop detected!" << endl;
-
-    // Send a stop signal to Local Mapping
-    // Avoid new keyframes are inserted while correcting the loop
-    mpLocalMapper->RequestStop();
-
-    // If a Global Bundle Adjustment is running, abort it
-    if(isRunningGBA())
+    void LoopClosing::CorrectLoop()
     {
-        mbStopGBA = true;
+        cout << "Loop detected!" << endl;
 
-        while(!isFinishedGBA())
-            usleep(5000);
+        // Send a stop signal to Local Mapping
+        // Avoid new keyframes are inserted while correcting the loop
+        mpLocalMapper->RequestStop();
 
-        mpThreadGBA->join();
-        delete mpThreadGBA;
-    }
+        // If a Global Bundle Adjustment is running, abort it
+        if (isRunningGBA())
+        {
+            mbStopGBA = true;
 
-    // Wait until Local Mapping has effectively stopped
-    while(!mpLocalMapper->isStopped())
-    {
-        usleep(1000);
-    }
+            while (!isFinishedGBA())
+                Sleep(5);
 
-    // Ensure current keyframe is updated
-    mpCurrentKF->UpdateConnections();
+            mpThreadGBA->join();
+            delete mpThreadGBA;
+        }
 
-    // Retrive keyframes connected to the current keyframe and compute corrected Sim3 pose by propagation
-    mvpCurrentConnectedKFs = mpCurrentKF->GetVectorCovisibleKeyFrames();
-    mvpCurrentConnectedKFs.push_back(mpCurrentKF);
+        // Wait until Local Mapping has effectively stopped
+        while (!mpLocalMapper->isStopped())
+        {
+            Sleep(1);
+        }
 
-    KeyFrameAndPose CorrectedSim3, NonCorrectedSim3;
-    CorrectedSim3[mpCurrentKF]=mg2oScw;
-    cv::Mat Twc = mpCurrentKF->GetPoseInverse();
+        // Ensure current keyframe is updated
+        mpCurrentKF->UpdateConnections();
 
+        // Retrive keyframes connected to the current keyframe and compute corrected Sim3 pose by propagation
+        mvpCurrentConnectedKFs = mpCurrentKF->GetVectorCovisibleKeyFrames();
+        mvpCurrentConnectedKFs.push_back(mpCurrentKF);
 
-    {
-        // Get Map Mutex
-        unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
+        KeyFrameAndPose CorrectedSim3, NonCorrectedSim3;
+        CorrectedSim3[mpCurrentKF] = mg2oScw;
+        cv::Mat Twc = mpCurrentKF->GetPoseInverse();
 
-        for(vector<KeyFrame*>::iterator vit=mvpCurrentConnectedKFs.begin(), vend=mvpCurrentConnectedKFs.end(); vit!=vend; vit++)
         {
-            KeyFrame* pKFi = *vit;
-
-            cv::Mat Tiw = pKFi->GetPose();
+            // Get Map Mutex
+            unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
 
-            if(pKFi!=mpCurrentKF)
+            for (vector<KeyFrame *>::iterator vit = mvpCurrentConnectedKFs.begin(), vend = mvpCurrentConnectedKFs.end(); vit != vend; vit++)
             {
-                cv::Mat Tic = Tiw*Twc;
-                cv::Mat Ric = Tic.rowRange(0,3).colRange(0,3);
-                cv::Mat tic = Tic.rowRange(0,3).col(3);
-                g2o::Sim3 g2oSic(Converter::toMatrix3d(Ric),Converter::toVector3d(tic),1.0);
-                g2o::Sim3 g2oCorrectedSiw = g2oSic*mg2oScw;
-                //Pose corrected with the Sim3 of the loop closure
-                CorrectedSim3[pKFi]=g2oCorrectedSiw;
-            }
+                KeyFrame *pKFi = *vit;
 
-            cv::Mat Riw = Tiw.rowRange(0,3).colRange(0,3);
-            cv::Mat tiw = Tiw.rowRange(0,3).col(3);
-            g2o::Sim3 g2oSiw(Converter::toMatrix3d(Riw),Converter::toVector3d(tiw),1.0);
-            //Pose without correction
-            NonCorrectedSim3[pKFi]=g2oSiw;
-        }
+                cv::Mat Tiw = pKFi->GetPose();
 
-        // Correct all MapPoints obsrved by current keyframe and neighbors, so that they align with the other side of the loop
-        for(KeyFrameAndPose::iterator mit=CorrectedSim3.begin(), mend=CorrectedSim3.end(); mit!=mend; mit++)
-        {
-            KeyFrame* pKFi = mit->first;
-            g2o::Sim3 g2oCorrectedSiw = mit->second;
-            g2o::Sim3 g2oCorrectedSwi = g2oCorrectedSiw.inverse();
+                if (pKFi != mpCurrentKF)
+                {
+                    cv::Mat Tic = Tiw * Twc;
+                    cv::Mat Ric = Tic.rowRange(0, 3).colRange(0, 3);
+                    cv::Mat tic = Tic.rowRange(0, 3).col(3);
+                    g2o::Sim3 g2oSic(Converter::toMatrix3d(Ric), Converter::toVector3d(tic), 1.0);
+                    g2o::Sim3 g2oCorrectedSiw = g2oSic * mg2oScw;
+                    // Pose corrected with the Sim3 of the loop closure
+                    CorrectedSim3[pKFi] = g2oCorrectedSiw;
+                }
 
-            g2o::Sim3 g2oSiw =NonCorrectedSim3[pKFi];
+                cv::Mat Riw = Tiw.rowRange(0, 3).colRange(0, 3);
+                cv::Mat tiw = Tiw.rowRange(0, 3).col(3);
+                g2o::Sim3 g2oSiw(Converter::toMatrix3d(Riw), Converter::toVector3d(tiw), 1.0);
+                // Pose without correction
+                NonCorrectedSim3[pKFi] = g2oSiw;
+            }
 
-            vector<MapPoint*> vpMPsi = pKFi->GetMapPointMatches();
-            for(size_t iMP=0, endMPi = vpMPsi.size(); iMP<endMPi; iMP++)
+            // Correct all MapPoints obsrved by current keyframe and neighbors, so that they align with the other side of the loop
+            for (KeyFrameAndPose::iterator mit = CorrectedSim3.begin(), mend = CorrectedSim3.end(); mit != mend; mit++)
             {
-                MapPoint* pMPi = vpMPsi[iMP];
-                if(!pMPi)
-                    continue;
-                if(pMPi->isBad())
-                    continue;
-                if(pMPi->mnCorrectedByKF==mpCurrentKF->mnId)
-                    continue;
+                KeyFrame *pKFi = mit->first;
+                g2o::Sim3 g2oCorrectedSiw = mit->second;
+                g2o::Sim3 g2oCorrectedSwi = g2oCorrectedSiw.inverse();
 
-                // Project with non-corrected pose and project back with corrected pose
-                cv::Mat P3Dw = pMPi->GetWorldPos();
-                Eigen::Matrix<double,3,1> eigP3Dw = Converter::toVector3d(P3Dw);
-                Eigen::Matrix<double,3,1> eigCorrectedP3Dw = g2oCorrectedSwi.map(g2oSiw.map(eigP3Dw));
+                g2o::Sim3 g2oSiw = NonCorrectedSim3[pKFi];
 
-                cv::Mat cvCorrectedP3Dw = Converter::toCvMat(eigCorrectedP3Dw);
-                pMPi->SetWorldPos(cvCorrectedP3Dw);
-                pMPi->mnCorrectedByKF = mpCurrentKF->mnId;
-                pMPi->mnCorrectedReference = pKFi->mnId;
-                pMPi->UpdateNormalAndDepth();
-            }
+                vector<MapPoint *> vpMPsi = pKFi->GetMapPointMatches();
+                for (size_t iMP = 0, endMPi = vpMPsi.size(); iMP < endMPi; iMP++)
+                {
+                    MapPoint *pMPi = vpMPsi[iMP];
+                    if (!pMPi)
+                        continue;
+                    if (pMPi->isBad())
+                        continue;
+                    if (pMPi->mnCorrectedByKF == mpCurrentKF->mnId)
+                        continue;
 
-            // Update keyframe pose with corrected Sim3. First transform Sim3 to SE3 (scale translation)
-            Eigen::Matrix3d eigR = g2oCorrectedSiw.rotation().toRotationMatrix();
-            Eigen::Vector3d eigt = g2oCorrectedSiw.translation();
-            double s = g2oCorrectedSiw.scale();
+                    // Project with non-corrected pose and project back with corrected pose
+                    cv::Mat P3Dw = pMPi->GetWorldPos();
+                    Eigen::Matrix<double, 3, 1> eigP3Dw = Converter::toVector3d(P3Dw);
+                    Eigen::Matrix<double, 3, 1> eigCorrectedP3Dw = g2oCorrectedSwi.map(g2oSiw.map(eigP3Dw));
 
-            eigt *=(1./s); //[R t/s;0 1]
+                    cv::Mat cvCorrectedP3Dw = Converter::toCvMat(eigCorrectedP3Dw);
+                    pMPi->SetWorldPos(cvCorrectedP3Dw);
+                    pMPi->mnCorrectedByKF = mpCurrentKF->mnId;
+                    pMPi->mnCorrectedReference = pKFi->mnId;
+                    pMPi->UpdateNormalAndDepth();
+                }
 
-            cv::Mat correctedTiw = Converter::toCvSE3(eigR,eigt);
+                // Update keyframe pose with corrected Sim3. First transform Sim3 to SE3 (scale translation)
+                Eigen::Matrix3d eigR = g2oCorrectedSiw.rotation().toRotationMatrix();
+                Eigen::Vector3d eigt = g2oCorrectedSiw.translation();
+                double s = g2oCorrectedSiw.scale();
 
-            pKFi->SetPose(correctedTiw);
+                eigt *= (1. / s); //[R t/s;0 1]
 
-            // Make sure connections are updated
-            pKFi->UpdateConnections();
-        }
+                cv::Mat correctedTiw = Converter::toCvSE3(eigR, eigt);
 
-        // Start Loop Fusion
-        // Update matched map points and replace if duplicated
-        for(size_t i=0; i<mvpCurrentMatchedPoints.size(); i++)
-        {
-            if(mvpCurrentMatchedPoints[i])
+                pKFi->SetPose(correctedTiw);
+
+                // Make sure connections are updated
+                pKFi->UpdateConnections();
+            }
+
+            // Start Loop Fusion
+            // Update matched map points and replace if duplicated
+            for (size_t i = 0; i < mvpCurrentMatchedPoints.size(); i++)
             {
-                MapPoint* pLoopMP = mvpCurrentMatchedPoints[i];
-                MapPoint* pCurMP = mpCurrentKF->GetMapPoint(i);
-                if(pCurMP)
-                    pCurMP->Replace(pLoopMP);
-                else
+                if (mvpCurrentMatchedPoints[i])
                 {
-                    mpCurrentKF->AddMapPoint(pLoopMP,i);
-                    pLoopMP->AddObservation(mpCurrentKF,i);
-                    pLoopMP->ComputeDistinctiveDescriptors();
+                    MapPoint *pLoopMP = mvpCurrentMatchedPoints[i];
+                    MapPoint *pCurMP = mpCurrentKF->GetMapPoint(i);
+                    if (pCurMP)
+                        pCurMP->Replace(pLoopMP);
+                    else
+                    {
+                        mpCurrentKF->AddMapPoint(pLoopMP, i);
+                        pLoopMP->AddObservation(mpCurrentKF, i);
+                        pLoopMP->ComputeDistinctiveDescriptors();
+                    }
                 }
             }
         }
 
-    }
-
-    // Project MapPoints observed in the neighborhood of the loop keyframe
-    // into the current keyframe and neighbors using corrected poses.
-    // Fuse duplications.
-    SearchAndFuse(CorrectedSim3);
-
+        // Project MapPoints observed in the neighborhood of the loop keyframe
+        // into the current keyframe and neighbors using corrected poses.
+        // Fuse duplications.
+        SearchAndFuse(CorrectedSim3);
 
-    // After the MapPoint fusion, new links in the covisibility graph will appear attaching both sides of the loop
-    map<KeyFrame*, set<KeyFrame*> > LoopConnections;
+        // After the MapPoint fusion, new links in the covisibility graph will appear attaching both sides of the loop
+        map<KeyFrame *, set<KeyFrame *>> LoopConnections;
 
-    for(vector<KeyFrame*>::iterator vit=mvpCurrentConnectedKFs.begin(), vend=mvpCurrentConnectedKFs.end(); vit!=vend; vit++)
-    {
-        KeyFrame* pKFi = *vit;
-        vector<KeyFrame*> vpPreviousNeighbors = pKFi->GetVectorCovisibleKeyFrames();
-
-        // Update connections. Detect new links.
-        pKFi->UpdateConnections();
-        LoopConnections[pKFi]=pKFi->GetConnectedKeyFrames();
-        for(vector<KeyFrame*>::iterator vit_prev=vpPreviousNeighbors.begin(), vend_prev=vpPreviousNeighbors.end(); vit_prev!=vend_prev; vit_prev++)
-        {
-            LoopConnections[pKFi].erase(*vit_prev);
-        }
-        for(vector<KeyFrame*>::iterator vit2=mvpCurrentConnectedKFs.begin(), vend2=mvpCurrentConnectedKFs.end(); vit2!=vend2; vit2++)
+        for (vector<KeyFrame *>::iterator vit = mvpCurrentConnectedKFs.begin(), vend = mvpCurrentConnectedKFs.end(); vit != vend; vit++)
         {
-            LoopConnections[pKFi].erase(*vit2);
-        }
-    }
+            KeyFrame *pKFi = *vit;
+            vector<KeyFrame *> vpPreviousNeighbors = pKFi->GetVectorCovisibleKeyFrames();
 
-    // Optimize graph
-    Optimizer::OptimizeEssentialGraph(mpMap, mpMatchedKF, mpCurrentKF, NonCorrectedSim3, CorrectedSim3, LoopConnections, mbFixScale);
+            // Update connections. Detect new links.
+            pKFi->UpdateConnections();
+            LoopConnections[pKFi] = pKFi->GetConnectedKeyFrames();
+            for (vector<KeyFrame *>::iterator vit_prev = vpPreviousNeighbors.begin(), vend_prev = vpPreviousNeighbors.end(); vit_prev != vend_prev; vit_prev++)
+            {
+                LoopConnections[pKFi].erase(*vit_prev);
+            }
+            for (vector<KeyFrame *>::iterator vit2 = mvpCurrentConnectedKFs.begin(), vend2 = mvpCurrentConnectedKFs.end(); vit2 != vend2; vit2++)
+            {
+                LoopConnections[pKFi].erase(*vit2);
+            }
+        }
 
-    // Add loop edge
-    mpMatchedKF->AddLoopEdge(mpCurrentKF);
-    mpCurrentKF->AddLoopEdge(mpMatchedKF);
+        // Optimize graph
+        Optimizer::OptimizeEssentialGraph(mpMap, mpMatchedKF, mpCurrentKF, NonCorrectedSim3, CorrectedSim3, LoopConnections, mbFixScale);
 
-    // Launch a new thread to perform Global Bundle Adjustment
-    mbRunningGBA = true;
-    mbFinishedGBA = false;
-    mbStopGBA = false;
-    mpThreadGBA = new thread(&LoopClosing::RunGlobalBundleAdjustment,this,mpCurrentKF->mnId);
+        // Add loop edge
+        mpMatchedKF->AddLoopEdge(mpCurrentKF);
+        mpCurrentKF->AddLoopEdge(mpMatchedKF);
 
-    // Loop closed. Release Local Mapping.
-    mpLocalMapper->Release();    
+        // Launch a new thread to perform Global Bundle Adjustment
+        mbRunningGBA = true;
+        mbFinishedGBA = false;
+        mbStopGBA = false;
+        mpThreadGBA = new thread(&LoopClosing::RunGlobalBundleAdjustment, this, mpCurrentKF->mnId);
 
-    cout << "Loop Closed!" << endl;
+        // Loop closed. Release Local Mapping.
+        mpLocalMapper->Release();
 
-    mLastLoopKFid = mpCurrentKF->mnId;   
-}
+        cout << "Loop Closed!" << endl;
 
-void LoopClosing::SearchAndFuse(const KeyFrameAndPose &CorrectedPosesMap)
-{
-    ORBmatcher matcher(0.8);
+        mLastLoopKFid = mpCurrentKF->mnId;
+    }
 
-    for(KeyFrameAndPose::const_iterator mit=CorrectedPosesMap.begin(), mend=CorrectedPosesMap.end(); mit!=mend;mit++)
+    void LoopClosing::SearchAndFuse(const KeyFrameAndPose &CorrectedPosesMap)
     {
-        KeyFrame* pKF = mit->first;
+        ORBmatcher matcher(0.8);
 
-        g2o::Sim3 g2oScw = mit->second;
-        cv::Mat cvScw = Converter::toCvMat(g2oScw);
+        for (KeyFrameAndPose::const_iterator mit = CorrectedPosesMap.begin(), mend = CorrectedPosesMap.end(); mit != mend; mit++)
+        {
+            KeyFrame *pKF = mit->first;
 
-        vector<MapPoint*> vpReplacePoints(mvpLoopMapPoints.size(),static_cast<MapPoint*>(NULL));
-        matcher.Fuse(pKF,cvScw,mvpLoopMapPoints,4,vpReplacePoints);
+            g2o::Sim3 g2oScw = mit->second;
+            cv::Mat cvScw = Converter::toCvMat(g2oScw);
 
-        // Get Map Mutex
-        unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
-        const int nLP = mvpLoopMapPoints.size();
-        for(int i=0; i<nLP;i++)
-        {
-            MapPoint* pRep = vpReplacePoints[i];
-            if(pRep)
+            vector<MapPoint *> vpReplacePoints(mvpLoopMapPoints.size(), static_cast<MapPoint *>(NULL));
+            matcher.Fuse(pKF, cvScw, mvpLoopMapPoints, 4, vpReplacePoints);
+
+            // Get Map Mutex
+            unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
+            const int nLP = mvpLoopMapPoints.size();
+            for (int i = 0; i < nLP; i++)
             {
-                pRep->Replace(mvpLoopMapPoints[i]);
+                MapPoint *pRep = vpReplacePoints[i];
+                if (pRep)
+                {
+                    pRep->Replace(mvpLoopMapPoints[i]);
+                }
             }
         }
     }
-}
-
 
-void LoopClosing::RequestReset()
-{
+    void LoopClosing::RequestReset()
     {
-        unique_lock<mutex> lock(mMutexReset);
-        mbResetRequested = true;
-    }
+        {
+            unique_lock<mutex> lock(mMutexReset);
+            mbResetRequested = true;
+        }
 
-    while(1)
-    {
+        while (1)
         {
-        unique_lock<mutex> lock2(mMutexReset);
-        if(!mbResetRequested)
-            break;
+            {
+                unique_lock<mutex> lock2(mMutexReset);
+                if (!mbResetRequested)
+                    break;
+            }
+            Sleep(5);
         }
-        usleep(5000);
     }
-}
 
-void LoopClosing::ResetIfRequested()
-{
-    unique_lock<mutex> lock(mMutexReset);
-    if(mbResetRequested)
+    void LoopClosing::ResetIfRequested()
     {
-        mlpLoopKeyFrameQueue.clear();
-        mLastLoopKFid=0;
-        mbResetRequested=false;
+        unique_lock<mutex> lock(mMutexReset);
+        if (mbResetRequested)
+        {
+            mlpLoopKeyFrameQueue.clear();
+            mLastLoopKFid = 0;
+            mbResetRequested = false;
+        }
     }
-}
-
-void LoopClosing::RunGlobalBundleAdjustment(unsigned long nLoopKF)
-{
-    cout << "Starting Global Bundle Adjustment" << endl;
 
-    Optimizer::GlobalBundleAdjustemnt(mpMap,20,&mbStopGBA,nLoopKF,false);
-
-    // Update all MapPoints and KeyFrames
-    // Local Mapping was active during BA, that means that there might be new keyframes
-    // not included in the Global BA and they are not consistent with the updated map.
-    // We need to propagate the correction through the spanning tree
+    void LoopClosing::RunGlobalBundleAdjustment(unsigned long nLoopKF)
     {
-        unique_lock<mutex> lock(mMutexGBA);
+        cout << "Starting Global Bundle Adjustment" << endl;
 
+        Optimizer::GlobalBundleAdjustemnt(mpMap, 20, &mbStopGBA, nLoopKF, false);
 
-        if(!mbStopGBA)
+        // Update all MapPoints and KeyFrames
+        // Local Mapping was active during BA, that means that there might be new keyframes
+        // not included in the Global BA and they are not consistent with the updated map.
+        // We need to propagate the correction through the spanning tree
         {
-            cout << "Global Bundle Adjustment finished" << endl;
-            cout << "Updating map ..." << endl;
-            mpLocalMapper->RequestStop();
-            // Wait until Local Mapping has effectively stopped
-
-            while(!mpLocalMapper->isStopped() && !mpLocalMapper->isFinished())
-            {
-                usleep(1000);
-            }
-                      
-
-            // Get Map Mutex
-            unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
-
-            // Correct keyframes starting at map first keyframe
-            list<KeyFrame*> lpKFtoCheck(mpMap->mvpKeyFrameOrigins.begin(),mpMap->mvpKeyFrameOrigins.end());
+            unique_lock<mutex> lock(mMutexGBA);
 
-            while(!lpKFtoCheck.empty())
+            if (!mbStopGBA)
             {
+                cout << "Global Bundle Adjustment finished" << endl;
+                cout << "Updating map ..." << endl;
+                mpLocalMapper->RequestStop();
+                // Wait until Local Mapping has effectively stopped
 
-                KeyFrame* pKF = lpKFtoCheck.front();
-                if (!pKF)
-                    continue;
+                while (!mpLocalMapper->isStopped() && !mpLocalMapper->isFinished())
+                {
+                    Sleep(1);
+                }
 
-                const set<KeyFrame*> sChilds = pKF->GetChilds();
+                // Get Map Mutex
+                unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
 
-                cv::Mat Twc = pKF->GetPoseInverse();
-                       
+                // Correct keyframes starting at map first keyframe
+                list<KeyFrame *> lpKFtoCheck(mpMap->mvpKeyFrameOrigins.begin(), mpMap->mvpKeyFrameOrigins.end());
 
-                for(set<KeyFrame*>::const_iterator sit=sChilds.begin();sit!=sChilds.end();sit++)
+                while (!lpKFtoCheck.empty())
                 {
-                                                                                                          
 
-                    KeyFrame* pChild = *sit;
-                    if (!pChild)
+                    KeyFrame *pKF = lpKFtoCheck.front();
+                    if (!pKF)
                         continue;
 
-                    if(pChild->mnBAGlobalForKF!=nLoopKF)
-                    {
-                                                                 
+                    const set<KeyFrame *> sChilds = pKF->GetChilds();
 
-                        cv::Mat Tchildc = pChild->GetPose()*Twc;
-                                                                 
+                    cv::Mat Twc = pKF->GetPoseInverse();
 
-                        pChild->mTcwGBA = Tchildc*pKF->mTcwGBA;//*Tcorc*pKF->mTcwGBA;
-                                                                                        
+                    for (set<KeyFrame *>::const_iterator sit = sChilds.begin(); sit != sChilds.end(); sit++)
+                    {
 
-                        pChild->mnBAGlobalForKF=nLoopKF;
+                        KeyFrame *pChild = *sit;
+                        if (!pChild)
+                            continue;
 
-                    }
-                    lpKFtoCheck.push_back(pChild);
-                }
+                        if (pChild->mnBAGlobalForKF != nLoopKF)
+                        {
 
-                pKF->mTcwBefGBA = pKF->GetPose();
-                pKF->SetPose(pKF->mTcwGBA);
-                lpKFtoCheck.pop_front();
-            }
-                                                  
+                            cv::Mat Tchildc = pChild->GetPose() * Twc;
 
-            // Correct MapPoints
-            const vector<MapPoint*> vpMPs = mpMap->GetAllMapPoints();
+                            pChild->mTcwGBA = Tchildc * pKF->mTcwGBA; //*Tcorc*pKF->mTcwGBA;
 
-            for(size_t i=0; i<vpMPs.size(); i++)
-            {
-                                    
+                            pChild->mnBAGlobalForKF = nLoopKF;
+                        }
+                        lpKFtoCheck.push_back(pChild);
+                    }
 
-                MapPoint* pMP = vpMPs[i];
-                if(!pMP)
-                    continue;
+                    pKF->mTcwBefGBA = pKF->GetPose();
+                    pKF->SetPose(pKF->mTcwGBA);
+                    lpKFtoCheck.pop_front();
+                }
 
-                if(pMP->isBad())
-                    continue;
+                // Correct MapPoints
+                const vector<MapPoint *> vpMPs = mpMap->GetAllMapPoints();
 
-                if(pMP->mnBAGlobalForKF==nLoopKF)
-                {
-                                                                    
-                    // If optimized by Global BA, just update
-                    pMP->SetWorldPos(pMP->mPosGBA);
-                }
-                else
+                for (size_t i = 0; i < vpMPs.size(); i++)
                 {
-                                                                     
 
-                    // Update according to the correction of its reference keyframe
-                    KeyFrame* pRefKF = pMP->GetReferenceKeyFrame();
-                    if(!pRefKF)
-                        continue;
-                    if(pRefKF->mnBAGlobalForKF!=nLoopKF)
+                    MapPoint *pMP = vpMPs[i];
+                    if (!pMP)
                         continue;
-                   cout << "RunGlobalBundleAdjustment CP " << pRefKF->mnId 
-                        << " " << pRefKF->mTcwBefGBA.rows 
-                        << " " << pRefKF->mTcwBefGBA.cols << endl;
-                    fflush(stdout);
 
-                    /* TODO : Stop-Gap for Loop Closure. Size coming as Zero! */
-                    if (!pRefKF->mTcwBefGBA.rows || !pRefKF->mTcwBefGBA.cols)
+                    if (pMP->isBad())
                         continue;
 
+                    if (pMP->mnBAGlobalForKF == nLoopKF)
+                    {
+
+                        // If optimized by Global BA, just update
+                        pMP->SetWorldPos(pMP->mPosGBA);
+                    }
+                    else
+                    {
 
-                    // Map to non-corrected camera
-                    cv::Mat Rcw = pRefKF->mTcwBefGBA.rowRange(0,3).colRange(0,3);
-                                
+                        // Update according to the correction of its reference keyframe
+                        KeyFrame *pRefKF = pMP->GetReferenceKeyFrame();
+                        if (!pRefKF)
+                            continue;
+                        if (pRefKF->mnBAGlobalForKF != nLoopKF)
+                            continue;
+                        cout << "RunGlobalBundleAdjustment CP " << pRefKF->mnId
+                             << " " << pRefKF->mTcwBefGBA.rows
+                             << " " << pRefKF->mTcwBefGBA.cols << endl;
+                        fflush(stdout);
 
-                    cv::Mat tcw = pRefKF->mTcwBefGBA.rowRange(0,3).col(3);
-                                                                                     
+                        /* TODO : Stop-Gap for Loop Closure. Size coming as Zero! */
+                        if (!pRefKF->mTcwBefGBA.rows || !pRefKF->mTcwBefGBA.cols)
+                            continue;
 
-                    cv::Mat Xc = Rcw*pMP->GetWorldPos()+tcw;
-                                                                    
+                        // Map to non-corrected camera
+                        cv::Mat Rcw = pRefKF->mTcwBefGBA.rowRange(0, 3).colRange(0, 3);
 
-                    // Backproject using corrected camera
-                    cv::Mat Twc = pRefKF->GetPoseInverse();
-                    cv::Mat Rwc = Twc.rowRange(0,3).colRange(0,3);
-                    cv::Mat twc = Twc.rowRange(0,3).col(3);
-                                                             
+                        cv::Mat tcw = pRefKF->mTcwBefGBA.rowRange(0, 3).col(3);
 
-                    pMP->SetWorldPos(Rwc*Xc+twc);
+                        cv::Mat Xc = Rcw * pMP->GetWorldPos() + tcw;
+
+                        // Backproject using corrected camera
+                        cv::Mat Twc = pRefKF->GetPoseInverse();
+                        cv::Mat Rwc = Twc.rowRange(0, 3).colRange(0, 3);
+                        cv::Mat twc = Twc.rowRange(0, 3).col(3);
+
+                        pMP->SetWorldPos(Rwc * Xc + twc);
+                    }
                 }
-            }
 
-            mpLocalMapper->Release();
+                mpLocalMapper->Release();
 
-            cout << "Map updated!" << endl;
-        }
+                cout << "Map updated!" << endl;
+            }
 
-        mbFinishedGBA = true;
-        mbRunningGBA = false;
+            mbFinishedGBA = true;
+            mbRunningGBA = false;
+        }
     }
-}
-
-void LoopClosing::RequestFinish()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    mbFinishRequested = true;
-}
 
-bool LoopClosing::CheckFinish()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    return mbFinishRequested;
-}
+    void LoopClosing::RequestFinish()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        mbFinishRequested = true;
+    }
 
-void LoopClosing::SetFinish()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    mbFinished = true;
-}
+    bool LoopClosing::CheckFinish()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        return mbFinishRequested;
+    }
 
-bool LoopClosing::isFinished()
-{
-    unique_lock<mutex> lock(mMutexFinish);
-    return mbFinished;
-}
+    void LoopClosing::SetFinish()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        mbFinished = true;
+    }
 
+    bool LoopClosing::isFinished()
+    {
+        unique_lock<mutex> lock(mMutexFinish);
+        return mbFinished;
+    }
 
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/MapPoint.cc b/slam/src/MapPoint.cc
index bc33106..180a656 100644
--- a/slam/src/MapPoint.cc
+++ b/slam/src/MapPoint.cc
@@ -1,642 +1,636 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "MapPoint.h"
 #include "ORBmatcher.h"
 
-#include<mutex>
+#include <mutex>
 
 namespace ORB_SLAM2
 {
 
-long unsigned int MapPoint::nNextId=0;
-mutex MapPoint::mGlobalMutex;
-MapPoint::MapPoint():
-    nObs(0), mnTrackReferenceForFrame(0),
-    mnLastFrameSeen(0), mnBALocalForKF(0), mnFuseCandidateForKF(0), mnLoopPointForKF(0), mnCorrectedByKF(0),
-    mnCorrectedReference(0), mnBAGlobalForKF(0),mnVisible(1), mnFound(1), mbBad(false),
-    mpReplaced(static_cast<MapPoint*>(NULL)), mfMinDistance(0), mfMaxDistance(0)
- { 
-    //mNormalVector = cv::Mat::zeros(3,1,CV_32F);
-    //unique_lock<recursive_mutex> lock(mpMap->mMutexPointCreation);
-    //mpMap = new Map();
-    // mpRefKF = new KeyFrame();
- }
-MapPoint::MapPoint(const cv::Mat &Pos, KeyFrame *pRefKF, Map* pMap):
-    mnFirstKFid(pRefKF->mnId), mnFirstFrame(pRefKF->mnFrameId), nObs(0), mnTrackReferenceForFrame(0),
-    mnLastFrameSeen(0), mnBALocalForKF(0), mnFuseCandidateForKF(0), mnLoopPointForKF(0), mnCorrectedByKF(0),
-    mnCorrectedReference(0), mnBAGlobalForKF(0), mpRefKF(pRefKF), mnVisible(1), mnFound(1), mbBad(false),
-    mpReplaced(static_cast<MapPoint*>(NULL)), mfMinDistance(0), mfMaxDistance(0), mpMap(pMap)
-{
-    Pos.copyTo(mWorldPos);
-    mNormalVector = cv::Mat::zeros(3,1,CV_32F);
+    long unsigned int MapPoint::nNextId = 0;
+    mutex MapPoint::mGlobalMutex;
+    MapPoint::MapPoint() : nObs(0), mnTrackReferenceForFrame(0),
+                           mnLastFrameSeen(0), mnBALocalForKF(0), mnFuseCandidateForKF(0), mnLoopPointForKF(0), mnCorrectedByKF(0),
+                           mnCorrectedReference(0), mnBAGlobalForKF(0), mnVisible(1), mnFound(1), mbBad(false),
+                           mpReplaced(static_cast<MapPoint *>(NULL)), mfMinDistance(0), mfMaxDistance(0)
+    {
+        // mNormalVector = cv::Mat::zeros(3,1,CV_32F);
+        // unique_lock<recursive_mutex> lock(mpMap->mMutexPointCreation);
+        // mpMap = new Map();
+        //  mpRefKF = new KeyFrame();
+    }
+    MapPoint::MapPoint(const cv::Mat &Pos, KeyFrame *pRefKF, Map *pMap) : mnFirstKFid(pRefKF->mnId), mnFirstFrame(pRefKF->mnFrameId), nObs(0), mnTrackReferenceForFrame(0),
+                                                                          mnLastFrameSeen(0), mnBALocalForKF(0), mnFuseCandidateForKF(0), mnLoopPointForKF(0), mnCorrectedByKF(0),
+                                                                          mnCorrectedReference(0), mnBAGlobalForKF(0), mpRefKF(pRefKF), mnVisible(1), mnFound(1), mbBad(false),
+                                                                          mpReplaced(static_cast<MapPoint *>(NULL)), mfMinDistance(0), mfMaxDistance(0), mpMap(pMap)
+    {
+        Pos.copyTo(mWorldPos);
+        mNormalVector = cv::Mat::zeros(3, 1, CV_32F);
 
-    // MapPoints can be created from Tracking and Local Mapping. This recursive_mutex avoid conflicts with id.
-    unique_lock<mutex> lock(mpMap->mMutexPointCreation);
-    mnId=nNextId++;
-}
+        // MapPoints can be created from Tracking and Local Mapping. This recursive_mutex avoid conflicts with id.
+        unique_lock<mutex> lock(mpMap->mMutexPointCreation);
+        mnId = nNextId++;
+    }
 
-template<class Archive>
-    void MapPoint::save(Archive & ar, const unsigned int version) const
+    template <class Archive>
+    void MapPoint::save(Archive &ar, const unsigned int version) const
     {
-        unsigned int nItems;bool is_id = false, is_valid = false;;
+        unsigned int nItems;
+        bool is_id = false, is_valid = false;
+        ;
         size_t t_size;
         long unsigned int t_nId;
 
         if (mbBad)
             return;
 
-        ar & const_cast<long unsigned int &> (mnId );
-        //cout << "[" << mnId << "]" ;
-        ar & nNextId;
-        ar & const_cast<long int &> (mnFirstKFid);
-        ar & const_cast<long int &> (mnFirstFrame);
-        ar & const_cast<int &> (nObs);
-        ar & const_cast<float &> (mTrackProjX);
-        ar & const_cast<float &> (mTrackProjY);
-        ar & const_cast<float &> (mTrackProjXR);
-        ar & const_cast<bool &> (mbTrackInView);
-        ar & const_cast<int &> (mnTrackScaleLevel);
-        ar & const_cast<float &> (mTrackViewCos);
-        ar & const_cast<long unsigned int &> (mnTrackReferenceForFrame);
-        ar & const_cast<long unsigned int &> (mnLastFrameSeen);
-        ar & const_cast<long unsigned int &> (mnBALocalForKF);
-        ar & const_cast<long unsigned int &> (mnFuseCandidateForKF);
-        ar & const_cast<long unsigned int &> (mnLoopPointForKF);
-        ar & const_cast<long unsigned int &> (mnCorrectedByKF);
-        ar & const_cast<long unsigned int &> (mnCorrectedReference);
-
-        ar & const_cast<cv::Mat &> (mPosGBA);
-        ar & const_cast<long unsigned int &> (mnBAGlobalForKF);
-        ar & const_cast<cv::Mat &> (mWorldPos);
-        
+        ar &const_cast<long unsigned int &>(mnId);
+        // cout << "[" << mnId << "]" ;
+        ar &nNextId;
+        ar &const_cast<long int &>(mnFirstKFid);
+        ar &const_cast<long int &>(mnFirstFrame);
+        ar &const_cast<int &>(nObs);
+        ar &const_cast<float &>(mTrackProjX);
+        ar &const_cast<float &>(mTrackProjY);
+        ar &const_cast<float &>(mTrackProjXR);
+        ar &const_cast<bool &>(mbTrackInView);
+        ar &const_cast<int &>(mnTrackScaleLevel);
+        ar &const_cast<float &>(mTrackViewCos);
+        ar &const_cast<long unsigned int &>(mnTrackReferenceForFrame);
+        ar &const_cast<long unsigned int &>(mnLastFrameSeen);
+        ar &const_cast<long unsigned int &>(mnBALocalForKF);
+        ar &const_cast<long unsigned int &>(mnFuseCandidateForKF);
+        ar &const_cast<long unsigned int &>(mnLoopPointForKF);
+        ar &const_cast<long unsigned int &>(mnCorrectedByKF);
+        ar &const_cast<long unsigned int &>(mnCorrectedReference);
+
+        ar &const_cast<cv::Mat &>(mPosGBA);
+        ar &const_cast<long unsigned int &>(mnBAGlobalForKF);
+        ar &const_cast<cv::Mat &>(mWorldPos);
+
         // Save each KF point id
         nItems = mObservations.size();
-        ar & nItems;
-                //cout << "{INFO}mvpMapPoints nItems -" << nItems << endl;
-        
-        for (std::map<KeyFrame*,size_t>::const_iterator it = mObservations.begin(); it != mObservations.end(); ++it) {        
+        ar &nItems;
+        // cout << "{INFO}mvpMapPoints nItems -" << nItems << endl;
+
+        for (std::map<KeyFrame *, size_t>::const_iterator it = mObservations.begin(); it != mObservations.end(); ++it)
+        {
             if (it->first == NULL)
             {
                 cout << "{INFO}Map POint Save - Empty observation " << mnId << endl;
 
                 is_id = false;
-                ar & is_id;
+                ar &is_id;
                 continue;
             }
             else
             {
                 is_id = true;
-                ar & is_id;
-                t_nId =  it->first->mnId;
-                ar & t_nId;
+                ar &is_id;
+                t_nId = it->first->mnId;
+                ar &t_nId;
                 t_size = it->second;
-                ar & t_size;
+                ar &t_size;
             }
- 
-            
         }
-        
 
-        ar & const_cast<cv::Mat &> (mNormalVector);
-        ar & const_cast<cv::Mat &> (mDescriptor);
-        if (mpRefKF) {
+        ar &const_cast<cv::Mat &>(mNormalVector);
+        ar &const_cast<cv::Mat &>(mDescriptor);
+        if (mpRefKF)
+        {
             is_valid = true;
-            ar & is_valid;
+            ar &is_valid;
             ar & mpRefKF->mnId;
         }
         else
         {
             is_valid = false;
-            ar & is_valid;
+            ar &is_valid;
         }
-            
-
-        ar & const_cast<int &> (mnVisible);
-        ar & const_cast<int &> (mnFound);
-        ar & const_cast<bool &> (mbBad);
-        ar & const_cast<float &> (mfMinDistance);
-        ar & const_cast<float &> (mfMaxDistance);           
-       
+
+        ar &const_cast<int &>(mnVisible);
+        ar &const_cast<int &>(mnFound);
+        ar &const_cast<bool &>(mbBad);
+        ar &const_cast<float &>(mfMinDistance);
+        ar &const_cast<float &>(mfMaxDistance);
     }
 
-    template<class Archive>
-    void MapPoint::load(Archive & ar, const unsigned int version)
+    template <class Archive>
+    void MapPoint::load(Archive &ar, const unsigned int version)
     {
-        unsigned int nItems;bool is_id = false, is_valid = false;
+        unsigned int nItems;
+        bool is_id = false, is_valid = false;
         size_t t_size;
 
         long unsigned int t_nId;
 
-        ar & const_cast<long unsigned int &> (mnId );
-        //cout << "[" << mnId << "]" ;
-        ar & nNextId;
-        ar & const_cast<long int &> (mnFirstKFid);
-        ar & const_cast<long int &> (mnFirstFrame);
-        ar & const_cast<int &> (nObs);
-        ar & const_cast<float &> (mTrackProjX);
-        ar & const_cast<float &> (mTrackProjY);
-        ar & const_cast<float &> (mTrackProjXR);
-        ar & const_cast<bool &> (mbTrackInView);
-        ar & const_cast<int &> (mnTrackScaleLevel);
-        ar & const_cast<float &> (mTrackViewCos);
-        ar & const_cast<long unsigned int &> (mnTrackReferenceForFrame);
-        ar & const_cast<long unsigned int &> (mnLastFrameSeen);
-        ar & const_cast<long unsigned int &> (mnBALocalForKF);
-        ar & const_cast<long unsigned int &> (mnFuseCandidateForKF);
-        ar & const_cast<long unsigned int &> (mnLoopPointForKF);
-        ar & const_cast<long unsigned int &> (mnCorrectedByKF);
-        ar & const_cast<long unsigned int &> (mnCorrectedReference);
-
-        ar & const_cast<cv::Mat &> (mPosGBA);
-        ar & const_cast<long unsigned int &> (mnBAGlobalForKF);
-        ar & const_cast<cv::Mat &> (mWorldPos);
-        
-         // Load each map point id
-        ar & nItems;
-        //mObservations.resize(nItems);
-        //mObservations_nId.resize(nItems);
-        for (unsigned int i = 0; i < nItems; ++i) { 
-
-            ar & is_id;
+        ar &const_cast<long unsigned int &>(mnId);
+        // cout << "[" << mnId << "]" ;
+        ar &nNextId;
+        ar &const_cast<long int &>(mnFirstKFid);
+        ar &const_cast<long int &>(mnFirstFrame);
+        ar &const_cast<int &>(nObs);
+        ar &const_cast<float &>(mTrackProjX);
+        ar &const_cast<float &>(mTrackProjY);
+        ar &const_cast<float &>(mTrackProjXR);
+        ar &const_cast<bool &>(mbTrackInView);
+        ar &const_cast<int &>(mnTrackScaleLevel);
+        ar &const_cast<float &>(mTrackViewCos);
+        ar &const_cast<long unsigned int &>(mnTrackReferenceForFrame);
+        ar &const_cast<long unsigned int &>(mnLastFrameSeen);
+        ar &const_cast<long unsigned int &>(mnBALocalForKF);
+        ar &const_cast<long unsigned int &>(mnFuseCandidateForKF);
+        ar &const_cast<long unsigned int &>(mnLoopPointForKF);
+        ar &const_cast<long unsigned int &>(mnCorrectedByKF);
+        ar &const_cast<long unsigned int &>(mnCorrectedReference);
+
+        ar &const_cast<cv::Mat &>(mPosGBA);
+        ar &const_cast<long unsigned int &>(mnBAGlobalForKF);
+        ar &const_cast<cv::Mat &>(mWorldPos);
+
+        // Load each map point id
+        ar &nItems;
+        // mObservations.resize(nItems);
+        // mObservations_nId.resize(nItems);
+        for (unsigned int i = 0; i < nItems; ++i)
+        {
+
+            ar &is_id;
             if (is_id)
             {
-                ar & t_nId;
-                ar & t_size;
+                ar &t_nId;
+                ar &t_size;
                 mObservations_nId[t_nId] = t_size;
             }
             else
             {
-
             }
         }
-        
-        ar & const_cast<cv::Mat &> (mNormalVector);
-        ar & const_cast<cv::Mat &> (mDescriptor);
 
-        //mpRefKF = new KeyFrame();
-        //Reference Keyframe
-        ar & is_valid;
+        ar &const_cast<cv::Mat &>(mNormalVector);
+        ar &const_cast<cv::Mat &>(mDescriptor);
+
+        // mpRefKF = new KeyFrame();
+        // Reference Keyframe
+        ar &is_valid;
         if (is_valid)
         {
-            ar & t_nId;
+            ar &t_nId;
         }
         else
             t_nId = 0;
-        
-        mref_KfId_pair = std::make_pair(t_nId,is_valid);
-
-      	ar & const_cast<int &> (mnVisible);
-        ar & const_cast<int &> (mnFound);
-        ar & const_cast<bool &> (mbBad);
-        ar & const_cast<float &> (mfMinDistance);
-        ar & const_cast<float &> (mfMaxDistance);         
+
+        mref_KfId_pair = std::make_pair(t_nId, is_valid);
+
+        ar &const_cast<int &>(mnVisible);
+        ar &const_cast<int &>(mnFound);
+        ar &const_cast<bool &>(mbBad);
+        ar &const_cast<float &>(mfMinDistance);
+        ar &const_cast<float &>(mfMaxDistance);
     }
 
+    // Explicit template instantiation
+    template void MapPoint::save<boost::archive::binary_oarchive>(
+        boost::archive::binary_oarchive &,
+        const unsigned int) const;
+    template void MapPoint::save<boost::archive::binary_iarchive>(
+        boost::archive::binary_iarchive &,
+        const unsigned int) const;
+    template void MapPoint::load<boost::archive::binary_oarchive>(
+        boost::archive::binary_oarchive &,
+        const unsigned int);
+    template void MapPoint::load<boost::archive::binary_iarchive>(
+        boost::archive::binary_iarchive &,
+        const unsigned int);
+
+    void MapPoint::SetMap(Map *map)
+    {
+        mpMap = map;
+    }
 
-// Explicit template instantiation
-template void MapPoint::save<boost::archive::binary_oarchive>(
-    boost::archive::binary_oarchive &, 
-    const unsigned int) const;
-template void MapPoint::save<boost::archive::binary_iarchive>(
-    boost::archive::binary_iarchive &, 
-    const unsigned int) const;
-template void MapPoint::load<boost::archive::binary_oarchive>(
-    boost::archive::binary_oarchive &, 
-    const unsigned int);
-template void MapPoint::load<boost::archive::binary_iarchive>(
-    boost::archive::binary_iarchive &, 
-    const unsigned int);
-
-void MapPoint::SetMap(Map* map)
-{
-    mpMap = map;   
-}
+    void MapPoint::SetObservations(std::vector<KeyFrame *> spKeyFrames)
+    {
 
-void MapPoint::SetObservations(std::vector<KeyFrame*> spKeyFrames)
-{
-    
-    long unsigned int id, kfRef_id; size_t size;    
-    //cout << "KF" << mnId <<" valid indexes-" << endl;
-    int j = 0; 
-    bool found_reference = false;
-    kfRef_id = mref_KfId_pair.first;
-    bool is_ref_valid = mref_KfId_pair.second;
-
-
-    for (map<long unsigned int, size_t>::iterator it = mObservations_nId.begin(); it != mObservations_nId.end(); j++,++it) {
-        id = it->first;
-        size = it->second;        
+        long unsigned int id, kfRef_id;
+        size_t size;
+        // cout << "KF" << mnId <<" valid indexes-" << endl;
+        int j = 0;
+        bool found_reference = false;
+        kfRef_id = mref_KfId_pair.first;
+        bool is_ref_valid = mref_KfId_pair.second;
+
+        for (map<long unsigned int, size_t>::iterator it = mObservations_nId.begin(); it != mObservations_nId.end(); j++, ++it)
         {
-            for(std::vector<KeyFrame*>::iterator mit=spKeyFrames.begin(); mit !=spKeyFrames.end(); mit++)
+            id = it->first;
+            size = it->second;
             {
-                KeyFrame* pKf = *mit;
-                //cout << "[" << pKf->mnId << "]";               
-                if(id == pKf->mnId)
-                {                    
-                    //cout << "[" << id <<"]";                    
-                    mObservations[pKf] = size;
-                    //id = -1;
-                    break;
+                for (std::vector<KeyFrame *>::iterator mit = spKeyFrames.begin(); mit != spKeyFrames.end(); mit++)
+                {
+                    KeyFrame *pKf = *mit;
+                    // cout << "[" << pKf->mnId << "]";
+                    if (id == pKf->mnId)
+                    {
+                        // cout << "[" << id <<"]";
+                        mObservations[pKf] = size;
+                        // id = -1;
+                        break;
+                    }
                 }
             }
-            
         }
 
-    }
+        for (std::vector<KeyFrame *>::iterator mit = spKeyFrames.begin(); mit != spKeyFrames.end(); mit++)
+        {
+            KeyFrame *pKf = *mit;
+            if (is_ref_valid && kfRef_id == pKf->mnId)
+            {
+                // Set the refernce Keyframe
+                mpRefKF = pKf;
+                found_reference = true;
+            }
+        }
 
-    for(std::vector<KeyFrame*>::iterator mit=spKeyFrames.begin(); mit !=spKeyFrames.end(); mit++)
-    {
-       KeyFrame* pKf = *mit;
-       if (is_ref_valid && kfRef_id == pKf->mnId )
-       {
-            // Set the refernce Keyframe
-            mpRefKF = pKf;
-            found_reference = true;
-       }
-   }
-
-    if (!found_reference)
-    {
-            mpRefKF = static_cast<KeyFrame*>(NULL);
-            //cout << "refernce KF - " << kfRef_id << "is not found for mappoint " << mnId << endl;  
-            // Dummy KF
-            //mpRefKF = new KeyFrame();  
+        if (!found_reference)
+        {
+            mpRefKF = static_cast<KeyFrame *>(NULL);
+            // cout << "refernce KF - " << kfRef_id << "is not found for mappoint " << mnId << endl;
+            //  Dummy KF
+            // mpRefKF = new KeyFrame();
+        }
     }
-}
 
-MapPoint::MapPoint(const cv::Mat &Pos, Map* pMap, Frame* pFrame, const int &idxF):
-    mnFirstKFid(-1), mnFirstFrame(pFrame->mnId), nObs(0), mnTrackReferenceForFrame(0), mnLastFrameSeen(0),
-    mnBALocalForKF(0), mnFuseCandidateForKF(0),mnLoopPointForKF(0), mnCorrectedByKF(0),
-    mnCorrectedReference(0), mnBAGlobalForKF(0), mpRefKF(static_cast<KeyFrame*>(NULL)), mnVisible(1),
-    mnFound(1), mbBad(false), mpReplaced(NULL), mpMap(pMap)
-{
-    Pos.copyTo(mWorldPos);
-    cv::Mat Ow = pFrame->GetCameraCenter();
-    mNormalVector = mWorldPos - Ow;
-    mNormalVector = mNormalVector/cv::norm(mNormalVector);
+    MapPoint::MapPoint(const cv::Mat &Pos, Map *pMap, Frame *pFrame, const int &idxF) : mnFirstKFid(-1), mnFirstFrame(pFrame->mnId), nObs(0), mnTrackReferenceForFrame(0), mnLastFrameSeen(0),
+                                                                                        mnBALocalForKF(0), mnFuseCandidateForKF(0), mnLoopPointForKF(0), mnCorrectedByKF(0),
+                                                                                        mnCorrectedReference(0), mnBAGlobalForKF(0), mpRefKF(static_cast<KeyFrame *>(NULL)), mnVisible(1),
+                                                                                        mnFound(1), mbBad(false), mpReplaced(NULL), mpMap(pMap)
+    {
+        Pos.copyTo(mWorldPos);
+        cv::Mat Ow = pFrame->GetCameraCenter();
+        mNormalVector = mWorldPos - Ow;
+        mNormalVector = mNormalVector / cv::norm(mNormalVector);
 
-    cv::Mat PC = Pos - Ow;
-    const float dist = cv::norm(PC);
-    const int level = pFrame->mvKeysUn[idxF].octave;
-    const float levelScaleFactor =  pFrame->mvScaleFactors[level];
-    const int nLevels = pFrame->mnScaleLevels;
+        cv::Mat PC = Pos - Ow;
+        const float dist = cv::norm(PC);
+        const int level = pFrame->mvKeysUn[idxF].octave;
+        const float levelScaleFactor = pFrame->mvScaleFactors[level];
+        const int nLevels = pFrame->mnScaleLevels;
 
-    mfMaxDistance = dist*levelScaleFactor;
-    mfMinDistance = mfMaxDistance/pFrame->mvScaleFactors[nLevels-1];
+        mfMaxDistance = dist * levelScaleFactor;
+        mfMinDistance = mfMaxDistance / pFrame->mvScaleFactors[nLevels - 1];
 
-    pFrame->mDescriptors.row(idxF).copyTo(mDescriptor);
+        pFrame->mDescriptors.row(idxF).copyTo(mDescriptor);
 
-    // MapPoints can be created from Tracking and Local Mapping. This recursive_mutex avoid conflicts with id.
-    unique_lock<mutex> lock(mpMap->mMutexPointCreation);
-    mnId=nNextId++;
-}
+        // MapPoints can be created from Tracking and Local Mapping. This recursive_mutex avoid conflicts with id.
+        unique_lock<mutex> lock(mpMap->mMutexPointCreation);
+        mnId = nNextId++;
+    }
 
-void MapPoint::SetWorldPos(const cv::Mat &Pos)
-{
-    unique_lock<mutex> lock2(mGlobalMutex);
-    unique_lock<mutex> lock(mMutexPos);
-    Pos.copyTo(mWorldPos);
-}
+    void MapPoint::SetWorldPos(const cv::Mat &Pos)
+    {
+        unique_lock<mutex> lock2(mGlobalMutex);
+        unique_lock<mutex> lock(mMutexPos);
+        Pos.copyTo(mWorldPos);
+    }
 
-cv::Mat MapPoint::GetWorldPos()
-{
-    unique_lock<mutex> lock(mMutexPos);
-    return mWorldPos.clone();
-}
+    cv::Mat MapPoint::GetWorldPos()
+    {
+        unique_lock<mutex> lock(mMutexPos);
+        return mWorldPos.clone();
+    }
 
-cv::Mat MapPoint::GetNormal()
-{
-    unique_lock<mutex> lock(mMutexPos);
-    return mNormalVector.clone();
-}
+    cv::Mat MapPoint::GetNormal()
+    {
+        unique_lock<mutex> lock(mMutexPos);
+        return mNormalVector.clone();
+    }
 
-KeyFrame* MapPoint::GetReferenceKeyFrame()
-{
-     unique_lock<mutex> lock(mMutexFeatures);
-     return mpRefKF;
-}
+    KeyFrame *MapPoint::GetReferenceKeyFrame()
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        return mpRefKF;
+    }
 
-void MapPoint::AddObservation(KeyFrame* pKF, size_t idx)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    if(mObservations.count(pKF))
-        return;
-    mObservations[pKF]=idx;
-
-    if(pKF->mvuRight[idx]>=0)
-        nObs+=2;
-    else
-        nObs++;
-}
-
-void MapPoint::EraseObservation(KeyFrame* pKF)
-{
-    bool bBad=false;
+    void MapPoint::AddObservation(KeyFrame *pKF, size_t idx)
     {
         unique_lock<mutex> lock(mMutexFeatures);
-        if(mObservations.count(pKF))
-        {
-            int idx = mObservations[pKF];
-            if(pKF->mvuRight[idx]>=0)
-                nObs-=2;
-            else
-                nObs--;
+        if (mObservations.count(pKF))
+            return;
+        mObservations[pKF] = idx;
 
-            mObservations.erase(pKF);
+        if (pKF->mvuRight[idx] >= 0)
+            nObs += 2;
+        else
+            nObs++;
+    }
 
-            if(mpRefKF==pKF)
-                mpRefKF=mObservations.begin()->first;
+    void MapPoint::EraseObservation(KeyFrame *pKF)
+    {
+        bool bBad = false;
+        {
+            unique_lock<mutex> lock(mMutexFeatures);
+            if (mObservations.count(pKF))
+            {
+                int idx = mObservations[pKF];
+                if (pKF->mvuRight[idx] >= 0)
+                    nObs -= 2;
+                else
+                    nObs--;
 
-            // If only 2 observations or less, discard point
-            if(nObs<=2)
-                bBad=true;
-        }
-    }
+                mObservations.erase(pKF);
 
-    if(bBad)
-        SetBadFlag();
-}
+                if (mpRefKF == pKF)
+                    mpRefKF = mObservations.begin()->first;
 
-map<KeyFrame*, size_t> MapPoint::GetObservations()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return mObservations;
-}
+                // If only 2 observations or less, discard point
+                if (nObs <= 2)
+                    bBad = true;
+            }
+        }
 
-int MapPoint::Observations()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return nObs;
-}
+        if (bBad)
+            SetBadFlag();
+    }
 
-void MapPoint::SetBadFlag()
-{
-    map<KeyFrame*,size_t> obs;
+    map<KeyFrame *, size_t> MapPoint::GetObservations()
     {
-        unique_lock<mutex> lock1(mMutexFeatures);
-        unique_lock<mutex> lock2(mMutexPos);
-        mbBad=true;
-        obs = mObservations;
-        mObservations.clear();
+        unique_lock<mutex> lock(mMutexFeatures);
+        return mObservations;
     }
-    for(map<KeyFrame*,size_t>::iterator mit=obs.begin(), mend=obs.end(); mit!=mend; mit++)
+
+    int MapPoint::Observations()
     {
-        KeyFrame* pKF = mit->first;
-        pKF->EraseMapPointMatch(mit->second);
+        unique_lock<mutex> lock(mMutexFeatures);
+        return nObs;
     }
 
-    mpMap->EraseMapPoint(this);
-}
-
-MapPoint* MapPoint::GetReplaced()
-{
-    unique_lock<mutex> lock1(mMutexFeatures);
-    unique_lock<mutex> lock2(mMutexPos);
-    return mpReplaced;
-}
+    void MapPoint::SetBadFlag()
+    {
+        map<KeyFrame *, size_t> obs;
+        {
+            unique_lock<mutex> lock1(mMutexFeatures);
+            unique_lock<mutex> lock2(mMutexPos);
+            mbBad = true;
+            obs = mObservations;
+            mObservations.clear();
+        }
+        for (map<KeyFrame *, size_t>::iterator mit = obs.begin(), mend = obs.end(); mit != mend; mit++)
+        {
+            KeyFrame *pKF = mit->first;
+            pKF->EraseMapPointMatch(mit->second);
+        }
 
-void MapPoint::Replace(MapPoint* pMP)
-{
-    if(pMP->mnId==this->mnId)
-        return;
+        mpMap->EraseMapPoint(this);
+    }
 
-    int nvisible, nfound;
-    map<KeyFrame*,size_t> obs;
+    MapPoint *MapPoint::GetReplaced()
     {
         unique_lock<mutex> lock1(mMutexFeatures);
         unique_lock<mutex> lock2(mMutexPos);
-        obs=mObservations;
-        mObservations.clear();
-        mbBad=true;
-        nvisible = mnVisible;
-        nfound = mnFound;
-        mpReplaced = pMP;
+        return mpReplaced;
     }
 
-    for(map<KeyFrame*,size_t>::iterator mit=obs.begin(), mend=obs.end(); mit!=mend; mit++)
+    void MapPoint::Replace(MapPoint *pMP)
     {
-        // Replace measurement in keyframe
-        KeyFrame* pKF = mit->first;
+        if (pMP->mnId == this->mnId)
+            return;
 
-        if(!pMP->IsInKeyFrame(pKF))
+        int nvisible, nfound;
+        map<KeyFrame *, size_t> obs;
         {
-            pKF->ReplaceMapPointMatch(mit->second, pMP);
-            pMP->AddObservation(pKF,mit->second);
+            unique_lock<mutex> lock1(mMutexFeatures);
+            unique_lock<mutex> lock2(mMutexPos);
+            obs = mObservations;
+            mObservations.clear();
+            mbBad = true;
+            nvisible = mnVisible;
+            nfound = mnFound;
+            mpReplaced = pMP;
         }
-        else
+
+        for (map<KeyFrame *, size_t>::iterator mit = obs.begin(), mend = obs.end(); mit != mend; mit++)
         {
-            pKF->EraseMapPointMatch(mit->second);
+            // Replace measurement in keyframe
+            KeyFrame *pKF = mit->first;
+
+            if (!pMP->IsInKeyFrame(pKF))
+            {
+                pKF->ReplaceMapPointMatch(mit->second, pMP);
+                pMP->AddObservation(pKF, mit->second);
+            }
+            else
+            {
+                pKF->EraseMapPointMatch(mit->second);
+            }
         }
+        pMP->IncreaseFound(nfound);
+        pMP->IncreaseVisible(nvisible);
+        pMP->ComputeDistinctiveDescriptors();
+
+        mpMap->EraseMapPoint(this);
     }
-    pMP->IncreaseFound(nfound);
-    pMP->IncreaseVisible(nvisible);
-    pMP->ComputeDistinctiveDescriptors();
 
-    mpMap->EraseMapPoint(this);
-}
+    bool MapPoint::isBad()
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        unique_lock<mutex> lock2(mMutexPos);
+        return mbBad;
+    }
 
-bool MapPoint::isBad()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    unique_lock<mutex> lock2(mMutexPos);
-    return mbBad;
-}
+    void MapPoint::IncreaseVisible(int n)
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        mnVisible += n;
+    }
 
-void MapPoint::IncreaseVisible(int n)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    mnVisible+=n;
-}
+    void MapPoint::IncreaseFound(int n)
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        mnFound += n;
+    }
 
-void MapPoint::IncreaseFound(int n)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    mnFound+=n;
-}
+    float MapPoint::GetFoundRatio()
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        return static_cast<float>(mnFound) / mnVisible;
+    }
 
-float MapPoint::GetFoundRatio()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return static_cast<float>(mnFound)/mnVisible;
-}
+    void MapPoint::ComputeDistinctiveDescriptors()
+    {
+        // Retrieve all observed descriptors
+        vector<cv::Mat> vDescriptors;
 
-void MapPoint::ComputeDistinctiveDescriptors()
-{
-    // Retrieve all observed descriptors
-    vector<cv::Mat> vDescriptors;
+        map<KeyFrame *, size_t> observations;
 
-    map<KeyFrame*,size_t> observations;
+        {
+            unique_lock<mutex> lock1(mMutexFeatures);
+            if (mbBad)
+                return;
+            observations = mObservations;
+        }
 
-    {
-        unique_lock<mutex> lock1(mMutexFeatures);
-        if(mbBad)
+        if (observations.empty())
             return;
-        observations=mObservations;
-    }
-
-    if(observations.empty())
-        return;
 
-    vDescriptors.reserve(observations.size());
-
-    for(map<KeyFrame*,size_t>::iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)
-    {
-        KeyFrame* pKF = mit->first;
+        vDescriptors.reserve(observations.size());
 
-        if(!pKF->isBad())
-            vDescriptors.push_back(pKF->mDescriptors.row(mit->second));
-    }
+        for (map<KeyFrame *, size_t>::iterator mit = observations.begin(), mend = observations.end(); mit != mend; mit++)
+        {
+            KeyFrame *pKF = mit->first;
 
-    if(vDescriptors.empty())
-        return;
+            if (!pKF->isBad())
+                vDescriptors.push_back(pKF->mDescriptors.row(mit->second));
+        }
 
-    // Compute distances between them
-    const size_t N = vDescriptors.size();
+        if (vDescriptors.empty())
+            return;
 
-    float Distances[N][N];
-    for(size_t i=0;i<N;i++)
-    {
-        Distances[i][i]=0;
-        for(size_t j=i+1;j<N;j++)
+        // Compute distances between them
+        size_t N = vDescriptors.size();
+        std::vector<std::vector<int>> Distances(N);
+        for (size_t i = 0; i < N; i++)
         {
-            int distij = ORBmatcher::DescriptorDistance(vDescriptors[i],vDescriptors[j]);
-            Distances[i][j]=distij;
-            Distances[j][i]=distij;
+            Distances.emplace_back(N);
+            Distances[i][i] = 0;
+            for (size_t j = i + 1; j < N; j++)
+            {
+                int distij = ORBmatcher::DescriptorDistance(vDescriptors[i], vDescriptors[j]);
+                Distances[i][j] = distij;
+                Distances[j][i] = distij;
+            }
         }
-    }
 
-    // Take the descriptor with least median distance to the rest
-    int BestMedian = INT_MAX;
-    int BestIdx = 0;
-    for(size_t i=0;i<N;i++)
-    {
-        vector<int> vDists(Distances[i],Distances[i]+N);
-        sort(vDists.begin(),vDists.end());
-        int median = vDists[0.5*(N-1)];
+        // Take the descriptor with least median distance to the rest
+        int BestMedian = std::numeric_limits<int>::max();
+        int BestIdx = 0;
+        for (size_t i = 0; i < N; i++)
+        {
+            vector<int> vDists(Distances[i].begin(), Distances[i].end());
+            sort(vDists.begin(), vDists.end());
+            int median = vDists[0.5 * (N - 1)];
+
+            if (median < BestMedian)
+            {
+                BestMedian = median;
+                BestIdx = i;
+            }
+        }
 
-        if(median<BestMedian)
         {
-            BestMedian = median;
-            BestIdx = i;
+            unique_lock<mutex> lock(mMutexFeatures);
+            mDescriptor = vDescriptors[BestIdx].clone();
         }
     }
 
+    cv::Mat MapPoint::GetDescriptor()
     {
         unique_lock<mutex> lock(mMutexFeatures);
-        mDescriptor = vDescriptors[BestIdx].clone();       
+        return mDescriptor.clone();
     }
-}
 
-cv::Mat MapPoint::GetDescriptor()
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return mDescriptor.clone();
-}
+    int MapPoint::GetIndexInKeyFrame(KeyFrame *pKF)
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        if (mObservations.count(pKF))
+            return mObservations[pKF];
+        else
+            return -1;
+    }
 
-int MapPoint::GetIndexInKeyFrame(KeyFrame *pKF)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    if(mObservations.count(pKF))
-        return mObservations[pKF];
-    else
-        return -1;
-}
-
-bool MapPoint::IsInKeyFrame(KeyFrame *pKF)
-{
-    unique_lock<mutex> lock(mMutexFeatures);
-    return (mObservations.count(pKF));
-}
+    bool MapPoint::IsInKeyFrame(KeyFrame *pKF)
+    {
+        unique_lock<mutex> lock(mMutexFeatures);
+        return (mObservations.count(pKF));
+    }
 
-void MapPoint::UpdateNormalAndDepth()
-{
-    map<KeyFrame*,size_t> observations;
-    KeyFrame* pRefKF;
-    cv::Mat Pos;
+    void MapPoint::UpdateNormalAndDepth()
     {
-        unique_lock<mutex> lock1(mMutexFeatures);
-        unique_lock<mutex> lock2(mMutexPos);
-        if(mbBad)
+        map<KeyFrame *, size_t> observations;
+        KeyFrame *pRefKF;
+        cv::Mat Pos;
+        {
+            unique_lock<mutex> lock1(mMutexFeatures);
+            unique_lock<mutex> lock2(mMutexPos);
+            if (mbBad)
+                return;
+            observations = mObservations;
+            pRefKF = mpRefKF;
+            Pos = mWorldPos.clone();
+        }
+
+        if (observations.empty())
             return;
-        observations=mObservations;
-        pRefKF=mpRefKF;
-        Pos = mWorldPos.clone();
-    }
 
-    if(observations.empty())
-        return;
+        cv::Mat normal = cv::Mat::zeros(3, 1, CV_32F);
+        int n = 0;
+        for (map<KeyFrame *, size_t>::iterator mit = observations.begin(), mend = observations.end(); mit != mend; mit++)
+        {
+            KeyFrame *pKF = mit->first;
+            cv::Mat Owi = pKF->GetCameraCenter();
+            cv::Mat normali = mWorldPos - Owi;
+            normal = normal + normali / cv::norm(normali);
+            n++;
+        }
+
+        if (!pRefKF)
+        {
 
-    cv::Mat normal = cv::Mat::zeros(3,1,CV_32F);
-    int n=0;
-    for(map<KeyFrame*,size_t>::iterator mit=observations.begin(), mend=observations.end(); mit!=mend; mit++)
-    {
-        KeyFrame* pKF = mit->first;
-        cv::Mat Owi = pKF->GetCameraCenter();
-        cv::Mat normali = mWorldPos - Owi;
-        normal = normal + normali/cv::norm(normali);
-        n++;
-    } 
-
-    if (!pRefKF)
-    {
-        
             return;
-    }
+        }
 
-    cv::Mat PC = Pos - pRefKF->GetCameraCenter();
-    const float dist = cv::norm(PC);
-    const int level = pRefKF->mvKeysUn[observations[pRefKF]].octave;
-    const float levelScaleFactor =  pRefKF->mvScaleFactors[level];
-    const int nLevels = pRefKF->mnScaleLevels;
+        cv::Mat PC = Pos - pRefKF->GetCameraCenter();
+        const float dist = cv::norm(PC);
+        const int level = pRefKF->mvKeysUn[observations[pRefKF]].octave;
+        const float levelScaleFactor = pRefKF->mvScaleFactors[level];
+        const int nLevels = pRefKF->mnScaleLevels;
 
+        {
+            unique_lock<mutex> lock3(mMutexPos);
+            mfMaxDistance = dist * levelScaleFactor;
+            mfMinDistance = mfMaxDistance / pRefKF->mvScaleFactors[nLevels - 1];
+            mNormalVector = normal / n;
+        }
+    }
 
+    float MapPoint::GetMinDistanceInvariance()
     {
-        unique_lock<mutex> lock3(mMutexPos);
-        mfMaxDistance = dist*levelScaleFactor;
-        mfMinDistance = mfMaxDistance/pRefKF->mvScaleFactors[nLevels-1];
-        mNormalVector = normal/n;
+        unique_lock<mutex> lock(mMutexPos);
+        return 0.8f * mfMinDistance;
     }
-}
 
-float MapPoint::GetMinDistanceInvariance()
-{
-    unique_lock<mutex> lock(mMutexPos);
-    return 0.8f*mfMinDistance;
-}
-
-float MapPoint::GetMaxDistanceInvariance()
-{
-    unique_lock<mutex> lock(mMutexPos);
-    return 1.2f*mfMaxDistance;
-}
-
-int MapPoint::PredictScale(const float &currentDist, const float &logScaleFactor)
-{
-    float ratio;
+    float MapPoint::GetMaxDistanceInvariance()
     {
-        unique_lock<mutex> lock3(mMutexPos);
-        ratio = mfMaxDistance/currentDist;
+        unique_lock<mutex> lock(mMutexPos);
+        return 1.2f * mfMaxDistance;
     }
 
-    return ceil(log(ratio)/logScaleFactor);
-}
+    int MapPoint::PredictScale(const float &currentDist, const float &logScaleFactor)
+    {
+        float ratio;
+        {
+            unique_lock<mutex> lock3(mMutexPos);
+            ratio = mfMaxDistance / currentDist;
+        }
+
+        return ceil(log(ratio) / logScaleFactor);
+    }
 
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/ORBextractor.cc b/slam/src/ORBextractor.cc
index ea962e2..fb6445d 100644
--- a/slam/src/ORBextractor.cc
+++ b/slam/src/ORBextractor.cc
@@ -1,58 +1,57 @@
 /**
-* This file is part of ORB-SLAM2.
-* This file is based on the file orb.cpp from the OpenCV library (see BSD license below).
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ * This file is based on the file orb.cpp from the OpenCV library (see BSD license below).
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 /**
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of the Willow Garage nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the Willow Garage nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <opencv2/core/core.hpp>
 #include <opencv2/highgui/highgui.hpp>
@@ -61,7 +60,6 @@
 #include <vector>
 #include "ORBextractor.h"
 
-
 using namespace cv;
 using namespace std;
 
@@ -75,1096 +73,1090 @@ std::chrono::steady_clock::time_point get_time2()
 
 uint get_time_diff2(std::chrono::steady_clock::time_point start, std::chrono::steady_clock::time_point end)
 {
-    return std::chrono::duration_cast<std::chrono::microseconds>(end-start).count();
+    return std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
 }
 
 namespace ORB_SLAM2
 {
 
-const int PATCH_SIZE = 31;
-const int HALF_PATCH_SIZE = 15;
-const int EDGE_THRESHOLD = 19;
+    const int PATCH_SIZE = 31;
+    const int HALF_PATCH_SIZE = 15;
+    const int EDGE_THRESHOLD = 19;
 
+    static float IC_Angle(const Mat &image, Point2f pt, const vector<int> &u_max)
+    {
+        int m_01 = 0, m_10 = 0;
 
-static float IC_Angle(const Mat& image, Point2f pt,  const vector<int> & u_max)
-{
-    int m_01 = 0, m_10 = 0;
-
-    const uchar* center = &image.at<uchar> (cvRound(pt.y), cvRound(pt.x));
+        const uchar *center = &image.at<uchar>(cvRound(pt.y), cvRound(pt.x));
 
-    // Treat the center line differently, v=0
-    for (int u = -HALF_PATCH_SIZE; u <= HALF_PATCH_SIZE; ++u)
-        m_10 += u * center[u];
+        // Treat the center line differently, v=0
+        for (int u = -HALF_PATCH_SIZE; u <= HALF_PATCH_SIZE; ++u)
+            m_10 += u * center[u];
 
-    // Go line by line in the circuI853lar patch
-    int step = (int)image.step1();
-    for (int v = 1; v <= HALF_PATCH_SIZE; ++v)
-    {
-        // Proceed over the two lines
-        int v_sum = 0;
-        int d = u_max[v];
-        for (int u = -d; u <= d; ++u)
+        // Go line by line in the circuI853lar patch
+        int step = (int)image.step1();
+        for (int v = 1; v <= HALF_PATCH_SIZE; ++v)
         {
-            int val_plus = center[u + v*step], val_minus = center[u - v*step];
-            v_sum += (val_plus - val_minus);
-            m_10 += u * (val_plus + val_minus);
+            // Proceed over the two lines
+            int v_sum = 0;
+            int d = u_max[v];
+            for (int u = -d; u <= d; ++u)
+            {
+                int val_plus = center[u + v * step], val_minus = center[u - v * step];
+                v_sum += (val_plus - val_minus);
+                m_10 += u * (val_plus + val_minus);
+            }
+            m_01 += v * v_sum;
         }
-        m_01 += v * v_sum;
-    }
-
-    return fastAtan2((float)m_01, (float)m_10);
-}
-
-
-const float factorPI = (float)(CV_PI/180.f);
-static void computeOrbDescriptor(const KeyPoint& kpt,
-                                 const Mat& img, const Point* pattern,
-                                 uchar* desc)
-{
-    float angle = (float)kpt.angle*factorPI;
-    float a = (float)cos(angle), b = (float)sin(angle);
-
-    const uchar* center = &img.at<uchar>(cvRound(kpt.pt.y), cvRound(kpt.pt.x));
-    const int step = (int)img.step;
-
-    #define GET_VALUE(idx) \
-        center[cvRound(pattern[idx].x*b + pattern[idx].y*a)*step + \
-               cvRound(pattern[idx].x*a - pattern[idx].y*b)]
 
-
-    for (int i = 0; i < 32; ++i, pattern += 16)
-    {
-        int t0, t1, val;
-        t0 = GET_VALUE(0); t1 = GET_VALUE(1);
-        val = t0 < t1;
-        t0 = GET_VALUE(2); t1 = GET_VALUE(3);
-        val |= (t0 < t1) << 1;
-        t0 = GET_VALUE(4); t1 = GET_VALUE(5);
-        val |= (t0 < t1) << 2;
-        t0 = GET_VALUE(6); t1 = GET_VALUE(7);
-        val |= (t0 < t1) << 3;
-        t0 = GET_VALUE(8); t1 = GET_VALUE(9);
-        val |= (t0 < t1) << 4;
-        t0 = GET_VALUE(10); t1 = GET_VALUE(11);
-        val |= (t0 < t1) << 5;
-        t0 = GET_VALUE(12); t1 = GET_VALUE(13);
-        val |= (t0 < t1) << 6;
-        t0 = GET_VALUE(14); t1 = GET_VALUE(15);
-        val |= (t0 < t1) << 7;
-
-        desc[i] = (uchar)val;
+        return fastAtan2((float)m_01, (float)m_10);
     }
 
-    #undef GET_VALUE
-}
-
-
-static int bit_pattern_31_[256*4] =
-{
-    8,-3, 9,5/*mean (0), correlation (0)*/,
-    4,2, 7,-12/*mean (1.12461e-05), correlation (0.0437584)*/,
-    -11,9, -8,2/*mean (3.37382e-05), correlation (0.0617409)*/,
-    7,-12, 12,-13/*mean (5.62303e-05), correlation (0.0636977)*/,
-    2,-13, 2,12/*mean (0.000134953), correlation (0.085099)*/,
-    1,-7, 1,6/*mean (0.000528565), correlation (0.0857175)*/,
-    -2,-10, -2,-4/*mean (0.0188821), correlation (0.0985774)*/,
-    -13,-13, -11,-8/*mean (0.0363135), correlation (0.0899616)*/,
-    -13,-3, -12,-9/*mean (0.121806), correlation (0.099849)*/,
-    10,4, 11,9/*mean (0.122065), correlation (0.093285)*/,
-    -13,-8, -8,-9/*mean (0.162787), correlation (0.0942748)*/,
-    -11,7, -9,12/*mean (0.21561), correlation (0.0974438)*/,
-    7,7, 12,6/*mean (0.160583), correlation (0.130064)*/,
-    -4,-5, -3,0/*mean (0.228171), correlation (0.132998)*/,
-    -13,2, -12,-3/*mean (0.00997526), correlation (0.145926)*/,
-    -9,0, -7,5/*mean (0.198234), correlation (0.143636)*/,
-    12,-6, 12,-1/*mean (0.0676226), correlation (0.16689)*/,
-    -3,6, -2,12/*mean (0.166847), correlation (0.171682)*/,
-    -6,-13, -4,-8/*mean (0.101215), correlation (0.179716)*/,
-    11,-13, 12,-8/*mean (0.200641), correlation (0.192279)*/,
-    4,7, 5,1/*mean (0.205106), correlation (0.186848)*/,
-    5,-3, 10,-3/*mean (0.234908), correlation (0.192319)*/,
-    3,-7, 6,12/*mean (0.0709964), correlation (0.210872)*/,
-    -8,-7, -6,-2/*mean (0.0939834), correlation (0.212589)*/,
-    -2,11, -1,-10/*mean (0.127778), correlation (0.20866)*/,
-    -13,12, -8,10/*mean (0.14783), correlation (0.206356)*/,
-    -7,3, -5,-3/*mean (0.182141), correlation (0.198942)*/,
-    -4,2, -3,7/*mean (0.188237), correlation (0.21384)*/,
-    -10,-12, -6,11/*mean (0.14865), correlation (0.23571)*/,
-    5,-12, 6,-7/*mean (0.222312), correlation (0.23324)*/,
-    5,-6, 7,-1/*mean (0.229082), correlation (0.23389)*/,
-    1,0, 4,-5/*mean (0.241577), correlation (0.215286)*/,
-    9,11, 11,-13/*mean (0.00338507), correlation (0.251373)*/,
-    4,7, 4,12/*mean (0.131005), correlation (0.257622)*/,
-    2,-1, 4,4/*mean (0.152755), correlation (0.255205)*/,
-    -4,-12, -2,7/*mean (0.182771), correlation (0.244867)*/,
-    -8,-5, -7,-10/*mean (0.186898), correlation (0.23901)*/,
-    4,11, 9,12/*mean (0.226226), correlation (0.258255)*/,
-    0,-8, 1,-13/*mean (0.0897886), correlation (0.274827)*/,
-    -13,-2, -8,2/*mean (0.148774), correlation (0.28065)*/,
-    -3,-2, -2,3/*mean (0.153048), correlation (0.283063)*/,
-    -6,9, -4,-9/*mean (0.169523), correlation (0.278248)*/,
-    8,12, 10,7/*mean (0.225337), correlation (0.282851)*/,
-    0,9, 1,3/*mean (0.226687), correlation (0.278734)*/,
-    7,-5, 11,-10/*mean (0.00693882), correlation (0.305161)*/,
-    -13,-6, -11,0/*mean (0.0227283), correlation (0.300181)*/,
-    10,7, 12,1/*mean (0.125517), correlation (0.31089)*/,
-    -6,-3, -6,12/*mean (0.131748), correlation (0.312779)*/,
-    10,-9, 12,-4/*mean (0.144827), correlation (0.292797)*/,
-    -13,8, -8,-12/*mean (0.149202), correlation (0.308918)*/,
-    -13,0, -8,-4/*mean (0.160909), correlation (0.310013)*/,
-    3,3, 7,8/*mean (0.177755), correlation (0.309394)*/,
-    5,7, 10,-7/*mean (0.212337), correlation (0.310315)*/,
-    -1,7, 1,-12/*mean (0.214429), correlation (0.311933)*/,
-    3,-10, 5,6/*mean (0.235807), correlation (0.313104)*/,
-    2,-4, 3,-10/*mean (0.00494827), correlation (0.344948)*/,
-    -13,0, -13,5/*mean (0.0549145), correlation (0.344675)*/,
-    -13,-7, -12,12/*mean (0.103385), correlation (0.342715)*/,
-    -13,3, -11,8/*mean (0.134222), correlation (0.322922)*/,
-    -7,12, -4,7/*mean (0.153284), correlation (0.337061)*/,
-    6,-10, 12,8/*mean (0.154881), correlation (0.329257)*/,
-    -9,-1, -7,-6/*mean (0.200967), correlation (0.33312)*/,
-    -2,-5, 0,12/*mean (0.201518), correlation (0.340635)*/,
-    -12,5, -7,5/*mean (0.207805), correlation (0.335631)*/,
-    3,-10, 8,-13/*mean (0.224438), correlation (0.34504)*/,
-    -7,-7, -4,5/*mean (0.239361), correlation (0.338053)*/,
-    -3,-2, -1,-7/*mean (0.240744), correlation (0.344322)*/,
-    2,9, 5,-11/*mean (0.242949), correlation (0.34145)*/,
-    -11,-13, -5,-13/*mean (0.244028), correlation (0.336861)*/,
-    -1,6, 0,-1/*mean (0.247571), correlation (0.343684)*/,
-    5,-3, 5,2/*mean (0.000697256), correlation (0.357265)*/,
-    -4,-13, -4,12/*mean (0.00213675), correlation (0.373827)*/,
-    -9,-6, -9,6/*mean (0.0126856), correlation (0.373938)*/,
-    -12,-10, -8,-4/*mean (0.0152497), correlation (0.364237)*/,
-    10,2, 12,-3/*mean (0.0299933), correlation (0.345292)*/,
-    7,12, 12,12/*mean (0.0307242), correlation (0.366299)*/,
-    -7,-13, -6,5/*mean (0.0534975), correlation (0.368357)*/,
-    -4,9, -3,4/*mean (0.099865), correlation (0.372276)*/,
-    7,-1, 12,2/*mean (0.117083), correlation (0.364529)*/,
-    -7,6, -5,1/*mean (0.126125), correlation (0.369606)*/,
-    -13,11, -12,5/*mean (0.130364), correlation (0.358502)*/,
-    -3,7, -2,-6/*mean (0.131691), correlation (0.375531)*/,
-    7,-8, 12,-7/*mean (0.160166), correlation (0.379508)*/,
-    -13,-7, -11,-12/*mean (0.167848), correlation (0.353343)*/,
-    1,-3, 12,12/*mean (0.183378), correlation (0.371916)*/,
-    2,-6, 3,0/*mean (0.228711), correlation (0.371761)*/,
-    -4,3, -2,-13/*mean (0.247211), correlation (0.364063)*/,
-    -1,-13, 1,9/*mean (0.249325), correlation (0.378139)*/,
-    7,1, 8,-6/*mean (0.000652272), correlation (0.411682)*/,
-    1,-1, 3,12/*mean (0.00248538), correlation (0.392988)*/,
-    9,1, 12,6/*mean (0.0206815), correlation (0.386106)*/,
-    -1,-9, -1,3/*mean (0.0364485), correlation (0.410752)*/,
-    -13,-13, -10,5/*mean (0.0376068), correlation (0.398374)*/,
-    7,7, 10,12/*mean (0.0424202), correlation (0.405663)*/,
-    12,-5, 12,9/*mean (0.0942645), correlation (0.410422)*/,
-    6,3, 7,11/*mean (0.1074), correlation (0.413224)*/,
-    5,-13, 6,10/*mean (0.109256), correlation (0.408646)*/,
-    2,-12, 2,3/*mean (0.131691), correlation (0.416076)*/,
-    3,8, 4,-6/*mean (0.165081), correlation (0.417569)*/,
-    2,6, 12,-13/*mean (0.171874), correlation (0.408471)*/,
-    9,-12, 10,3/*mean (0.175146), correlation (0.41296)*/,
-    -8,4, -7,9/*mean (0.183682), correlation (0.402956)*/,
-    -11,12, -4,-6/*mean (0.184672), correlation (0.416125)*/,
-    1,12, 2,-8/*mean (0.191487), correlation (0.386696)*/,
-    6,-9, 7,-4/*mean (0.192668), correlation (0.394771)*/,
-    2,3, 3,-2/*mean (0.200157), correlation (0.408303)*/,
-    6,3, 11,0/*mean (0.204588), correlation (0.411762)*/,
-    3,-3, 8,-8/*mean (0.205904), correlation (0.416294)*/,
-    7,8, 9,3/*mean (0.213237), correlation (0.409306)*/,
-    -11,-5, -6,-4/*mean (0.243444), correlation (0.395069)*/,
-    -10,11, -5,10/*mean (0.247672), correlation (0.413392)*/,
-    -5,-8, -3,12/*mean (0.24774), correlation (0.411416)*/,
-    -10,5, -9,0/*mean (0.00213675), correlation (0.454003)*/,
-    8,-1, 12,-6/*mean (0.0293635), correlation (0.455368)*/,
-    4,-6, 6,-11/*mean (0.0404971), correlation (0.457393)*/,
-    -10,12, -8,7/*mean (0.0481107), correlation (0.448364)*/,
-    4,-2, 6,7/*mean (0.050641), correlation (0.455019)*/,
-    -2,0, -2,12/*mean (0.0525978), correlation (0.44338)*/,
-    -5,-8, -5,2/*mean (0.0629667), correlation (0.457096)*/,
-    7,-6, 10,12/*mean (0.0653846), correlation (0.445623)*/,
-    -9,-13, -8,-8/*mean (0.0858749), correlation (0.449789)*/,
-    -5,-13, -5,-2/*mean (0.122402), correlation (0.450201)*/,
-    8,-8, 9,-13/*mean (0.125416), correlation (0.453224)*/,
-    -9,-11, -9,0/*mean (0.130128), correlation (0.458724)*/,
-    1,-8, 1,-2/*mean (0.132467), correlation (0.440133)*/,
-    7,-4, 9,1/*mean (0.132692), correlation (0.454)*/,
-    -2,1, -1,-4/*mean (0.135695), correlation (0.455739)*/,
-    11,-6, 12,-11/*mean (0.142904), correlation (0.446114)*/,
-    -12,-9, -6,4/*mean (0.146165), correlation (0.451473)*/,
-    3,7, 7,12/*mean (0.147627), correlation (0.456643)*/,
-    5,5, 10,8/*mean (0.152901), correlation (0.455036)*/,
-    0,-4, 2,8/*mean (0.167083), correlation (0.459315)*/,
-    -9,12, -5,-13/*mean (0.173234), correlation (0.454706)*/,
-    0,7, 2,12/*mean (0.18312), correlation (0.433855)*/,
-    -1,2, 1,7/*mean (0.185504), correlation (0.443838)*/,
-    5,11, 7,-9/*mean (0.185706), correlation (0.451123)*/,
-    3,5, 6,-8/*mean (0.188968), correlation (0.455808)*/,
-    -13,-4, -8,9/*mean (0.191667), correlation (0.459128)*/,
-    -5,9, -3,-3/*mean (0.193196), correlation (0.458364)*/,
-    -4,-7, -3,-12/*mean (0.196536), correlation (0.455782)*/,
-    6,5, 8,0/*mean (0.1972), correlation (0.450481)*/,
-    -7,6, -6,12/*mean (0.199438), correlation (0.458156)*/,
-    -13,6, -5,-2/*mean (0.211224), correlation (0.449548)*/,
-    1,-10, 3,10/*mean (0.211718), correlation (0.440606)*/,
-    4,1, 8,-4/*mean (0.213034), correlation (0.443177)*/,
-    -2,-2, 2,-13/*mean (0.234334), correlation (0.455304)*/,
-    2,-12, 12,12/*mean (0.235684), correlation (0.443436)*/,
-    -2,-13, 0,-6/*mean (0.237674), correlation (0.452525)*/,
-    4,1, 9,3/*mean (0.23962), correlation (0.444824)*/,
-    -6,-10, -3,-5/*mean (0.248459), correlation (0.439621)*/,
-    -3,-13, -1,1/*mean (0.249505), correlation (0.456666)*/,
-    7,5, 12,-11/*mean (0.00119208), correlation (0.495466)*/,
-    4,-2, 5,-7/*mean (0.00372245), correlation (0.484214)*/,
-    -13,9, -9,-5/*mean (0.00741116), correlation (0.499854)*/,
-    7,1, 8,6/*mean (0.0208952), correlation (0.499773)*/,
-    7,-8, 7,6/*mean (0.0220085), correlation (0.501609)*/,
-    -7,-4, -7,1/*mean (0.0233806), correlation (0.496568)*/,
-    -8,11, -7,-8/*mean (0.0236505), correlation (0.489719)*/,
-    -13,6, -12,-8/*mean (0.0268781), correlation (0.503487)*/,
-    2,4, 3,9/*mean (0.0323324), correlation (0.501938)*/,
-    10,-5, 12,3/*mean (0.0399235), correlation (0.494029)*/,
-    -6,-5, -6,7/*mean (0.0420153), correlation (0.486579)*/,
-    8,-3, 9,-8/*mean (0.0548021), correlation (0.484237)*/,
-    2,-12, 2,8/*mean (0.0616622), correlation (0.496642)*/,
-    -11,-2, -10,3/*mean (0.0627755), correlation (0.498563)*/,
-    -12,-13, -7,-9/*mean (0.0829622), correlation (0.495491)*/,
-    -11,0, -10,-5/*mean (0.0843342), correlation (0.487146)*/,
-    5,-3, 11,8/*mean (0.0929937), correlation (0.502315)*/,
-    -2,-13, -1,12/*mean (0.113327), correlation (0.48941)*/,
-    -1,-8, 0,9/*mean (0.132119), correlation (0.467268)*/,
-    -13,-11, -12,-5/*mean (0.136269), correlation (0.498771)*/,
-    -10,-2, -10,11/*mean (0.142173), correlation (0.498714)*/,
-    -3,9, -2,-13/*mean (0.144141), correlation (0.491973)*/,
-    2,-3, 3,2/*mean (0.14892), correlation (0.500782)*/,
-    -9,-13, -4,0/*mean (0.150371), correlation (0.498211)*/,
-    -4,6, -3,-10/*mean (0.152159), correlation (0.495547)*/,
-    -4,12, -2,-7/*mean (0.156152), correlation (0.496925)*/,
-    -6,-11, -4,9/*mean (0.15749), correlation (0.499222)*/,
-    6,-3, 6,11/*mean (0.159211), correlation (0.503821)*/,
-    -13,11, -5,5/*mean (0.162427), correlation (0.501907)*/,
-    11,11, 12,6/*mean (0.16652), correlation (0.497632)*/,
-    7,-5, 12,-2/*mean (0.169141), correlation (0.484474)*/,
-    -1,12, 0,7/*mean (0.169456), correlation (0.495339)*/,
-    -4,-8, -3,-2/*mean (0.171457), correlation (0.487251)*/,
-    -7,1, -6,7/*mean (0.175), correlation (0.500024)*/,
-    -13,-12, -8,-13/*mean (0.175866), correlation (0.497523)*/,
-    -7,-2, -6,-8/*mean (0.178273), correlation (0.501854)*/,
-    -8,5, -6,-9/*mean (0.181107), correlation (0.494888)*/,
-    -5,-1, -4,5/*mean (0.190227), correlation (0.482557)*/,
-    -13,7, -8,10/*mean (0.196739), correlation (0.496503)*/,
-    1,5, 5,-13/*mean (0.19973), correlation (0.499759)*/,
-    1,0, 10,-13/*mean (0.204465), correlation (0.49873)*/,
-    9,12, 10,-1/*mean (0.209334), correlation (0.49063)*/,
-    5,-8, 10,-9/*mean (0.211134), correlation (0.503011)*/,
-    -1,11, 1,-13/*mean (0.212), correlation (0.499414)*/,
-    -9,-3, -6,2/*mean (0.212168), correlation (0.480739)*/,
-    -1,-10, 1,12/*mean (0.212731), correlation (0.502523)*/,
-    -13,1, -8,-10/*mean (0.21327), correlation (0.489786)*/,
-    8,-11, 10,-6/*mean (0.214159), correlation (0.488246)*/,
-    2,-13, 3,-6/*mean (0.216993), correlation (0.50287)*/,
-    7,-13, 12,-9/*mean (0.223639), correlation (0.470502)*/,
-    -10,-10, -5,-7/*mean (0.224089), correlation (0.500852)*/,
-    -10,-8, -8,-13/*mean (0.228666), correlation (0.502629)*/,
-    4,-6, 8,5/*mean (0.22906), correlation (0.498305)*/,
-    3,12, 8,-13/*mean (0.233378), correlation (0.503825)*/,
-    -4,2, -3,-3/*mean (0.234323), correlation (0.476692)*/,
-    5,-13, 10,-12/*mean (0.236392), correlation (0.475462)*/,
-    4,-13, 5,-1/*mean (0.236842), correlation (0.504132)*/,
-    -9,9, -4,3/*mean (0.236977), correlation (0.497739)*/,
-    0,3, 3,-9/*mean (0.24314), correlation (0.499398)*/,
-    -12,1, -6,1/*mean (0.243297), correlation (0.489447)*/,
-    3,2, 4,-8/*mean (0.00155196), correlation (0.553496)*/,
-    -10,-10, -10,9/*mean (0.00239541), correlation (0.54297)*/,
-    8,-13, 12,12/*mean (0.0034413), correlation (0.544361)*/,
-    -8,-12, -6,-5/*mean (0.003565), correlation (0.551225)*/,
-    2,2, 3,7/*mean (0.00835583), correlation (0.55285)*/,
-    10,6, 11,-8/*mean (0.00885065), correlation (0.540913)*/,
-    6,8, 8,-12/*mean (0.0101552), correlation (0.551085)*/,
-    -7,10, -6,5/*mean (0.0102227), correlation (0.533635)*/,
-    -3,-9, -3,9/*mean (0.0110211), correlation (0.543121)*/,
-    -1,-13, -1,5/*mean (0.0113473), correlation (0.550173)*/,
-    -3,-7, -3,4/*mean (0.0140913), correlation (0.554774)*/,
-    -8,-2, -8,3/*mean (0.017049), correlation (0.55461)*/,
-    4,2, 12,12/*mean (0.01778), correlation (0.546921)*/,
-    2,-5, 3,11/*mean (0.0224022), correlation (0.549667)*/,
-    6,-9, 11,-13/*mean (0.029161), correlation (0.546295)*/,
-    3,-1, 7,12/*mean (0.0303081), correlation (0.548599)*/,
-    11,-1, 12,4/*mean (0.0355151), correlation (0.523943)*/,
-    -3,0, -3,6/*mean (0.0417904), correlation (0.543395)*/,
-    4,-11, 4,12/*mean (0.0487292), correlation (0.542818)*/,
-    2,-4, 2,1/*mean (0.0575124), correlation (0.554888)*/,
-    -10,-6, -8,1/*mean (0.0594242), correlation (0.544026)*/,
-    -13,7, -11,1/*mean (0.0597391), correlation (0.550524)*/,
-    -13,12, -11,-13/*mean (0.0608974), correlation (0.55383)*/,
-    6,0, 11,-13/*mean (0.065126), correlation (0.552006)*/,
-    0,-1, 1,4/*mean (0.074224), correlation (0.546372)*/,
-    -13,3, -9,-2/*mean (0.0808592), correlation (0.554875)*/,
-    -9,8, -6,-3/*mean (0.0883378), correlation (0.551178)*/,
-    -13,-6, -8,-2/*mean (0.0901035), correlation (0.548446)*/,
-    5,-9, 8,10/*mean (0.0949843), correlation (0.554694)*/,
-    2,7, 3,-9/*mean (0.0994152), correlation (0.550979)*/,
-    -1,-6, -1,-1/*mean (0.10045), correlation (0.552714)*/,
-    9,5, 11,-2/*mean (0.100686), correlation (0.552594)*/,
-    11,-3, 12,-8/*mean (0.101091), correlation (0.532394)*/,
-    3,0, 3,5/*mean (0.101147), correlation (0.525576)*/,
-    -1,4, 0,10/*mean (0.105263), correlation (0.531498)*/,
-    3,-6, 4,5/*mean (0.110785), correlation (0.540491)*/,
-    -13,0, -10,5/*mean (0.112798), correlation (0.536582)*/,
-    5,8, 12,11/*mean (0.114181), correlation (0.555793)*/,
-    8,9, 9,-6/*mean (0.117431), correlation (0.553763)*/,
-    7,-4, 8,-12/*mean (0.118522), correlation (0.553452)*/,
-    -10,4, -10,9/*mean (0.12094), correlation (0.554785)*/,
-    7,3, 12,4/*mean (0.122582), correlation (0.555825)*/,
-    9,-7, 10,-2/*mean (0.124978), correlation (0.549846)*/,
-    7,0, 12,-2/*mean (0.127002), correlation (0.537452)*/,
-    -1,-6, 0,-11/*mean (0.127148), correlation (0.547401)*/
-};
-
-ORBextractor::ORBextractor(int _nfeatures, float _scaleFactor, int _nlevels,
-         int _iniThFAST, int _minThFAST):
-    nfeatures(_nfeatures), scaleFactor(_scaleFactor), nlevels(_nlevels),
-    iniThFAST(_iniThFAST), minThFAST(_minThFAST)
-{
-    mvScaleFactor.resize(nlevels);
-    mvLevelSigma2.resize(nlevels);
-    mvScaleFactor[0]=1.0f;
-    mvLevelSigma2[0]=1.0f;
-    for(int i=1; i<nlevels; i++)
-    {
-        mvScaleFactor[i]=mvScaleFactor[i-1]*scaleFactor;
-        mvLevelSigma2[i]=mvScaleFactor[i]*mvScaleFactor[i];
-    }
-
-    mvInvScaleFactor.resize(nlevels);
-    mvInvLevelSigma2.resize(nlevels);
-    for(int i=0; i<nlevels; i++)
-    {
-        mvInvScaleFactor[i]=1.0f/mvScaleFactor[i];
-        mvInvLevelSigma2[i]=1.0f/mvLevelSigma2[i];
-    }
-
-    mvImagePyramid.resize(nlevels);
-
-    mnFeaturesPerLevel.resize(nlevels);
-    float factor = 1.0f / scaleFactor;
-    float nDesiredFeaturesPerScale = nfeatures*(1 - factor)/(1 - (float)pow((double)factor, (double)nlevels));
-
-    int sumFeatures = 0;
-    for( int level = 0; level < nlevels-1; level++ )
+    const float factorPI = (float)(CV_PI / 180.f);
+    static void computeOrbDescriptor(const KeyPoint &kpt,
+                                     const Mat &img, const Point *pattern,
+                                     uchar *desc)
     {
-        mnFeaturesPerLevel[level] = cvRound(nDesiredFeaturesPerScale);
-        sumFeatures += mnFeaturesPerLevel[level];
-        nDesiredFeaturesPerScale *= factor;
-    }
-    mnFeaturesPerLevel[nlevels-1] = std::max(nfeatures - sumFeatures, 0);
+        float angle = (float)kpt.angle * factorPI;
+        float a = (float)cos(angle), b = (float)sin(angle);
 
-    const int npoints = 512;
-    const Point* pattern0 = (const Point*)bit_pattern_31_;
-    std::copy(pattern0, pattern0 + npoints, std::back_inserter(pattern));
+        const uchar *center = &img.at<uchar>(cvRound(kpt.pt.y), cvRound(kpt.pt.x));
+        const int step = (int)img.step;
 
-    //This is for orientation
-    // pre-compute the end of a row in a circular patch
-    umax.resize(HALF_PATCH_SIZE + 1);
+#define GET_VALUE(idx)                                               \
+    center[cvRound(pattern[idx].x * b + pattern[idx].y * a) * step + \
+           cvRound(pattern[idx].x * a - pattern[idx].y * b)]
 
-    int v, v0, vmax = cvFloor(HALF_PATCH_SIZE * sqrt(2.f) / 2 + 1);
-    int vmin = cvCeil(HALF_PATCH_SIZE * sqrt(2.f) / 2);
-    const double hp2 = HALF_PATCH_SIZE*HALF_PATCH_SIZE;
-    for (v = 0; v <= vmax; ++v)
-        umax[v] = cvRound(sqrt(hp2 - v * v));
+        for (int i = 0; i < 32; ++i, pattern += 16)
+        {
+            int t0, t1, val;
+            t0 = GET_VALUE(0);
+            t1 = GET_VALUE(1);
+            val = t0 < t1;
+            t0 = GET_VALUE(2);
+            t1 = GET_VALUE(3);
+            val |= (t0 < t1) << 1;
+            t0 = GET_VALUE(4);
+            t1 = GET_VALUE(5);
+            val |= (t0 < t1) << 2;
+            t0 = GET_VALUE(6);
+            t1 = GET_VALUE(7);
+            val |= (t0 < t1) << 3;
+            t0 = GET_VALUE(8);
+            t1 = GET_VALUE(9);
+            val |= (t0 < t1) << 4;
+            t0 = GET_VALUE(10);
+            t1 = GET_VALUE(11);
+            val |= (t0 < t1) << 5;
+            t0 = GET_VALUE(12);
+            t1 = GET_VALUE(13);
+            val |= (t0 < t1) << 6;
+            t0 = GET_VALUE(14);
+            t1 = GET_VALUE(15);
+            val |= (t0 < t1) << 7;
+
+            desc[i] = (uchar)val;
+        }
 
-    // Make sure we are symmetric
-    for (v = HALF_PATCH_SIZE, v0 = 0; v >= vmin; --v)
-    {
-        while (umax[v0] == umax[v0 + 1])
-            ++v0;
-        umax[v] = v0;
-        ++v0;
+#undef GET_VALUE
     }
-}
 
-static void computeOrientation(const Mat& image, vector<KeyPoint>& keypoints, const vector<int>& umax)
-{
-    for (vector<KeyPoint>::iterator keypoint = keypoints.begin(),
-         keypointEnd = keypoints.end(); keypoint != keypointEnd; ++keypoint)
+    static int bit_pattern_31_[256 * 4] =
+        {
+            8, -3, 9, 5 /*mean (0), correlation (0)*/,
+            4, 2, 7, -12 /*mean (1.12461e-05), correlation (0.0437584)*/,
+            -11, 9, -8, 2 /*mean (3.37382e-05), correlation (0.0617409)*/,
+            7, -12, 12, -13 /*mean (5.62303e-05), correlation (0.0636977)*/,
+            2, -13, 2, 12 /*mean (0.000134953), correlation (0.085099)*/,
+            1, -7, 1, 6 /*mean (0.000528565), correlation (0.0857175)*/,
+            -2, -10, -2, -4 /*mean (0.0188821), correlation (0.0985774)*/,
+            -13, -13, -11, -8 /*mean (0.0363135), correlation (0.0899616)*/,
+            -13, -3, -12, -9 /*mean (0.121806), correlation (0.099849)*/,
+            10, 4, 11, 9 /*mean (0.122065), correlation (0.093285)*/,
+            -13, -8, -8, -9 /*mean (0.162787), correlation (0.0942748)*/,
+            -11, 7, -9, 12 /*mean (0.21561), correlation (0.0974438)*/,
+            7, 7, 12, 6 /*mean (0.160583), correlation (0.130064)*/,
+            -4, -5, -3, 0 /*mean (0.228171), correlation (0.132998)*/,
+            -13, 2, -12, -3 /*mean (0.00997526), correlation (0.145926)*/,
+            -9, 0, -7, 5 /*mean (0.198234), correlation (0.143636)*/,
+            12, -6, 12, -1 /*mean (0.0676226), correlation (0.16689)*/,
+            -3, 6, -2, 12 /*mean (0.166847), correlation (0.171682)*/,
+            -6, -13, -4, -8 /*mean (0.101215), correlation (0.179716)*/,
+            11, -13, 12, -8 /*mean (0.200641), correlation (0.192279)*/,
+            4, 7, 5, 1 /*mean (0.205106), correlation (0.186848)*/,
+            5, -3, 10, -3 /*mean (0.234908), correlation (0.192319)*/,
+            3, -7, 6, 12 /*mean (0.0709964), correlation (0.210872)*/,
+            -8, -7, -6, -2 /*mean (0.0939834), correlation (0.212589)*/,
+            -2, 11, -1, -10 /*mean (0.127778), correlation (0.20866)*/,
+            -13, 12, -8, 10 /*mean (0.14783), correlation (0.206356)*/,
+            -7, 3, -5, -3 /*mean (0.182141), correlation (0.198942)*/,
+            -4, 2, -3, 7 /*mean (0.188237), correlation (0.21384)*/,
+            -10, -12, -6, 11 /*mean (0.14865), correlation (0.23571)*/,
+            5, -12, 6, -7 /*mean (0.222312), correlation (0.23324)*/,
+            5, -6, 7, -1 /*mean (0.229082), correlation (0.23389)*/,
+            1, 0, 4, -5 /*mean (0.241577), correlation (0.215286)*/,
+            9, 11, 11, -13 /*mean (0.00338507), correlation (0.251373)*/,
+            4, 7, 4, 12 /*mean (0.131005), correlation (0.257622)*/,
+            2, -1, 4, 4 /*mean (0.152755), correlation (0.255205)*/,
+            -4, -12, -2, 7 /*mean (0.182771), correlation (0.244867)*/,
+            -8, -5, -7, -10 /*mean (0.186898), correlation (0.23901)*/,
+            4, 11, 9, 12 /*mean (0.226226), correlation (0.258255)*/,
+            0, -8, 1, -13 /*mean (0.0897886), correlation (0.274827)*/,
+            -13, -2, -8, 2 /*mean (0.148774), correlation (0.28065)*/,
+            -3, -2, -2, 3 /*mean (0.153048), correlation (0.283063)*/,
+            -6, 9, -4, -9 /*mean (0.169523), correlation (0.278248)*/,
+            8, 12, 10, 7 /*mean (0.225337), correlation (0.282851)*/,
+            0, 9, 1, 3 /*mean (0.226687), correlation (0.278734)*/,
+            7, -5, 11, -10 /*mean (0.00693882), correlation (0.305161)*/,
+            -13, -6, -11, 0 /*mean (0.0227283), correlation (0.300181)*/,
+            10, 7, 12, 1 /*mean (0.125517), correlation (0.31089)*/,
+            -6, -3, -6, 12 /*mean (0.131748), correlation (0.312779)*/,
+            10, -9, 12, -4 /*mean (0.144827), correlation (0.292797)*/,
+            -13, 8, -8, -12 /*mean (0.149202), correlation (0.308918)*/,
+            -13, 0, -8, -4 /*mean (0.160909), correlation (0.310013)*/,
+            3, 3, 7, 8 /*mean (0.177755), correlation (0.309394)*/,
+            5, 7, 10, -7 /*mean (0.212337), correlation (0.310315)*/,
+            -1, 7, 1, -12 /*mean (0.214429), correlation (0.311933)*/,
+            3, -10, 5, 6 /*mean (0.235807), correlation (0.313104)*/,
+            2, -4, 3, -10 /*mean (0.00494827), correlation (0.344948)*/,
+            -13, 0, -13, 5 /*mean (0.0549145), correlation (0.344675)*/,
+            -13, -7, -12, 12 /*mean (0.103385), correlation (0.342715)*/,
+            -13, 3, -11, 8 /*mean (0.134222), correlation (0.322922)*/,
+            -7, 12, -4, 7 /*mean (0.153284), correlation (0.337061)*/,
+            6, -10, 12, 8 /*mean (0.154881), correlation (0.329257)*/,
+            -9, -1, -7, -6 /*mean (0.200967), correlation (0.33312)*/,
+            -2, -5, 0, 12 /*mean (0.201518), correlation (0.340635)*/,
+            -12, 5, -7, 5 /*mean (0.207805), correlation (0.335631)*/,
+            3, -10, 8, -13 /*mean (0.224438), correlation (0.34504)*/,
+            -7, -7, -4, 5 /*mean (0.239361), correlation (0.338053)*/,
+            -3, -2, -1, -7 /*mean (0.240744), correlation (0.344322)*/,
+            2, 9, 5, -11 /*mean (0.242949), correlation (0.34145)*/,
+            -11, -13, -5, -13 /*mean (0.244028), correlation (0.336861)*/,
+            -1, 6, 0, -1 /*mean (0.247571), correlation (0.343684)*/,
+            5, -3, 5, 2 /*mean (0.000697256), correlation (0.357265)*/,
+            -4, -13, -4, 12 /*mean (0.00213675), correlation (0.373827)*/,
+            -9, -6, -9, 6 /*mean (0.0126856), correlation (0.373938)*/,
+            -12, -10, -8, -4 /*mean (0.0152497), correlation (0.364237)*/,
+            10, 2, 12, -3 /*mean (0.0299933), correlation (0.345292)*/,
+            7, 12, 12, 12 /*mean (0.0307242), correlation (0.366299)*/,
+            -7, -13, -6, 5 /*mean (0.0534975), correlation (0.368357)*/,
+            -4, 9, -3, 4 /*mean (0.099865), correlation (0.372276)*/,
+            7, -1, 12, 2 /*mean (0.117083), correlation (0.364529)*/,
+            -7, 6, -5, 1 /*mean (0.126125), correlation (0.369606)*/,
+            -13, 11, -12, 5 /*mean (0.130364), correlation (0.358502)*/,
+            -3, 7, -2, -6 /*mean (0.131691), correlation (0.375531)*/,
+            7, -8, 12, -7 /*mean (0.160166), correlation (0.379508)*/,
+            -13, -7, -11, -12 /*mean (0.167848), correlation (0.353343)*/,
+            1, -3, 12, 12 /*mean (0.183378), correlation (0.371916)*/,
+            2, -6, 3, 0 /*mean (0.228711), correlation (0.371761)*/,
+            -4, 3, -2, -13 /*mean (0.247211), correlation (0.364063)*/,
+            -1, -13, 1, 9 /*mean (0.249325), correlation (0.378139)*/,
+            7, 1, 8, -6 /*mean (0.000652272), correlation (0.411682)*/,
+            1, -1, 3, 12 /*mean (0.00248538), correlation (0.392988)*/,
+            9, 1, 12, 6 /*mean (0.0206815), correlation (0.386106)*/,
+            -1, -9, -1, 3 /*mean (0.0364485), correlation (0.410752)*/,
+            -13, -13, -10, 5 /*mean (0.0376068), correlation (0.398374)*/,
+            7, 7, 10, 12 /*mean (0.0424202), correlation (0.405663)*/,
+            12, -5, 12, 9 /*mean (0.0942645), correlation (0.410422)*/,
+            6, 3, 7, 11 /*mean (0.1074), correlation (0.413224)*/,
+            5, -13, 6, 10 /*mean (0.109256), correlation (0.408646)*/,
+            2, -12, 2, 3 /*mean (0.131691), correlation (0.416076)*/,
+            3, 8, 4, -6 /*mean (0.165081), correlation (0.417569)*/,
+            2, 6, 12, -13 /*mean (0.171874), correlation (0.408471)*/,
+            9, -12, 10, 3 /*mean (0.175146), correlation (0.41296)*/,
+            -8, 4, -7, 9 /*mean (0.183682), correlation (0.402956)*/,
+            -11, 12, -4, -6 /*mean (0.184672), correlation (0.416125)*/,
+            1, 12, 2, -8 /*mean (0.191487), correlation (0.386696)*/,
+            6, -9, 7, -4 /*mean (0.192668), correlation (0.394771)*/,
+            2, 3, 3, -2 /*mean (0.200157), correlation (0.408303)*/,
+            6, 3, 11, 0 /*mean (0.204588), correlation (0.411762)*/,
+            3, -3, 8, -8 /*mean (0.205904), correlation (0.416294)*/,
+            7, 8, 9, 3 /*mean (0.213237), correlation (0.409306)*/,
+            -11, -5, -6, -4 /*mean (0.243444), correlation (0.395069)*/,
+            -10, 11, -5, 10 /*mean (0.247672), correlation (0.413392)*/,
+            -5, -8, -3, 12 /*mean (0.24774), correlation (0.411416)*/,
+            -10, 5, -9, 0 /*mean (0.00213675), correlation (0.454003)*/,
+            8, -1, 12, -6 /*mean (0.0293635), correlation (0.455368)*/,
+            4, -6, 6, -11 /*mean (0.0404971), correlation (0.457393)*/,
+            -10, 12, -8, 7 /*mean (0.0481107), correlation (0.448364)*/,
+            4, -2, 6, 7 /*mean (0.050641), correlation (0.455019)*/,
+            -2, 0, -2, 12 /*mean (0.0525978), correlation (0.44338)*/,
+            -5, -8, -5, 2 /*mean (0.0629667), correlation (0.457096)*/,
+            7, -6, 10, 12 /*mean (0.0653846), correlation (0.445623)*/,
+            -9, -13, -8, -8 /*mean (0.0858749), correlation (0.449789)*/,
+            -5, -13, -5, -2 /*mean (0.122402), correlation (0.450201)*/,
+            8, -8, 9, -13 /*mean (0.125416), correlation (0.453224)*/,
+            -9, -11, -9, 0 /*mean (0.130128), correlation (0.458724)*/,
+            1, -8, 1, -2 /*mean (0.132467), correlation (0.440133)*/,
+            7, -4, 9, 1 /*mean (0.132692), correlation (0.454)*/,
+            -2, 1, -1, -4 /*mean (0.135695), correlation (0.455739)*/,
+            11, -6, 12, -11 /*mean (0.142904), correlation (0.446114)*/,
+            -12, -9, -6, 4 /*mean (0.146165), correlation (0.451473)*/,
+            3, 7, 7, 12 /*mean (0.147627), correlation (0.456643)*/,
+            5, 5, 10, 8 /*mean (0.152901), correlation (0.455036)*/,
+            0, -4, 2, 8 /*mean (0.167083), correlation (0.459315)*/,
+            -9, 12, -5, -13 /*mean (0.173234), correlation (0.454706)*/,
+            0, 7, 2, 12 /*mean (0.18312), correlation (0.433855)*/,
+            -1, 2, 1, 7 /*mean (0.185504), correlation (0.443838)*/,
+            5, 11, 7, -9 /*mean (0.185706), correlation (0.451123)*/,
+            3, 5, 6, -8 /*mean (0.188968), correlation (0.455808)*/,
+            -13, -4, -8, 9 /*mean (0.191667), correlation (0.459128)*/,
+            -5, 9, -3, -3 /*mean (0.193196), correlation (0.458364)*/,
+            -4, -7, -3, -12 /*mean (0.196536), correlation (0.455782)*/,
+            6, 5, 8, 0 /*mean (0.1972), correlation (0.450481)*/,
+            -7, 6, -6, 12 /*mean (0.199438), correlation (0.458156)*/,
+            -13, 6, -5, -2 /*mean (0.211224), correlation (0.449548)*/,
+            1, -10, 3, 10 /*mean (0.211718), correlation (0.440606)*/,
+            4, 1, 8, -4 /*mean (0.213034), correlation (0.443177)*/,
+            -2, -2, 2, -13 /*mean (0.234334), correlation (0.455304)*/,
+            2, -12, 12, 12 /*mean (0.235684), correlation (0.443436)*/,
+            -2, -13, 0, -6 /*mean (0.237674), correlation (0.452525)*/,
+            4, 1, 9, 3 /*mean (0.23962), correlation (0.444824)*/,
+            -6, -10, -3, -5 /*mean (0.248459), correlation (0.439621)*/,
+            -3, -13, -1, 1 /*mean (0.249505), correlation (0.456666)*/,
+            7, 5, 12, -11 /*mean (0.00119208), correlation (0.495466)*/,
+            4, -2, 5, -7 /*mean (0.00372245), correlation (0.484214)*/,
+            -13, 9, -9, -5 /*mean (0.00741116), correlation (0.499854)*/,
+            7, 1, 8, 6 /*mean (0.0208952), correlation (0.499773)*/,
+            7, -8, 7, 6 /*mean (0.0220085), correlation (0.501609)*/,
+            -7, -4, -7, 1 /*mean (0.0233806), correlation (0.496568)*/,
+            -8, 11, -7, -8 /*mean (0.0236505), correlation (0.489719)*/,
+            -13, 6, -12, -8 /*mean (0.0268781), correlation (0.503487)*/,
+            2, 4, 3, 9 /*mean (0.0323324), correlation (0.501938)*/,
+            10, -5, 12, 3 /*mean (0.0399235), correlation (0.494029)*/,
+            -6, -5, -6, 7 /*mean (0.0420153), correlation (0.486579)*/,
+            8, -3, 9, -8 /*mean (0.0548021), correlation (0.484237)*/,
+            2, -12, 2, 8 /*mean (0.0616622), correlation (0.496642)*/,
+            -11, -2, -10, 3 /*mean (0.0627755), correlation (0.498563)*/,
+            -12, -13, -7, -9 /*mean (0.0829622), correlation (0.495491)*/,
+            -11, 0, -10, -5 /*mean (0.0843342), correlation (0.487146)*/,
+            5, -3, 11, 8 /*mean (0.0929937), correlation (0.502315)*/,
+            -2, -13, -1, 12 /*mean (0.113327), correlation (0.48941)*/,
+            -1, -8, 0, 9 /*mean (0.132119), correlation (0.467268)*/,
+            -13, -11, -12, -5 /*mean (0.136269), correlation (0.498771)*/,
+            -10, -2, -10, 11 /*mean (0.142173), correlation (0.498714)*/,
+            -3, 9, -2, -13 /*mean (0.144141), correlation (0.491973)*/,
+            2, -3, 3, 2 /*mean (0.14892), correlation (0.500782)*/,
+            -9, -13, -4, 0 /*mean (0.150371), correlation (0.498211)*/,
+            -4, 6, -3, -10 /*mean (0.152159), correlation (0.495547)*/,
+            -4, 12, -2, -7 /*mean (0.156152), correlation (0.496925)*/,
+            -6, -11, -4, 9 /*mean (0.15749), correlation (0.499222)*/,
+            6, -3, 6, 11 /*mean (0.159211), correlation (0.503821)*/,
+            -13, 11, -5, 5 /*mean (0.162427), correlation (0.501907)*/,
+            11, 11, 12, 6 /*mean (0.16652), correlation (0.497632)*/,
+            7, -5, 12, -2 /*mean (0.169141), correlation (0.484474)*/,
+            -1, 12, 0, 7 /*mean (0.169456), correlation (0.495339)*/,
+            -4, -8, -3, -2 /*mean (0.171457), correlation (0.487251)*/,
+            -7, 1, -6, 7 /*mean (0.175), correlation (0.500024)*/,
+            -13, -12, -8, -13 /*mean (0.175866), correlation (0.497523)*/,
+            -7, -2, -6, -8 /*mean (0.178273), correlation (0.501854)*/,
+            -8, 5, -6, -9 /*mean (0.181107), correlation (0.494888)*/,
+            -5, -1, -4, 5 /*mean (0.190227), correlation (0.482557)*/,
+            -13, 7, -8, 10 /*mean (0.196739), correlation (0.496503)*/,
+            1, 5, 5, -13 /*mean (0.19973), correlation (0.499759)*/,
+            1, 0, 10, -13 /*mean (0.204465), correlation (0.49873)*/,
+            9, 12, 10, -1 /*mean (0.209334), correlation (0.49063)*/,
+            5, -8, 10, -9 /*mean (0.211134), correlation (0.503011)*/,
+            -1, 11, 1, -13 /*mean (0.212), correlation (0.499414)*/,
+            -9, -3, -6, 2 /*mean (0.212168), correlation (0.480739)*/,
+            -1, -10, 1, 12 /*mean (0.212731), correlation (0.502523)*/,
+            -13, 1, -8, -10 /*mean (0.21327), correlation (0.489786)*/,
+            8, -11, 10, -6 /*mean (0.214159), correlation (0.488246)*/,
+            2, -13, 3, -6 /*mean (0.216993), correlation (0.50287)*/,
+            7, -13, 12, -9 /*mean (0.223639), correlation (0.470502)*/,
+            -10, -10, -5, -7 /*mean (0.224089), correlation (0.500852)*/,
+            -10, -8, -8, -13 /*mean (0.228666), correlation (0.502629)*/,
+            4, -6, 8, 5 /*mean (0.22906), correlation (0.498305)*/,
+            3, 12, 8, -13 /*mean (0.233378), correlation (0.503825)*/,
+            -4, 2, -3, -3 /*mean (0.234323), correlation (0.476692)*/,
+            5, -13, 10, -12 /*mean (0.236392), correlation (0.475462)*/,
+            4, -13, 5, -1 /*mean (0.236842), correlation (0.504132)*/,
+            -9, 9, -4, 3 /*mean (0.236977), correlation (0.497739)*/,
+            0, 3, 3, -9 /*mean (0.24314), correlation (0.499398)*/,
+            -12, 1, -6, 1 /*mean (0.243297), correlation (0.489447)*/,
+            3, 2, 4, -8 /*mean (0.00155196), correlation (0.553496)*/,
+            -10, -10, -10, 9 /*mean (0.00239541), correlation (0.54297)*/,
+            8, -13, 12, 12 /*mean (0.0034413), correlation (0.544361)*/,
+            -8, -12, -6, -5 /*mean (0.003565), correlation (0.551225)*/,
+            2, 2, 3, 7 /*mean (0.00835583), correlation (0.55285)*/,
+            10, 6, 11, -8 /*mean (0.00885065), correlation (0.540913)*/,
+            6, 8, 8, -12 /*mean (0.0101552), correlation (0.551085)*/,
+            -7, 10, -6, 5 /*mean (0.0102227), correlation (0.533635)*/,
+            -3, -9, -3, 9 /*mean (0.0110211), correlation (0.543121)*/,
+            -1, -13, -1, 5 /*mean (0.0113473), correlation (0.550173)*/,
+            -3, -7, -3, 4 /*mean (0.0140913), correlation (0.554774)*/,
+            -8, -2, -8, 3 /*mean (0.017049), correlation (0.55461)*/,
+            4, 2, 12, 12 /*mean (0.01778), correlation (0.546921)*/,
+            2, -5, 3, 11 /*mean (0.0224022), correlation (0.549667)*/,
+            6, -9, 11, -13 /*mean (0.029161), correlation (0.546295)*/,
+            3, -1, 7, 12 /*mean (0.0303081), correlation (0.548599)*/,
+            11, -1, 12, 4 /*mean (0.0355151), correlation (0.523943)*/,
+            -3, 0, -3, 6 /*mean (0.0417904), correlation (0.543395)*/,
+            4, -11, 4, 12 /*mean (0.0487292), correlation (0.542818)*/,
+            2, -4, 2, 1 /*mean (0.0575124), correlation (0.554888)*/,
+            -10, -6, -8, 1 /*mean (0.0594242), correlation (0.544026)*/,
+            -13, 7, -11, 1 /*mean (0.0597391), correlation (0.550524)*/,
+            -13, 12, -11, -13 /*mean (0.0608974), correlation (0.55383)*/,
+            6, 0, 11, -13 /*mean (0.065126), correlation (0.552006)*/,
+            0, -1, 1, 4 /*mean (0.074224), correlation (0.546372)*/,
+            -13, 3, -9, -2 /*mean (0.0808592), correlation (0.554875)*/,
+            -9, 8, -6, -3 /*mean (0.0883378), correlation (0.551178)*/,
+            -13, -6, -8, -2 /*mean (0.0901035), correlation (0.548446)*/,
+            5, -9, 8, 10 /*mean (0.0949843), correlation (0.554694)*/,
+            2, 7, 3, -9 /*mean (0.0994152), correlation (0.550979)*/,
+            -1, -6, -1, -1 /*mean (0.10045), correlation (0.552714)*/,
+            9, 5, 11, -2 /*mean (0.100686), correlation (0.552594)*/,
+            11, -3, 12, -8 /*mean (0.101091), correlation (0.532394)*/,
+            3, 0, 3, 5 /*mean (0.101147), correlation (0.525576)*/,
+            -1, 4, 0, 10 /*mean (0.105263), correlation (0.531498)*/,
+            3, -6, 4, 5 /*mean (0.110785), correlation (0.540491)*/,
+            -13, 0, -10, 5 /*mean (0.112798), correlation (0.536582)*/,
+            5, 8, 12, 11 /*mean (0.114181), correlation (0.555793)*/,
+            8, 9, 9, -6 /*mean (0.117431), correlation (0.553763)*/,
+            7, -4, 8, -12 /*mean (0.118522), correlation (0.553452)*/,
+            -10, 4, -10, 9 /*mean (0.12094), correlation (0.554785)*/,
+            7, 3, 12, 4 /*mean (0.122582), correlation (0.555825)*/,
+            9, -7, 10, -2 /*mean (0.124978), correlation (0.549846)*/,
+            7, 0, 12, -2 /*mean (0.127002), correlation (0.537452)*/,
+            -1, -6, 0, -11 /*mean (0.127148), correlation (0.547401)*/
+    };
+
+    ORBextractor::ORBextractor(int _nfeatures, float _scaleFactor, int _nlevels,
+                               int _iniThFAST, int _minThFAST) : nfeatures(_nfeatures), scaleFactor(_scaleFactor), nlevels(_nlevels),
+                                                                 iniThFAST(_iniThFAST), minThFAST(_minThFAST)
     {
-        keypoint->angle = IC_Angle(image, keypoint->pt, umax);
-    }
-}
+        mvScaleFactor.resize(nlevels);
+        mvLevelSigma2.resize(nlevels);
+        mvScaleFactor[0] = 1.0f;
+        mvLevelSigma2[0] = 1.0f;
+        for (int i = 1; i < nlevels; i++)
+        {
+            mvScaleFactor[i] = mvScaleFactor[i - 1] * scaleFactor;
+            mvLevelSigma2[i] = mvScaleFactor[i] * mvScaleFactor[i];
+        }
 
-void ExtractorNode::DivideNode(ExtractorNode &n1, ExtractorNode &n2, ExtractorNode &n3, ExtractorNode &n4)
-{
-    const int halfX = ceil(static_cast<float>(UR.x-UL.x)/2);
-    const int halfY = ceil(static_cast<float>(BR.y-UL.y)/2);
-
-    //Define boundaries of childs
-    n1.UL = UL;
-    n1.UR = cv::Point2i(UL.x+halfX,UL.y);
-    n1.BL = cv::Point2i(UL.x,UL.y+halfY);
-    n1.BR = cv::Point2i(UL.x+halfX,UL.y+halfY);
-    n1.vKeys.reserve(vKeys.size());
-
-    n2.UL = n1.UR;
-    n2.UR = UR;
-    n2.BL = n1.BR;
-    n2.BR = cv::Point2i(UR.x,UL.y+halfY);
-    n2.vKeys.reserve(vKeys.size());
-
-    n3.UL = n1.BL;
-    n3.UR = n1.BR;
-    n3.BL = BL;
-    n3.BR = cv::Point2i(n1.BR.x,BL.y);
-    n3.vKeys.reserve(vKeys.size());
-
-    n4.UL = n3.UR;
-    n4.UR = n2.BR;
-    n4.BL = n3.BR;
-    n4.BR = BR;
-    n4.vKeys.reserve(vKeys.size());
-
-    //Associate points to childs
-    for(size_t i=0;i<vKeys.size();i++)
-    {
-        const cv::KeyPoint &kp = vKeys[i];
-        if(kp.pt.x<n1.UR.x)
+        mvInvScaleFactor.resize(nlevels);
+        mvInvLevelSigma2.resize(nlevels);
+        for (int i = 0; i < nlevels; i++)
         {
-            if(kp.pt.y<n1.BR.y)
-                n1.vKeys.push_back(kp);
-            else
-                n3.vKeys.push_back(kp);
+            mvInvScaleFactor[i] = 1.0f / mvScaleFactor[i];
+            mvInvLevelSigma2[i] = 1.0f / mvLevelSigma2[i];
         }
-        else if(kp.pt.y<n1.BR.y)
-            n2.vKeys.push_back(kp);
-        else
-            n4.vKeys.push_back(kp);
-    }
 
-    if(n1.vKeys.size()==1)
-        n1.bNoMore = true;
-    if(n2.vKeys.size()==1)
-        n2.bNoMore = true;
-    if(n3.vKeys.size()==1)
-        n3.bNoMore = true;
-    if(n4.vKeys.size()==1)
-        n4.bNoMore = true;
+        mvImagePyramid.resize(nlevels);
 
-}
+        mnFeaturesPerLevel.resize(nlevels);
+        float factor = 1.0f / scaleFactor;
+        float nDesiredFeaturesPerScale = nfeatures * (1 - factor) / (1 - (float)pow((double)factor, (double)nlevels));
 
-vector<cv::KeyPoint> ORBextractor::DistributeOctTree(const vector<cv::KeyPoint>& vToDistributeKeys, const int &minX,
-                                       const int &maxX, const int &minY, const int &maxY, const int &N, const int &level)
-{
-    // Compute how many initial nodes   
-    const int nIni = round(static_cast<float>(maxX-minX)/(maxY-minY));
+        int sumFeatures = 0;
+        for (int level = 0; level < nlevels - 1; level++)
+        {
+            mnFeaturesPerLevel[level] = cvRound(nDesiredFeaturesPerScale);
+            sumFeatures += mnFeaturesPerLevel[level];
+            nDesiredFeaturesPerScale *= factor;
+        }
+        mnFeaturesPerLevel[nlevels - 1] = std::max(nfeatures - sumFeatures, 0);
 
-    const float hX = static_cast<float>(maxX-minX)/nIni;
+        const int npoints = 512;
+        const Point *pattern0 = (const Point *)bit_pattern_31_;
+        std::copy(pattern0, pattern0 + npoints, std::back_inserter(pattern));
 
-    list<ExtractorNode> lNodes;
+        // This is for orientation
+        //  pre-compute the end of a row in a circular patch
+        umax.resize(HALF_PATCH_SIZE + 1);
 
-    vector<ExtractorNode*> vpIniNodes;
-    vpIniNodes.resize(nIni);
+        int v, v0, vmax = cvFloor(HALF_PATCH_SIZE * sqrt(2.f) / 2 + 1);
+        int vmin = cvCeil(HALF_PATCH_SIZE * sqrt(2.f) / 2);
+        const double hp2 = HALF_PATCH_SIZE * HALF_PATCH_SIZE;
+        for (v = 0; v <= vmax; ++v)
+            umax[v] = cvRound(sqrt(hp2 - v * v));
 
-    for(int i=0; i<nIni; i++)
-    {
-        ExtractorNode ni;
-        ni.UL = cv::Point2i(hX*static_cast<float>(i),0);
-        ni.UR = cv::Point2i(hX*static_cast<float>(i+1),0);
-        ni.BL = cv::Point2i(ni.UL.x,maxY-minY);
-        ni.BR = cv::Point2i(ni.UR.x,maxY-minY);
-        ni.vKeys.reserve(vToDistributeKeys.size());
-
-        lNodes.push_back(ni);
-        vpIniNodes[i] = &lNodes.back();
+        // Make sure we are symmetric
+        for (v = HALF_PATCH_SIZE, v0 = 0; v >= vmin; --v)
+        {
+            while (umax[v0] == umax[v0 + 1])
+                ++v0;
+            umax[v] = v0;
+            ++v0;
+        }
     }
 
-    //Associate points to childs
-    for(size_t i=0;i<vToDistributeKeys.size();i++)
+    static void computeOrientation(const Mat &image, vector<KeyPoint> &keypoints, const vector<int> &umax)
     {
-        const cv::KeyPoint &kp = vToDistributeKeys[i];
-        vpIniNodes[kp.pt.x/hX]->vKeys.push_back(kp);
+        for (vector<KeyPoint>::iterator keypoint = keypoints.begin(),
+                                        keypointEnd = keypoints.end();
+             keypoint != keypointEnd; ++keypoint)
+        {
+            keypoint->angle = IC_Angle(image, keypoint->pt, umax);
+        }
     }
 
-    list<ExtractorNode>::iterator lit = lNodes.begin();
-
-    while(lit!=lNodes.end())
+    void ExtractorNode::DivideNode(ExtractorNode &n1, ExtractorNode &n2, ExtractorNode &n3, ExtractorNode &n4)
     {
-        if(lit->vKeys.size()==1)
+        const int halfX = ceil(static_cast<float>(UR.x - UL.x) / 2);
+        const int halfY = ceil(static_cast<float>(BR.y - UL.y) / 2);
+
+        // Define boundaries of childs
+        n1.UL = UL;
+        n1.UR = cv::Point2i(UL.x + halfX, UL.y);
+        n1.BL = cv::Point2i(UL.x, UL.y + halfY);
+        n1.BR = cv::Point2i(UL.x + halfX, UL.y + halfY);
+        n1.vKeys.reserve(vKeys.size());
+
+        n2.UL = n1.UR;
+        n2.UR = UR;
+        n2.BL = n1.BR;
+        n2.BR = cv::Point2i(UR.x, UL.y + halfY);
+        n2.vKeys.reserve(vKeys.size());
+
+        n3.UL = n1.BL;
+        n3.UR = n1.BR;
+        n3.BL = BL;
+        n3.BR = cv::Point2i(n1.BR.x, BL.y);
+        n3.vKeys.reserve(vKeys.size());
+
+        n4.UL = n3.UR;
+        n4.UR = n2.BR;
+        n4.BL = n3.BR;
+        n4.BR = BR;
+        n4.vKeys.reserve(vKeys.size());
+
+        // Associate points to childs
+        for (size_t i = 0; i < vKeys.size(); i++)
         {
-            lit->bNoMore=true;
-            lit++;
+            const cv::KeyPoint &kp = vKeys[i];
+            if (kp.pt.x < n1.UR.x)
+            {
+                if (kp.pt.y < n1.BR.y)
+                    n1.vKeys.push_back(kp);
+                else
+                    n3.vKeys.push_back(kp);
+            }
+            else if (kp.pt.y < n1.BR.y)
+                n2.vKeys.push_back(kp);
+            else
+                n4.vKeys.push_back(kp);
         }
-        else if(lit->vKeys.empty())
-            lit = lNodes.erase(lit);
-        else
-            lit++;
-    }
 
-    bool bFinish = false;
+        if (n1.vKeys.size() == 1)
+            n1.bNoMore = true;
+        if (n2.vKeys.size() == 1)
+            n2.bNoMore = true;
+        if (n3.vKeys.size() == 1)
+            n3.bNoMore = true;
+        if (n4.vKeys.size() == 1)
+            n4.bNoMore = true;
+    }
 
-    int iteration = 0;
+    vector<cv::KeyPoint> ORBextractor::DistributeOctTree(const vector<cv::KeyPoint> &vToDistributeKeys, const int &minX,
+                                                         const int &maxX, const int &minY, const int &maxY, const int &N, const int &level)
+    {
+        // Compute how many initial nodes
+        const int nIni = round(static_cast<float>(maxX - minX) / (maxY - minY));
 
-    vector<pair<int,ExtractorNode*> > vSizeAndPointerToNode;
-    vSizeAndPointerToNode.reserve(lNodes.size()*4);
+        const float hX = static_cast<float>(maxX - minX) / nIni;
 
-    while(!bFinish)
-    {
-        iteration++;
+        list<ExtractorNode> lNodes;
 
-        int prevSize = lNodes.size();
+        vector<ExtractorNode *> vpIniNodes;
+        vpIniNodes.resize(nIni);
 
-        lit = lNodes.begin();
+        for (int i = 0; i < nIni; i++)
+        {
+            ExtractorNode ni;
+            ni.UL = cv::Point2i(hX * static_cast<float>(i), 0);
+            ni.UR = cv::Point2i(hX * static_cast<float>(i + 1), 0);
+            ni.BL = cv::Point2i(ni.UL.x, maxY - minY);
+            ni.BR = cv::Point2i(ni.UR.x, maxY - minY);
+            ni.vKeys.reserve(vToDistributeKeys.size());
+
+            lNodes.push_back(ni);
+            vpIniNodes[i] = &lNodes.back();
+        }
 
-        int nToExpand = 0;
+        // Associate points to childs
+        for (size_t i = 0; i < vToDistributeKeys.size(); i++)
+        {
+            const cv::KeyPoint &kp = vToDistributeKeys[i];
+            vpIniNodes[kp.pt.x / hX]->vKeys.push_back(kp);
+        }
 
-        vSizeAndPointerToNode.clear();
+        list<ExtractorNode>::iterator lit = lNodes.begin();
 
-        while(lit!=lNodes.end())
+        while (lit != lNodes.end())
         {
-            if(lit->bNoMore)
+            if (lit->vKeys.size() == 1)
             {
-                // If node only contains one point do not subdivide and continue
+                lit->bNoMore = true;
                 lit++;
-                continue;
             }
+            else if (lit->vKeys.empty())
+                lit = lNodes.erase(lit);
             else
-            {
-                // If more than one point, subdivide
-                ExtractorNode n1,n2,n3,n4;
-                lit->DivideNode(n1,n2,n3,n4);
+                lit++;
+        }
 
-                // Add childs if they contain points
-                if(n1.vKeys.size()>0)
-                {
-                    lNodes.push_front(n1);                    
-                    if(n1.vKeys.size()>1)
-                    {
-                        nToExpand++;
-                        vSizeAndPointerToNode.push_back(make_pair(n1.vKeys.size(),&lNodes.front()));
-                        lNodes.front().lit = lNodes.begin();
-                    }
-                }
-                if(n2.vKeys.size()>0)
-                {
-                    lNodes.push_front(n2);
-                    if(n2.vKeys.size()>1)
-                    {
-                        nToExpand++;
-                        vSizeAndPointerToNode.push_back(make_pair(n2.vKeys.size(),&lNodes.front()));
-                        lNodes.front().lit = lNodes.begin();
-                    }
-                }
-                if(n3.vKeys.size()>0)
-                {
-                    lNodes.push_front(n3);
-                    if(n3.vKeys.size()>1)
-                    {
-                        nToExpand++;
-                        vSizeAndPointerToNode.push_back(make_pair(n3.vKeys.size(),&lNodes.front()));
-                        lNodes.front().lit = lNodes.begin();
-                    }
-                }
-                if(n4.vKeys.size()>0)
-                {
-                    lNodes.push_front(n4);
-                    if(n4.vKeys.size()>1)
-                    {
-                        nToExpand++;
-                        vSizeAndPointerToNode.push_back(make_pair(n4.vKeys.size(),&lNodes.front()));
-                        lNodes.front().lit = lNodes.begin();
-                    }
-                }
+        bool bFinish = false;
 
-                lit=lNodes.erase(lit);
-                continue;
-            }
-        }       
+        int iteration = 0;
 
-        // Finish if there are more nodes than required features
-        // or all nodes contain just one point
-        if((int)lNodes.size()>=N || (int)lNodes.size()==prevSize)
-        {
-            bFinish = true;
-        }
-        else if(((int)lNodes.size()+nToExpand*3)>N)
+        vector<pair<int, ExtractorNode *>> vSizeAndPointerToNode;
+        vSizeAndPointerToNode.reserve(lNodes.size() * 4);
+
+        while (!bFinish)
         {
+            iteration++;
 
-            while(!bFinish)
-            {
+            int prevSize = lNodes.size();
+
+            lit = lNodes.begin();
 
-                prevSize = lNodes.size();
+            int nToExpand = 0;
 
-                vector<pair<int,ExtractorNode*> > vPrevSizeAndPointerToNode = vSizeAndPointerToNode;
-                vSizeAndPointerToNode.clear();
+            vSizeAndPointerToNode.clear();
 
-                sort(vPrevSizeAndPointerToNode.begin(),vPrevSizeAndPointerToNode.end());
-                for(int j=vPrevSizeAndPointerToNode.size()-1;j>=0;j--)
+            while (lit != lNodes.end())
+            {
+                if (lit->bNoMore)
+                {
+                    // If node only contains one point do not subdivide and continue
+                    lit++;
+                    continue;
+                }
+                else
                 {
-                    ExtractorNode n1,n2,n3,n4;
-                    vPrevSizeAndPointerToNode[j].second->DivideNode(n1,n2,n3,n4);
+                    // If more than one point, subdivide
+                    ExtractorNode n1, n2, n3, n4;
+                    lit->DivideNode(n1, n2, n3, n4);
 
                     // Add childs if they contain points
-                    if(n1.vKeys.size()>0)
+                    if (n1.vKeys.size() > 0)
                     {
                         lNodes.push_front(n1);
-                        if(n1.vKeys.size()>1)
+                        if (n1.vKeys.size() > 1)
                         {
-                            vSizeAndPointerToNode.push_back(make_pair(n1.vKeys.size(),&lNodes.front()));
+                            nToExpand++;
+                            vSizeAndPointerToNode.push_back(make_pair(n1.vKeys.size(), &lNodes.front()));
                             lNodes.front().lit = lNodes.begin();
                         }
                     }
-                    if(n2.vKeys.size()>0)
+                    if (n2.vKeys.size() > 0)
                     {
                         lNodes.push_front(n2);
-                        if(n2.vKeys.size()>1)
+                        if (n2.vKeys.size() > 1)
                         {
-                            vSizeAndPointerToNode.push_back(make_pair(n2.vKeys.size(),&lNodes.front()));
+                            nToExpand++;
+                            vSizeAndPointerToNode.push_back(make_pair(n2.vKeys.size(), &lNodes.front()));
                             lNodes.front().lit = lNodes.begin();
                         }
                     }
-                    if(n3.vKeys.size()>0)
+                    if (n3.vKeys.size() > 0)
                     {
                         lNodes.push_front(n3);
-                        if(n3.vKeys.size()>1)
+                        if (n3.vKeys.size() > 1)
                         {
-                            vSizeAndPointerToNode.push_back(make_pair(n3.vKeys.size(),&lNodes.front()));
+                            nToExpand++;
+                            vSizeAndPointerToNode.push_back(make_pair(n3.vKeys.size(), &lNodes.front()));
                             lNodes.front().lit = lNodes.begin();
                         }
                     }
-                    if(n4.vKeys.size()>0)
+                    if (n4.vKeys.size() > 0)
                     {
                         lNodes.push_front(n4);
-                        if(n4.vKeys.size()>1)
+                        if (n4.vKeys.size() > 1)
                         {
-                            vSizeAndPointerToNode.push_back(make_pair(n4.vKeys.size(),&lNodes.front()));
+                            nToExpand++;
+                            vSizeAndPointerToNode.push_back(make_pair(n4.vKeys.size(), &lNodes.front()));
                             lNodes.front().lit = lNodes.begin();
                         }
                     }
 
-                    lNodes.erase(vPrevSizeAndPointerToNode[j].second->lit);
-
-                    if((int)lNodes.size()>=N)
-                        break;
+                    lit = lNodes.erase(lit);
+                    continue;
                 }
+            }
+
+            // Finish if there are more nodes than required features
+            // or all nodes contain just one point
+            if ((int)lNodes.size() >= N || (int)lNodes.size() == prevSize)
+            {
+                bFinish = true;
+            }
+            else if (((int)lNodes.size() + nToExpand * 3) > N)
+            {
+
+                while (!bFinish)
+                {
+
+                    prevSize = lNodes.size();
+
+                    vector<pair<int, ExtractorNode *>> vPrevSizeAndPointerToNode = vSizeAndPointerToNode;
+                    vSizeAndPointerToNode.clear();
+
+                    sort(vPrevSizeAndPointerToNode.begin(), vPrevSizeAndPointerToNode.end());
+                    for (int j = vPrevSizeAndPointerToNode.size() - 1; j >= 0; j--)
+                    {
+                        ExtractorNode n1, n2, n3, n4;
+                        vPrevSizeAndPointerToNode[j].second->DivideNode(n1, n2, n3, n4);
+
+                        // Add childs if they contain points
+                        if (n1.vKeys.size() > 0)
+                        {
+                            lNodes.push_front(n1);
+                            if (n1.vKeys.size() > 1)
+                            {
+                                vSizeAndPointerToNode.push_back(make_pair(n1.vKeys.size(), &lNodes.front()));
+                                lNodes.front().lit = lNodes.begin();
+                            }
+                        }
+                        if (n2.vKeys.size() > 0)
+                        {
+                            lNodes.push_front(n2);
+                            if (n2.vKeys.size() > 1)
+                            {
+                                vSizeAndPointerToNode.push_back(make_pair(n2.vKeys.size(), &lNodes.front()));
+                                lNodes.front().lit = lNodes.begin();
+                            }
+                        }
+                        if (n3.vKeys.size() > 0)
+                        {
+                            lNodes.push_front(n3);
+                            if (n3.vKeys.size() > 1)
+                            {
+                                vSizeAndPointerToNode.push_back(make_pair(n3.vKeys.size(), &lNodes.front()));
+                                lNodes.front().lit = lNodes.begin();
+                            }
+                        }
+                        if (n4.vKeys.size() > 0)
+                        {
+                            lNodes.push_front(n4);
+                            if (n4.vKeys.size() > 1)
+                            {
+                                vSizeAndPointerToNode.push_back(make_pair(n4.vKeys.size(), &lNodes.front()));
+                                lNodes.front().lit = lNodes.begin();
+                            }
+                        }
 
-                if((int)lNodes.size()>=N || (int)lNodes.size()==prevSize)
-                    bFinish = true;
+                        lNodes.erase(vPrevSizeAndPointerToNode[j].second->lit);
+
+                        if ((int)lNodes.size() >= N)
+                            break;
+                    }
 
+                    if ((int)lNodes.size() >= N || (int)lNodes.size() == prevSize)
+                        bFinish = true;
+                }
             }
         }
-    }
-
-    // Retain the best point in each node
-    vector<cv::KeyPoint> vResultKeys;
-    vResultKeys.reserve(nfeatures);
-    for(list<ExtractorNode>::iterator lit=lNodes.begin(); lit!=lNodes.end(); lit++)
-    {
-        vector<cv::KeyPoint> &vNodeKeys = lit->vKeys;
-        cv::KeyPoint* pKP = &vNodeKeys[0];
-        float maxResponse = pKP->response;
 
-        for(size_t k=1;k<vNodeKeys.size();k++)
+        // Retain the best point in each node
+        vector<cv::KeyPoint> vResultKeys;
+        vResultKeys.reserve(nfeatures);
+        for (list<ExtractorNode>::iterator lit = lNodes.begin(); lit != lNodes.end(); lit++)
         {
-            if(vNodeKeys[k].response>maxResponse)
+            vector<cv::KeyPoint> &vNodeKeys = lit->vKeys;
+            cv::KeyPoint *pKP = &vNodeKeys[0];
+            float maxResponse = pKP->response;
+
+            for (size_t k = 1; k < vNodeKeys.size(); k++)
             {
-                pKP = &vNodeKeys[k];
-                maxResponse = vNodeKeys[k].response;
+                if (vNodeKeys[k].response > maxResponse)
+                {
+                    pKP = &vNodeKeys[k];
+                    maxResponse = vNodeKeys[k].response;
+                }
             }
+
+            vResultKeys.push_back(*pKP);
         }
 
-        vResultKeys.push_back(*pKP);
+        return vResultKeys;
     }
 
-    return vResultKeys;
-}
-
-void ORBextractor::ComputeKeyPointsOctTree(vector<vector<KeyPoint> >& allKeypoints)
-{
-    allKeypoints.resize(nlevels);
-
-    const float W = 30;
-
-    for (int level = 0; level < nlevels; ++level)
+    void ORBextractor::ComputeKeyPointsOctTree(vector<vector<KeyPoint>> &allKeypoints)
     {
-        const int minBorderX = EDGE_THRESHOLD-3;
-        const int minBorderY = minBorderX;
-        const int maxBorderX = mvImagePyramid[level].cols-EDGE_THRESHOLD+3;
-        const int maxBorderY = mvImagePyramid[level].rows-EDGE_THRESHOLD+3;
-
-        vector<cv::KeyPoint> vToDistributeKeys;
-        vToDistributeKeys.reserve(nfeatures*10);
-
-        const float width = (maxBorderX-minBorderX);
-        const float height = (maxBorderY-minBorderY);
-
-        const int nCols = width/W;
-        const int nRows = height/W;
-        const int wCell = ceil(width/nCols);
-        const int hCell = ceil(height/nRows);
-#ifndef _BAR_
-        for(int i=0; i<nRows; i++)
-        {
-            const float iniY =minBorderY+i*hCell;
-            float maxY = iniY+hCell+6;
+        allKeypoints.resize(nlevels);
 
-            if(iniY>=maxBorderY-3)
-                continue;
-            if(maxY>maxBorderY)
-                maxY = maxBorderY;
+        const float W = 30;
 
-            for(int j=0; j<nCols; j++)
+        for (int level = 0; level < nlevels; ++level)
+        {
+            const int minBorderX = EDGE_THRESHOLD - 3;
+            const int minBorderY = minBorderX;
+            const int maxBorderX = mvImagePyramid[level].cols - EDGE_THRESHOLD + 3;
+            const int maxBorderY = mvImagePyramid[level].rows - EDGE_THRESHOLD + 3;
+
+            vector<cv::KeyPoint> vToDistributeKeys;
+            vToDistributeKeys.reserve(nfeatures * 10);
+
+            const float width = (maxBorderX - minBorderX);
+            const float height = (maxBorderY - minBorderY);
+
+            const int nCols = width / W;
+            const int nRows = height / W;
+            const int wCell = ceil(width / nCols);
+            const int hCell = ceil(height / nRows);
+            for (int i = 0; i < nRows; i++)
             {
-                const float iniX =minBorderX+j*wCell;
-                float maxX = iniX+wCell+6;
-                if(iniX>=maxBorderX-6)
-                    continue;
-                if(maxX>maxBorderX)
-                    maxX = maxBorderX;
+                const float iniY = minBorderY + i * hCell;
+                float maxY = iniY + hCell + 6;
 
-                vector<cv::KeyPoint> vKeysCell;
-                FAST(mvImagePyramid[level].rowRange(iniY,maxY).colRange(iniX,maxX),
-                     vKeysCell,iniThFAST,true);
+                if (iniY >= maxBorderY - 3)
+                    continue;
+                if (maxY > maxBorderY)
+                    maxY = maxBorderY;
 
-                if(vKeysCell.empty())
+                for (int j = 0; j < nCols; j++)
                 {
-                    FAST(mvImagePyramid[level].rowRange(iniY,maxY).colRange(iniX,maxX),
-                         vKeysCell,minThFAST,true);
-                }
+                    const float iniX = minBorderX + j * wCell;
+                    float maxX = iniX + wCell + 6;
+                    if (iniX >= maxBorderX - 6)
+                        continue;
+                    if (maxX > maxBorderX)
+                        maxX = maxBorderX;
 
-                if(!vKeysCell.empty())
-                {
-                    for(vector<cv::KeyPoint>::iterator vit=vKeysCell.begin(); vit!=vKeysCell.end();vit++)
+                    vector<cv::KeyPoint> vKeysCell;
+                    FAST(mvImagePyramid[level].rowRange(iniY, maxY).colRange(iniX, maxX),
+                        vKeysCell, iniThFAST, true);
+
+                    if (vKeysCell.empty())
                     {
-                        (*vit).pt.x+=j*wCell;
-                        (*vit).pt.y+=i*hCell;
-                        vToDistributeKeys.push_back(*vit);
+                        FAST(mvImagePyramid[level].rowRange(iniY, maxY).colRange(iniX, maxX),
+                            vKeysCell, minThFAST, true);
                     }
-                }
 
-            }
-        }
-#else
-        cv::FAST(mvImagePyramid[level].rowRange(minBorderY, maxBorderY).colRange(minBorderX, maxBorderX), vToDistributeKeys, minThFAST, true);
-#endif
-        vector<KeyPoint> & keypoints = allKeypoints[level];
-        keypoints.reserve(nfeatures);
-
-        keypoints = DistributeOctTree(vToDistributeKeys, minBorderX, maxBorderX,
-                                      minBorderY, maxBorderY,mnFeaturesPerLevel[level], level);
+                    if (!vKeysCell.empty())
+                    {
+                        for (vector<cv::KeyPoint>::iterator vit = vKeysCell.begin(); vit != vKeysCell.end(); vit++)
+                        {
+                            (*vit).pt.x += j * wCell;
+                            (*vit).pt.y += i * hCell;
+                            cv::KeyPoint kp = (*vit);
+                            //vToDistributeKeys.push_back(*vit);
+                            vToDistributeKeys.emplace_back(kp);
 
-        const int scaledPatchSize = PATCH_SIZE*mvScaleFactor[level];
+                        }
+                    }
 
-        // Add border to coordinates and scale information
-        const int nkps = keypoints.size();
-        for(int i=0; i<nkps ; i++)
-        {
-            keypoints[i].pt.x+=minBorderX;
-            keypoints[i].pt.y+=minBorderY;
-            keypoints[i].octave=level;
-            keypoints[i].size = scaledPatchSize;
-        }
-    }
+                }
+            }
 
-    // compute orientations
-    for (int level = 0; level < nlevels; ++level)
-        computeOrientation(mvImagePyramid[level], allKeypoints[level], umax);
-}
+            vector<KeyPoint> &keypoints = allKeypoints[level];
+            keypoints.reserve(nfeatures);
 
-void ORBextractor::ComputeKeyPointsOld(std::vector<std::vector<KeyPoint> > &allKeypoints)
-{
-    allKeypoints.resize(nlevels);
+            keypoints = DistributeOctTree(vToDistributeKeys, minBorderX, maxBorderX,
+                                          minBorderY, maxBorderY, mnFeaturesPerLevel[level], level);
 
-    float imageRatio = (float)mvImagePyramid[0].cols/mvImagePyramid[0].rows;
+            const int scaledPatchSize = PATCH_SIZE * mvScaleFactor[level];
 
-    for (int level = 0; level < nlevels; ++level)
-    {
-        const int nDesiredFeatures = mnFeaturesPerLevel[level];
+            // Add border to coordinates and scale information
+            const int nkps = keypoints.size();
+            for (int i = 0; i < nkps; i++)
+            {
+                keypoints[i].pt.x += minBorderX;
+                keypoints[i].pt.y += minBorderY;
+                keypoints[i].octave = level;
+                keypoints[i].size = scaledPatchSize;
+            }
+        }
 
-        const int levelCols = sqrt((float)nDesiredFeatures/(5*imageRatio));
-        const int levelRows = imageRatio*levelCols;
+        // compute orientations
+        for (int level = 0; level < nlevels; ++level)
+            computeOrientation(mvImagePyramid[level], allKeypoints[level], umax);
+    }
 
-        const int minBorderX = EDGE_THRESHOLD;
-        const int minBorderY = minBorderX;
-        const int maxBorderX = mvImagePyramid[level].cols-EDGE_THRESHOLD;
-        const int maxBorderY = mvImagePyramid[level].rows-EDGE_THRESHOLD;
+    void ORBextractor::ComputeKeyPointsOld(std::vector<std::vector<KeyPoint>> &allKeypoints)
+    {
+        allKeypoints.resize(nlevels);
 
-        const int W = maxBorderX - minBorderX;
-        const int H = maxBorderY - minBorderY;
-        const int cellW = ceil((float)W/levelCols);
-        const int cellH = ceil((float)H/levelRows);
+        float imageRatio = (float)mvImagePyramid[0].cols / mvImagePyramid[0].rows;
 
-        const int nCells = levelRows*levelCols;
-        const int nfeaturesCell = ceil((float)nDesiredFeatures/nCells);
+        for (int level = 0; level < nlevels; ++level)
+        {
+            const int nDesiredFeatures = mnFeaturesPerLevel[level];
 
-        vector<vector<vector<KeyPoint> > > cellKeyPoints(levelRows, vector<vector<KeyPoint> >(levelCols));
+            const int levelCols = sqrt((float)nDesiredFeatures / (5 * imageRatio));
+            const int levelRows = imageRatio * levelCols;
 
-        vector<vector<int> > nToRetain(levelRows,vector<int>(levelCols,0));
-        vector<vector<int> > nTotal(levelRows,vector<int>(levelCols,0));
-        vector<vector<bool> > bNoMore(levelRows,vector<bool>(levelCols,false));
-        vector<int> iniXCol(levelCols);
-        vector<int> iniYRow(levelRows);
-        int nNoMore = 0;
-        int nToDistribute = 0;
+            const int minBorderX = EDGE_THRESHOLD;
+            const int minBorderY = minBorderX;
+            const int maxBorderX = mvImagePyramid[level].cols - EDGE_THRESHOLD;
+            const int maxBorderY = mvImagePyramid[level].rows - EDGE_THRESHOLD;
 
+            const int W = maxBorderX - minBorderX;
+            const int H = maxBorderY - minBorderY;
+            const int cellW = ceil((float)W / levelCols);
+            const int cellH = ceil((float)H / levelRows);
 
-        float hY = cellH + 6;
+            const int nCells = levelRows * levelCols;
+            const int nfeaturesCell = ceil((float)nDesiredFeatures / nCells);
 
-        for(int i=0; i<levelRows; i++)
-        {
-            const float iniY = minBorderY + i*cellH - 3;
-            iniYRow[i] = iniY;
+            vector<vector<vector<KeyPoint>>> cellKeyPoints(levelRows, vector<vector<KeyPoint>>(levelCols));
 
-            if(i == levelRows-1)
-            {
-                hY = maxBorderY+3-iniY;
-                if(hY<=0)
-                    continue;
-            }
+            vector<vector<int>> nToRetain(levelRows, vector<int>(levelCols, 0));
+            vector<vector<int>> nTotal(levelRows, vector<int>(levelCols, 0));
+            vector<vector<bool>> bNoMore(levelRows, vector<bool>(levelCols, false));
+            vector<int> iniXCol(levelCols);
+            vector<int> iniYRow(levelRows);
+            int nNoMore = 0;
+            int nToDistribute = 0;
 
-            float hX = cellW + 6;
+            float hY = cellH + 6;
 
-            for(int j=0; j<levelCols; j++)
+            for (int i = 0; i < levelRows; i++)
             {
-                float iniX;
+                const float iniY = minBorderY + i * cellH - 3;
+                iniYRow[i] = iniY;
 
-                if(i==0)
-                {
-                    iniX = minBorderX + j*cellW - 3;
-                    iniXCol[j] = iniX;
-                }
-                else
+                if (i == levelRows - 1)
                 {
-                    iniX = iniXCol[j];
+                    hY = maxBorderY + 3 - iniY;
+                    if (hY <= 0)
+                        continue;
                 }
 
+                float hX = cellW + 6;
 
-                if(j == levelCols-1)
+                for (int j = 0; j < levelCols; j++)
                 {
-                    hX = maxBorderX+3-iniX;
-                    if(hX<=0)
-                        continue;
-                }
+                    float iniX;
 
+                    if (i == 0)
+                    {
+                        iniX = minBorderX + j * cellW - 3;
+                        iniXCol[j] = iniX;
+                    }
+                    else
+                    {
+                        iniX = iniXCol[j];
+                    }
 
-                Mat cellImage = mvImagePyramid[level].rowRange(iniY,iniY+hY).colRange(iniX,iniX+hX);
+                    if (j == levelCols - 1)
+                    {
+                        hX = maxBorderX + 3 - iniX;
+                        if (hX <= 0)
+                            continue;
+                    }
 
-                cellKeyPoints[i][j].reserve(nfeaturesCell*5);
+                    Mat cellImage = mvImagePyramid[level].rowRange(iniY, iniY + hY).colRange(iniX, iniX + hX);
 
-                FAST(cellImage,cellKeyPoints[i][j],iniThFAST,true);
+                    cellKeyPoints[i][j].reserve(nfeaturesCell * 5);
 
-                if(cellKeyPoints[i][j].size()<=3)
-                {
-                    cellKeyPoints[i][j].clear();
+                    FAST(cellImage, cellKeyPoints[i][j], iniThFAST, true);
 
-                    FAST(cellImage,cellKeyPoints[i][j],minThFAST,true);
-                }
+                    if (cellKeyPoints[i][j].size() <= 3)
+                    {
+                        cellKeyPoints[i][j].clear();
 
+                        FAST(cellImage, cellKeyPoints[i][j], minThFAST, true);
+                    }
 
-                const int nKeys = cellKeyPoints[i][j].size();
-                nTotal[i][j] = nKeys;
+                    const int nKeys = cellKeyPoints[i][j].size();
+                    nTotal[i][j] = nKeys;
 
-                if(nKeys>nfeaturesCell)
-                {
-                    nToRetain[i][j] = nfeaturesCell;
-                    bNoMore[i][j] = false;
-                }
-                else
-                {
-                    nToRetain[i][j] = nKeys;
-                    nToDistribute += nfeaturesCell-nKeys;
-                    bNoMore[i][j] = true;
-                    nNoMore++;
+                    if (nKeys > nfeaturesCell)
+                    {
+                        nToRetain[i][j] = nfeaturesCell;
+                        bNoMore[i][j] = false;
+                    }
+                    else
+                    {
+                        nToRetain[i][j] = nKeys;
+                        nToDistribute += nfeaturesCell - nKeys;
+                        bNoMore[i][j] = true;
+                        nNoMore++;
+                    }
                 }
-
             }
-        }
 
+            // Retain by score
 
-        // Retain by score
-
-        while(nToDistribute>0 && nNoMore<nCells)
-        {
-            int nNewFeaturesCell = nfeaturesCell + ceil((float)nToDistribute/(nCells-nNoMore));
-            nToDistribute = 0;
-
-            for(int i=0; i<levelRows; i++)
+            while (nToDistribute > 0 && nNoMore < nCells)
             {
-                for(int j=0; j<levelCols; j++)
+                int nNewFeaturesCell = nfeaturesCell + ceil((float)nToDistribute / (nCells - nNoMore));
+                nToDistribute = 0;
+
+                for (int i = 0; i < levelRows; i++)
                 {
-                    if(!bNoMore[i][j])
+                    for (int j = 0; j < levelCols; j++)
                     {
-                        if(nTotal[i][j]>nNewFeaturesCell)
+                        if (!bNoMore[i][j])
                         {
-                            nToRetain[i][j] = nNewFeaturesCell;
-                            bNoMore[i][j] = false;
-                        }
-                        else
-                        {
-                            nToRetain[i][j] = nTotal[i][j];
-                            nToDistribute += nNewFeaturesCell-nTotal[i][j];
-                            bNoMore[i][j] = true;
-                            nNoMore++;
+                            if (nTotal[i][j] > nNewFeaturesCell)
+                            {
+                                nToRetain[i][j] = nNewFeaturesCell;
+                                bNoMore[i][j] = false;
+                            }
+                            else
+                            {
+                                nToRetain[i][j] = nTotal[i][j];
+                                nToDistribute += nNewFeaturesCell - nTotal[i][j];
+                                bNoMore[i][j] = true;
+                                nNoMore++;
+                            }
                         }
                     }
                 }
             }
-        }
 
-        vector<KeyPoint> & keypoints = allKeypoints[level];
-        keypoints.reserve(nDesiredFeatures*2);
+            vector<KeyPoint> &keypoints = allKeypoints[level];
+            keypoints.reserve(nDesiredFeatures * 2);
 
-        const int scaledPatchSize = PATCH_SIZE*mvScaleFactor[level];
+            const int scaledPatchSize = PATCH_SIZE * mvScaleFactor[level];
 
-        // Retain by score and transform coordinates
-        for(int i=0; i<levelRows; i++)
-        {
-            for(int j=0; j<levelCols; j++)
+            // Retain by score and transform coordinates
+            for (int i = 0; i < levelRows; i++)
             {
-                vector<KeyPoint> &keysCell = cellKeyPoints[i][j];
-                KeyPointsFilter::retainBest(keysCell,nToRetain[i][j]);
-                if((int)keysCell.size()>nToRetain[i][j])
-                    keysCell.resize(nToRetain[i][j]);
-
-
-                for(size_t k=0, kend=keysCell.size(); k<kend; k++)
+                for (int j = 0; j < levelCols; j++)
                 {
-                    keysCell[k].pt.x+=iniXCol[j];
-                    keysCell[k].pt.y+=iniYRow[i];
-                    keysCell[k].octave=level;
-                    keysCell[k].size = scaledPatchSize;
-                    keypoints.push_back(keysCell[k]);
+                    vector<KeyPoint> &keysCell = cellKeyPoints[i][j];
+                    KeyPointsFilter::retainBest(keysCell, nToRetain[i][j]);
+                    if ((int)keysCell.size() > nToRetain[i][j])
+                        keysCell.resize(nToRetain[i][j]);
+
+                    for (size_t k = 0, kend = keysCell.size(); k < kend; k++)
+                    {
+                        keysCell[k].pt.x += iniXCol[j];
+                        keysCell[k].pt.y += iniYRow[i];
+                        keysCell[k].octave = level;
+                        keysCell[k].size = scaledPatchSize;
+                        keypoints.push_back(keysCell[k]);
+                    }
                 }
             }
-        }
 
-        if((int)keypoints.size()>nDesiredFeatures)
-        {
-            KeyPointsFilter::retainBest(keypoints,nDesiredFeatures);
-            keypoints.resize(nDesiredFeatures);
+            if ((int)keypoints.size() > nDesiredFeatures)
+            {
+                KeyPointsFilter::retainBest(keypoints, nDesiredFeatures);
+                keypoints.resize(nDesiredFeatures);
+            }
         }
-    }
 
-    // and compute orientations
-    for (int level = 0; level < nlevels; ++level)
-        computeOrientation(mvImagePyramid[level], allKeypoints[level], umax);
-}
+        // and compute orientations
+        for (int level = 0; level < nlevels; ++level)
+            computeOrientation(mvImagePyramid[level], allKeypoints[level], umax);
+    }
 
-static void computeDescriptors(const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors,
-                               const vector<Point>& pattern)
-{
-    descriptors = Mat::zeros((int)keypoints.size(), 32, CV_8UC1);
+    static void computeDescriptors(const Mat &image, vector<KeyPoint> &keypoints, Mat &descriptors,
+                                   const vector<Point> &pattern)
+    {
+        descriptors = Mat::zeros((int)keypoints.size(), 32, CV_8UC1);
 
-    for (size_t i = 0; i < keypoints.size(); i++)
-        computeOrbDescriptor(keypoints[i], image, &pattern[0], descriptors.ptr((int)i));
-}
+        for (size_t i = 0; i < keypoints.size(); i++)
+            computeOrbDescriptor(keypoints[i], image, &pattern[0], descriptors.ptr((int)i));
+    }
 
-void ORBextractor::operator()( InputArray _image, InputArray _mask, vector<KeyPoint>& _keypoints,
-                      OutputArray _descriptors)
-{ 
-    if(_image.empty())
-        return;
-
-    Mat image = _image.getMat();
-    assert(image.type() == CV_8UC1 );
-
-    // Pre-compute the scale pyramid
-    auto start = get_time2();
-    ComputePyramid(image);
-    auto end = get_time2();
-    //std::cout << "pyramid: " << get_time_diff2(start, end) << "\n";
-
-
-    vector < vector<KeyPoint> > allKeypoints;
-    start = get_time2();
-    ComputeKeyPointsOctTree(allKeypoints);
-    end = get_time2();
-    //std::cout << "kpts time: " << get_time_diff2(start, end) << "\n";
-    //ComputeKeyPointsOld(allKeypoints);
-
-    Mat descriptors;
-
-    int nkeypoints = 0;
-    for (int level = 0; level < nlevels; ++level)
-        nkeypoints += (int)allKeypoints[level].size();
-    if( nkeypoints == 0 )
-        _descriptors.release();
-    else
+    void ORBextractor::operator()(InputArray _image, InputArray _mask, vector<KeyPoint> &_keypoints,
+                                  OutputArray _descriptors)
     {
-        _descriptors.create(nkeypoints, 32, CV_8U);
-        descriptors = _descriptors.getMat();
-    }
+        if (_image.empty())
+            return;
+
+        Mat image = _image.getMat();
+        assert(image.type() == CV_8UC1);
+
+        // Pre-compute the scale pyramid
+        auto start = get_time2();
+        ComputePyramid(image);
+        auto end = get_time2();
+        // std::cout << "pyramid: " << get_time_diff2(start, end) << "\n";
+
+        vector<vector<KeyPoint>> allKeypoints;
+        start = get_time2();
+        ComputeKeyPointsOctTree(allKeypoints);
+        end = get_time2();
+        // std::cout << "kpts time: " << get_time_diff2(start, end) << "\n";
+        // ComputeKeyPointsOld(allKeypoints);
+
+        Mat descriptors;
+
+        int nkeypoints = 0;
+        for (int level = 0; level < nlevels; ++level)
+            nkeypoints += (int)allKeypoints[level].size();
+        if (nkeypoints == 0)
+            _descriptors.release();
+        else
+        {
+            _descriptors.create(nkeypoints, 32, CV_8U);
+            descriptors = _descriptors.getMat();
+        }
 
-    _keypoints.clear();
-    _keypoints.reserve(nkeypoints);
+        _keypoints.clear();
+        _keypoints.reserve(nkeypoints);
 
-    int offset = 0;
-    uint total_t = 0;
-    uint total_desc = 0;
-    start = get_time2();
-    for (int level = 0; level < nlevels; ++level)
-    {
-        vector<KeyPoint>& keypoints = allKeypoints[level];
-        int nkeypointsLevel = (int)keypoints.size();
-
-        if(nkeypointsLevel==0)
-            continue;
-
-        // preprocess the resized image
-        Mat workingMat = mvImagePyramid[level].clone();
-        auto start2 = get_time2();
-        GaussianBlur(workingMat, workingMat, Size(5, 5), 2, 2, BORDER_REFLECT_101);            
-        //boxFilter(workingMat, workingMat, workingMat.depth(), Size(5,5), Point(-1, -1), true, BORDER_REFLECT101);
-        auto end2 = get_time2();
-        total_t += get_time_diff2(start2, end2);
-        //std::cout << "curr total: " << total_t << "\n";
-
-        // Compute the descriptors
-        Mat desc = descriptors.rowRange(offset, offset + nkeypointsLevel);
-        start2 = get_time2();
-        computeDescriptors(workingMat, keypoints, desc, pattern);
-        end2 = get_time2();
-        total_desc += get_time_diff2(start2, end2);
-
-        offset += nkeypointsLevel;
-
-        // Scale keypoint coordinates
-        if (level != 0)
+        int offset = 0;
+        uint total_t = 0;
+        uint total_desc = 0;
+        start = get_time2();
+        for (int level = 0; level < nlevels; ++level)
         {
-            float scale = mvScaleFactor[level]; //getScale(level, firstLevel, scaleFactor);
-            for (vector<KeyPoint>::iterator keypoint = keypoints.begin(),
-                 keypointEnd = keypoints.end(); keypoint != keypointEnd; ++keypoint)
-                keypoint->pt *= scale;
+            vector<KeyPoint> &keypoints = allKeypoints[level];
+            int nkeypointsLevel = (int)keypoints.size();
+
+            if (nkeypointsLevel == 0)
+                continue;
+
+            // preprocess the resized image
+            Mat workingMat = mvImagePyramid[level].clone();
+            auto start2 = get_time2();
+            GaussianBlur(workingMat, workingMat, Size(5, 5), 2, 2, BORDER_REFLECT_101);
+            // boxFilter(workingMat, workingMat, workingMat.depth(), Size(5,5), Point(-1, -1), true, BORDER_REFLECT101);
+            auto end2 = get_time2();
+            total_t += get_time_diff2(start2, end2);
+            // std::cout << "curr total: " << total_t << "\n";
+
+            // Compute the descriptors
+            Mat desc = descriptors.rowRange(offset, offset + nkeypointsLevel);
+            start2 = get_time2();
+            computeDescriptors(workingMat, keypoints, desc, pattern);
+            end2 = get_time2();
+            total_desc += get_time_diff2(start2, end2);
+
+            offset += nkeypointsLevel;
+
+            // Scale keypoint coordinates
+            if (level != 0)
+            {
+                float scale = mvScaleFactor[level]; // getScale(level, firstLevel, scaleFactor);
+                for (vector<KeyPoint>::iterator keypoint = keypoints.begin(),
+                                                keypointEnd = keypoints.end();
+                     keypoint != keypointEnd; ++keypoint)
+                    keypoint->pt *= scale;
+            }
+            // And add the keypoints to the output
+            _keypoints.insert(_keypoints.end(), keypoints.begin(), keypoints.end());
         }
-        // And add the keypoints to the output
-        _keypoints.insert(_keypoints.end(), keypoints.begin(), keypoints.end());
+        end = get_time2();
+        // std::cout << "descriptors: " << get_time_diff2(start, end) << "\n";
+        // std::cout << "only descriptors: " << total_desc << "\n";
     }
-    end = get_time2();
-    //std::cout << "descriptors: " << get_time_diff2(start, end) << "\n";
-    //std::cout << "only descriptors: " << total_desc << "\n";
-}
 
-void ORBextractor::ComputePyramid(cv::Mat image)
-{
-    for (int level = 0; level < nlevels; ++level)
+    void ORBextractor::ComputePyramid(cv::Mat image)
     {
-        float scale = mvInvScaleFactor[level];
-        Size sz(cvRound((float)image.cols*scale), cvRound((float)image.rows*scale));
-        Size wholeSize(sz.width + EDGE_THRESHOLD*2, sz.height + EDGE_THRESHOLD*2);
-        Mat temp(wholeSize, image.type()), masktemp;
-        mvImagePyramid[level] = temp(Rect(EDGE_THRESHOLD, EDGE_THRESHOLD, sz.width, sz.height));
-
-        // Compute the resized image
-        if( level != 0 )
+        for (int level = 0; level < nlevels; ++level)
         {
-            resize(mvImagePyramid[level-1], mvImagePyramid[level], sz, 0, 0, INTER_LINEAR);
+            float scale = mvInvScaleFactor[level];
+            Size sz(cvRound((float)image.cols * scale), cvRound((float)image.rows * scale));
+            Size wholeSize(sz.width + EDGE_THRESHOLD * 2, sz.height + EDGE_THRESHOLD * 2);
+            Mat temp(wholeSize, image.type()), masktemp;
+            mvImagePyramid[level] = temp(Rect(EDGE_THRESHOLD, EDGE_THRESHOLD, sz.width, sz.height));
+
+            // Compute the resized image
+            if (level != 0)
+            {
+                resize(mvImagePyramid[level - 1], mvImagePyramid[level], sz, 0, 0, INTER_LINEAR);
 
-            copyMakeBorder(mvImagePyramid[level], temp, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD,
-                           BORDER_REFLECT_101+BORDER_ISOLATED);            
-        }
-        else
-        {
-            //GaussianBlur(image, image, Size(5, 5), 2, 2, BORDER_REFLECT_101);            
-            copyMakeBorder(image, temp, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD,
-                           BORDER_REFLECT_101);            
+                copyMakeBorder(mvImagePyramid[level], temp, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD,
+                               BORDER_REFLECT_101 + BORDER_ISOLATED);
+            }
+            else
+            {
+                // GaussianBlur(image, image, Size(5, 5), 2, 2, BORDER_REFLECT_101);
+                copyMakeBorder(image, temp, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD, EDGE_THRESHOLD,
+                               BORDER_REFLECT_101);
+            }
         }
     }
 
-}
-
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/ORBmatcher.cc b/slam/src/ORBmatcher.cc
index e62ce44..892bb59 100644
--- a/slam/src/ORBmatcher.cc
+++ b/slam/src/ORBmatcher.cc
@@ -1,1668 +1,1658 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "ORBmatcher.h"
 
-#include<limits.h>
+#include <limits.h>
 
-#include<opencv2/core/core.hpp>
-#include<opencv2/features2d/features2d.hpp>
+#include <opencv2/core/core.hpp>
+#include <opencv2/features2d/features2d.hpp>
 
-#include "../Thirdparty/DBoW2/DBoW2/FeatureVector.h"
+#include "DBoW2/FeatureVector.h"
 
-#include<stdint-gcc.h>
+#include <stdint.h>
 
 using namespace std;
 
 namespace ORB_SLAM2
 {
 
-const int ORBmatcher::TH_HIGH = 100;
-const int ORBmatcher::TH_LOW = 50;
-const int ORBmatcher::HISTO_LENGTH = 30;
+    const int ORBmatcher::TH_HIGH = 100;
+    const int ORBmatcher::TH_LOW = 50;
+    const int ORBmatcher::HISTO_LENGTH = 30;
 
-ORBmatcher::ORBmatcher(float nnratio, bool checkOri): mfNNratio(nnratio), mbCheckOrientation(checkOri)
-{
-}
-
-int ORBmatcher::SearchByProjection(Frame &F, const vector<MapPoint*> &vpMapPoints, const float th)
-{
-    int nmatches=0;
-
-    const bool bFactor = th!=1.0;
+    ORBmatcher::ORBmatcher(float nnratio, bool checkOri) : mfNNratio(nnratio), mbCheckOrientation(checkOri)
+    {
+    }
 
-    for(size_t iMP=0; iMP<vpMapPoints.size(); iMP++)
+    int ORBmatcher::SearchByProjection(Frame &F, const vector<MapPoint *> &vpMapPoints, const float th)
     {
-        MapPoint* pMP = vpMapPoints[iMP];
-        if(!pMP->mbTrackInView)
-            continue;
+        int nmatches = 0;
 
-        if(pMP->isBad())
-            continue;
+        const bool bFactor = th != 1.0;
 
-        const int &nPredictedLevel = pMP->mnTrackScaleLevel;
+        for (size_t iMP = 0; iMP < vpMapPoints.size(); iMP++)
+        {
+            MapPoint *pMP = vpMapPoints[iMP];
+            if (!pMP->mbTrackInView)
+                continue;
 
-        // The size of the window will depend on the viewing direction
-        float r = RadiusByViewingCos(pMP->mTrackViewCos);
+            if (pMP->isBad())
+                continue;
 
-        if(bFactor)
-            r*=th;
+            const int &nPredictedLevel = pMP->mnTrackScaleLevel;
 
-        const vector<size_t> vIndices =
-                F.GetFeaturesInArea(pMP->mTrackProjX,pMP->mTrackProjY,r*F.mvScaleFactors[nPredictedLevel],nPredictedLevel-1,nPredictedLevel);
+            // The size of the window will depend on the viewing direction
+            float r = RadiusByViewingCos(pMP->mTrackViewCos);
 
-        if(vIndices.empty())
-            continue;
+            if (bFactor)
+                r *= th;
 
-        const cv::Mat MPdescriptor = pMP->GetDescriptor();
+            const vector<size_t> vIndices =
+                F.GetFeaturesInArea(pMP->mTrackProjX, pMP->mTrackProjY, r * F.mvScaleFactors[nPredictedLevel], nPredictedLevel - 1, nPredictedLevel);
 
-        int bestDist=256;
-        int bestLevel= -1;
-        int bestDist2=256;
-        int bestLevel2 = -1;
-        int bestIdx =-1 ;
+            if (vIndices.empty())
+                continue;
 
-        // Get best and second matches with near keypoints
-        for(vector<size_t>::const_iterator vit=vIndices.begin(), vend=vIndices.end(); vit!=vend; vit++)
-        {
-            const size_t idx = *vit;
+            const cv::Mat MPdescriptor = pMP->GetDescriptor();
 
-            if(F.mvpMapPoints[idx])
-                if(F.mvpMapPoints[idx]->Observations()>0)
-                    continue;
+            int bestDist = 256;
+            int bestLevel = -1;
+            int bestDist2 = 256;
+            int bestLevel2 = -1;
+            int bestIdx = -1;
 
-            if(F.mvuRight[idx]>0)
+            // Get best and second matches with near keypoints
+            for (vector<size_t>::const_iterator vit = vIndices.begin(), vend = vIndices.end(); vit != vend; vit++)
             {
-                const float er = fabs(pMP->mTrackProjXR-F.mvuRight[idx]);
-                if(er>r*F.mvScaleFactors[nPredictedLevel])
-                    continue;
-            }
+                const size_t idx = *vit;
 
-            const cv::Mat &d = F.mDescriptors.row(idx);
+                if (F.mvpMapPoints[idx])
+                    if (F.mvpMapPoints[idx]->Observations() > 0)
+                        continue;
 
-            const int dist = DescriptorDistance(MPdescriptor,d);
+                if (F.mvuRight[idx] > 0)
+                {
+                    const float er = fabs(pMP->mTrackProjXR - F.mvuRight[idx]);
+                    if (er > r * F.mvScaleFactors[nPredictedLevel])
+                        continue;
+                }
 
-            if(dist<bestDist)
-            {
-                bestDist2=bestDist;
-                bestDist=dist;
-                bestLevel2 = bestLevel;
-                bestLevel = F.mvKeysUn[idx].octave;
-                bestIdx=idx;
+                const cv::Mat &d = F.mDescriptors.row(idx);
+
+                const int dist = DescriptorDistance(MPdescriptor, d);
+
+                if (dist < bestDist)
+                {
+                    bestDist2 = bestDist;
+                    bestDist = dist;
+                    bestLevel2 = bestLevel;
+                    bestLevel = F.mvKeysUn[idx].octave;
+                    bestIdx = idx;
+                }
+                else if (dist < bestDist2)
+                {
+                    bestLevel2 = F.mvKeysUn[idx].octave;
+                    bestDist2 = dist;
+                }
             }
-            else if(dist<bestDist2)
+
+            // Apply ratio to second match (only if best and second are in the same scale level)
+            if (bestDist <= TH_HIGH)
             {
-                bestLevel2 = F.mvKeysUn[idx].octave;
-                bestDist2=dist;
+                if (bestLevel == bestLevel2 && bestDist > mfNNratio * bestDist2)
+                    continue;
+
+                F.mvpMapPoints[bestIdx] = pMP;
+                nmatches++;
             }
         }
 
-        // Apply ratio to second match (only if best and second are in the same scale level)
-        if(bestDist<=TH_HIGH)
-        {
-            if(bestLevel==bestLevel2 && bestDist>mfNNratio*bestDist2)
-                continue;
-
-            F.mvpMapPoints[bestIdx]=pMP;
-            nmatches++;
-        }
+        return nmatches;
     }
 
-    return nmatches;
-}
-
-float ORBmatcher::RadiusByViewingCos(const float &viewCos)
-{
-    if(viewCos>0.998)
-        return 2.5;
-    else
-        return 4.0;
-}
-
+    float ORBmatcher::RadiusByViewingCos(const float &viewCos)
+    {
+        if (viewCos > 0.998)
+            return 2.5;
+        else
+            return 4.0;
+    }
 
-bool ORBmatcher::CheckDistEpipolarLine(const cv::KeyPoint &kp1,const cv::KeyPoint &kp2,const cv::Mat &F12,const KeyFrame* pKF2)
-{
-    // Epipolar line in second image l = x1'F12 = [a b c]
-    const float a = kp1.pt.x*F12.at<float>(0,0)+kp1.pt.y*F12.at<float>(1,0)+F12.at<float>(2,0);
-    const float b = kp1.pt.x*F12.at<float>(0,1)+kp1.pt.y*F12.at<float>(1,1)+F12.at<float>(2,1);
-    const float c = kp1.pt.x*F12.at<float>(0,2)+kp1.pt.y*F12.at<float>(1,2)+F12.at<float>(2,2);
+    bool ORBmatcher::CheckDistEpipolarLine(const cv::KeyPoint &kp1, const cv::KeyPoint &kp2, const cv::Mat &F12, const KeyFrame *pKF2)
+    {
+        // Epipolar line in second image l = x1'F12 = [a b c]
+        const float a = kp1.pt.x * F12.at<float>(0, 0) + kp1.pt.y * F12.at<float>(1, 0) + F12.at<float>(2, 0);
+        const float b = kp1.pt.x * F12.at<float>(0, 1) + kp1.pt.y * F12.at<float>(1, 1) + F12.at<float>(2, 1);
+        const float c = kp1.pt.x * F12.at<float>(0, 2) + kp1.pt.y * F12.at<float>(1, 2) + F12.at<float>(2, 2);
 
-    const float num = a*kp2.pt.x+b*kp2.pt.y+c;
+        const float num = a * kp2.pt.x + b * kp2.pt.y + c;
 
-    const float den = a*a+b*b;
+        const float den = a * a + b * b;
 
-    if(den==0)
-        return false;
+        if (den == 0)
+            return false;
 
-    const float dsqr = num*num/den;
+        const float dsqr = num * num / den;
 
-    return dsqr<3.84*pKF2->mvLevelSigma2[kp2.octave];
-}
+        return dsqr < 3.84 * pKF2->mvLevelSigma2[kp2.octave];
+    }
 
-int ORBmatcher::SearchByBoW(KeyFrame* pKF,Frame &F, vector<MapPoint*> &vpMapPointMatches)
-{
-    const vector<MapPoint*> vpMapPointsKF = pKF->GetMapPointMatches();
+    int ORBmatcher::SearchByBoW(KeyFrame *pKF, Frame &F, vector<MapPoint *> &vpMapPointMatches)
+    {
+        const vector<MapPoint *> vpMapPointsKF = pKF->GetMapPointMatches();
 
-    //cout << "SearchByBoW: ref KF points size = " << vpMapPointsKF.size();
-    vpMapPointMatches = vector<MapPoint*>(F.N,static_cast<MapPoint*>(NULL));
+        // cout << "SearchByBoW: ref KF points size = " << vpMapPointsKF.size();
+        vpMapPointMatches = vector<MapPoint *>(F.N, static_cast<MapPoint *>(NULL));
 
-    const DBoW2::FeatureVector &vFeatVecKF = pKF->mFeatVec;
+        const DBoW2::FeatureVector &vFeatVecKF = pKF->mFeatVec;
 
-    int nmatches=0;
+        int nmatches = 0;
 
-    //cout << "SearchByBoW: CP1 nmatches =  " << nmatches << endl;
+        // cout << "SearchByBoW: CP1 nmatches =  " << nmatches << endl;
 
-    vector<int> rotHist[HISTO_LENGTH];
-    for(int i=0;i<HISTO_LENGTH;i++)
-        rotHist[i].reserve(500);
-    const float factor = 1.0f/HISTO_LENGTH;
+        vector<int> rotHist[HISTO_LENGTH];
+        for (int i = 0; i < HISTO_LENGTH; i++)
+            rotHist[i].reserve(500);
+        const float factor = 1.0f / HISTO_LENGTH;
 
-    // We perform the matching over ORB that belong to the same vocabulary node (at a certain level)
-    DBoW2::FeatureVector::const_iterator KFit = vFeatVecKF.begin();
-    DBoW2::FeatureVector::const_iterator Fit = F.mFeatVec.begin();
-    DBoW2::FeatureVector::const_iterator KFend = vFeatVecKF.end();
-    DBoW2::FeatureVector::const_iterator Fend = F.mFeatVec.end();
+        // We perform the matching over ORB that belong to the same vocabulary node (at a certain level)
+        DBoW2::FeatureVector::const_iterator KFit = vFeatVecKF.begin();
+        DBoW2::FeatureVector::const_iterator Fit = F.mFeatVec.begin();
+        DBoW2::FeatureVector::const_iterator KFend = vFeatVecKF.end();
+        DBoW2::FeatureVector::const_iterator Fend = F.mFeatVec.end();
 
-    while(KFit != KFend && Fit != Fend)
-    {
-        if(KFit->first == Fit->first)
+        while (KFit != KFend && Fit != Fend)
         {
-            const vector<unsigned int> vIndicesKF = KFit->second;
-            const vector<unsigned int> vIndicesF = Fit->second;
-
-            for(size_t iKF=0; iKF<vIndicesKF.size(); iKF++)
+            if (KFit->first == Fit->first)
             {
-                const unsigned int realIdxKF = vIndicesKF[iKF];
+                const vector<unsigned int> vIndicesKF = KFit->second;
+                const vector<unsigned int> vIndicesF = Fit->second;
 
-                MapPoint* pMP = vpMapPointsKF[realIdxKF];
+                for (size_t iKF = 0; iKF < vIndicesKF.size(); iKF++)
+                {
+                    const unsigned int realIdxKF = vIndicesKF[iKF];
 
-                if(!pMP)
-                    continue;
+                    MapPoint *pMP = vpMapPointsKF[realIdxKF];
 
-                if(pMP->isBad())
-                    continue;                
+                    if (!pMP)
+                        continue;
 
-                const cv::Mat &dKF= pKF->mDescriptors.row(realIdxKF);
+                    if (pMP->isBad())
+                        continue;
 
-                int bestDist1=256;
-                int bestIdxF =-1 ;
-                int bestDist2=256;
+                    const cv::Mat &dKF = pKF->mDescriptors.row(realIdxKF);
 
-                for(size_t iF=0; iF<vIndicesF.size(); iF++)
-                {
-                    const unsigned int realIdxF = vIndicesF[iF];
+                    int bestDist1 = 256;
+                    int bestIdxF = -1;
+                    int bestDist2 = 256;
 
-                    if(vpMapPointMatches[realIdxF])
-                        continue;
+                    for (size_t iF = 0; iF < vIndicesF.size(); iF++)
+                    {
+                        const unsigned int realIdxF = vIndicesF[iF];
 
-                    const cv::Mat &dF = F.mDescriptors.row(realIdxF);
+                        if (vpMapPointMatches[realIdxF])
+                            continue;
 
-                    const int dist =  DescriptorDistance(dKF,dF);
+                        const cv::Mat &dF = F.mDescriptors.row(realIdxF);
 
-                    if(dist<bestDist1)
-                    {
-                        bestDist2=bestDist1;
-                        bestDist1=dist;
-                        bestIdxF=realIdxF;
-                    }
-                    else if(dist<bestDist2)
-                    {
-                        bestDist2=dist;
+                        const int dist = DescriptorDistance(dKF, dF);
+
+                        if (dist < bestDist1)
+                        {
+                            bestDist2 = bestDist1;
+                            bestDist1 = dist;
+                            bestIdxF = realIdxF;
+                        }
+                        else if (dist < bestDist2)
+                        {
+                            bestDist2 = dist;
+                        }
                     }
-                }
 
-                if(bestDist1<=TH_LOW)
-                {
-                    if(static_cast<float>(bestDist1)<mfNNratio*static_cast<float>(bestDist2))
+                    if (bestDist1 <= TH_LOW)
                     {
-                        vpMapPointMatches[bestIdxF]=pMP;
-
-                        const cv::KeyPoint &kp = pKF->mvKeysUn[realIdxKF];
-
-                        if(mbCheckOrientation)
+                        if (static_cast<float>(bestDist1) < mfNNratio * static_cast<float>(bestDist2))
                         {
-                            float rot = kp.angle-F.mvKeys[bestIdxF].angle;
-                            if(rot<0.0)
-                                rot+=360.0f;
-                            int bin = round(rot*factor);
-                            if(bin==HISTO_LENGTH)
-                                bin=0;
-                            assert(bin>=0 && bin<HISTO_LENGTH);
-                            rotHist[bin].push_back(bestIdxF);
+                            vpMapPointMatches[bestIdxF] = pMP;
+
+                            const cv::KeyPoint &kp = pKF->mvKeysUn[realIdxKF];
+
+                            if (mbCheckOrientation)
+                            {
+                                float rot = kp.angle - F.mvKeys[bestIdxF].angle;
+                                if (rot < 0.0)
+                                    rot += 360.0f;
+                                int bin = round(rot * factor);
+                                if (bin == HISTO_LENGTH)
+                                    bin = 0;
+                                assert(bin >= 0 && bin < HISTO_LENGTH);
+                                rotHist[bin].push_back(bestIdxF);
+                            }
+                            nmatches++;
                         }
-                        nmatches++;
                     }
                 }
 
+                KFit++;
+                Fit++;
+            }
+            else if (KFit->first < Fit->first)
+            {
+                KFit = vFeatVecKF.lower_bound(Fit->first);
+            }
+            else
+            {
+                Fit = F.mFeatVec.lower_bound(KFit->first);
             }
-
-            KFit++;
-            Fit++;
-        }
-        else if(KFit->first < Fit->first)
-        {
-            KFit = vFeatVecKF.lower_bound(Fit->first);
-        }
-        else
-        {
-            Fit = F.mFeatVec.lower_bound(KFit->first);
         }
-    }
-
 
-    if(mbCheckOrientation)
-    {
-        int ind1=-1;
-        int ind2=-1;
-        int ind3=-1;
+        if (mbCheckOrientation)
+        {
+            int ind1 = -1;
+            int ind2 = -1;
+            int ind3 = -1;
 
-        ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3);
+            ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);
 
-        for(int i=0; i<HISTO_LENGTH; i++)
-        {
-            if(i==ind1 || i==ind2 || i==ind3)
-                continue;
-            for(size_t j=0, jend=rotHist[i].size(); j<jend; j++)
+            for (int i = 0; i < HISTO_LENGTH; i++)
             {
-                vpMapPointMatches[rotHist[i][j]]=static_cast<MapPoint*>(NULL);
-                nmatches--;
+                if (i == ind1 || i == ind2 || i == ind3)
+                    continue;
+                for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
+                {
+                    vpMapPointMatches[rotHist[i][j]] = static_cast<MapPoint *>(NULL);
+                    nmatches--;
+                }
             }
         }
-    }
 
-    return nmatches;
-}
+        return nmatches;
+    }
 
-int ORBmatcher::SearchByProjection(KeyFrame* pKF, cv::Mat Scw, const vector<MapPoint*> &vpPoints, vector<MapPoint*> &vpMatched, int th)
-{
-    // Get Calibration Parameters for later projection
-    const float &fx = pKF->fx;
-    const float &fy = pKF->fy;
-    const float &cx = pKF->cx;
-    const float &cy = pKF->cy;
-
-    // Decompose Scw
-    cv::Mat sRcw = Scw.rowRange(0,3).colRange(0,3);
-    const float scw = sqrt(sRcw.row(0).dot(sRcw.row(0)));
-    cv::Mat Rcw = sRcw/scw;
-    cv::Mat tcw = Scw.rowRange(0,3).col(3)/scw;
-    cv::Mat Ow = -Rcw.t()*tcw;
-
-    // Set of MapPoints already found in the KeyFrame
-    set<MapPoint*> spAlreadyFound(vpMatched.begin(), vpMatched.end());
-    spAlreadyFound.erase(static_cast<MapPoint*>(NULL));
-
-    int nmatches=0;
-
-    // For each Candidate MapPoint Project and Match
-    for(int iMP=0, iendMP=vpPoints.size(); iMP<iendMP; iMP++)
+    int ORBmatcher::SearchByProjection(KeyFrame *pKF, cv::Mat Scw, const vector<MapPoint *> &vpPoints, vector<MapPoint *> &vpMatched, int th)
     {
-        MapPoint* pMP = vpPoints[iMP];
+        // Get Calibration Parameters for later projection
+        const float &fx = pKF->fx;
+        const float &fy = pKF->fy;
+        const float &cx = pKF->cx;
+        const float &cy = pKF->cy;
+
+        // Decompose Scw
+        cv::Mat sRcw = Scw.rowRange(0, 3).colRange(0, 3);
+        const float scw = sqrt(sRcw.row(0).dot(sRcw.row(0)));
+        cv::Mat Rcw = sRcw / scw;
+        cv::Mat tcw = Scw.rowRange(0, 3).col(3) / scw;
+        cv::Mat Ow = -Rcw.t() * tcw;
+
+        // Set of MapPoints already found in the KeyFrame
+        set<MapPoint *> spAlreadyFound(vpMatched.begin(), vpMatched.end());
+        spAlreadyFound.erase(static_cast<MapPoint *>(NULL));
+
+        int nmatches = 0;
+
+        // For each Candidate MapPoint Project and Match
+        for (int iMP = 0, iendMP = vpPoints.size(); iMP < iendMP; iMP++)
+        {
+            MapPoint *pMP = vpPoints[iMP];
 
-        // Discard Bad MapPoints and already found
-        if(pMP->isBad() || spAlreadyFound.count(pMP))
-            continue;
+            // Discard Bad MapPoints and already found
+            if (pMP->isBad() || spAlreadyFound.count(pMP))
+                continue;
 
-        // Get 3D Coords.
-        cv::Mat p3Dw = pMP->GetWorldPos();
+            // Get 3D Coords.
+            cv::Mat p3Dw = pMP->GetWorldPos();
 
-        // Transform into Camera Coords.
-        cv::Mat p3Dc = Rcw*p3Dw+tcw;
+            // Transform into Camera Coords.
+            cv::Mat p3Dc = Rcw * p3Dw + tcw;
 
-        // Depth must be positive
-        if(p3Dc.at<float>(2)<0.0)
-            continue;
+            // Depth must be positive
+            if (p3Dc.at<float>(2) < 0.0)
+                continue;
 
-        // Project into Image
-        const float invz = 1/p3Dc.at<float>(2);
-        const float x = p3Dc.at<float>(0)*invz;
-        const float y = p3Dc.at<float>(1)*invz;
+            // Project into Image
+            const float invz = 1 / p3Dc.at<float>(2);
+            const float x = p3Dc.at<float>(0) * invz;
+            const float y = p3Dc.at<float>(1) * invz;
 
-        const float u = fx*x+cx;
-        const float v = fy*y+cy;
+            const float u = fx * x + cx;
+            const float v = fy * y + cy;
 
-        // Point must be inside the image
-        if(!pKF->IsInImage(u,v))
-            continue;
+            // Point must be inside the image
+            if (!pKF->IsInImage(u, v))
+                continue;
 
-        // Depth must be inside the scale invariance region of the point
-        const float maxDistance = pMP->GetMaxDistanceInvariance();
-        const float minDistance = pMP->GetMinDistanceInvariance();
-        cv::Mat PO = p3Dw-Ow;
-        const float dist = cv::norm(PO);
+            // Depth must be inside the scale invariance region of the point
+            const float maxDistance = pMP->GetMaxDistanceInvariance();
+            const float minDistance = pMP->GetMinDistanceInvariance();
+            cv::Mat PO = p3Dw - Ow;
+            const float dist = cv::norm(PO);
 
-        if(dist<minDistance || dist>maxDistance)
-            continue;
+            if (dist < minDistance || dist > maxDistance)
+                continue;
 
-        // Viewing angle must be less than 60 deg
-        cv::Mat Pn = pMP->GetNormal();
+            // Viewing angle must be less than 60 deg
+            cv::Mat Pn = pMP->GetNormal();
 
-        if(PO.dot(Pn)<0.5*dist)
-            continue;
+            if (PO.dot(Pn) < 0.5 * dist)
+                continue;
 
-        int nPredictedLevel = pMP->PredictScale(dist,pKF->mfLogScaleFactor);
+            int nPredictedLevel = pMP->PredictScale(dist, pKF->mfLogScaleFactor);
 
-        // Search in a radius
-        const float radius = th*pKF->mvScaleFactors[nPredictedLevel];
+            // Search in a radius
+            const float radius = th * pKF->mvScaleFactors[nPredictedLevel];
 
-        const vector<size_t> vIndices = pKF->GetFeaturesInArea(u,v,radius);
+            const vector<size_t> vIndices = pKF->GetFeaturesInArea(u, v, radius);
 
-        if(vIndices.empty())
-            continue;
+            if (vIndices.empty())
+                continue;
 
-        // Match to the most similar keypoint in the radius
-        const cv::Mat dMP = pMP->GetDescriptor();
+            // Match to the most similar keypoint in the radius
+            const cv::Mat dMP = pMP->GetDescriptor();
 
-        int bestDist = 256;
-        int bestIdx = -1;
-        for(vector<size_t>::const_iterator vit=vIndices.begin(), vend=vIndices.end(); vit!=vend; vit++)
-        {
-            const size_t idx = *vit;
-            if(vpMatched[idx])
-                continue;
+            int bestDist = 256;
+            int bestIdx = -1;
+            for (vector<size_t>::const_iterator vit = vIndices.begin(), vend = vIndices.end(); vit != vend; vit++)
+            {
+                const size_t idx = *vit;
+                if (vpMatched[idx])
+                    continue;
 
-            const int &kpLevel= pKF->mvKeysUn[idx].octave;
+                const int &kpLevel = pKF->mvKeysUn[idx].octave;
 
-            if(kpLevel<nPredictedLevel-1 || kpLevel>nPredictedLevel)
-                continue;
+                if (kpLevel < nPredictedLevel - 1 || kpLevel > nPredictedLevel)
+                    continue;
 
-            const cv::Mat &dKF = pKF->mDescriptors.row(idx);
+                const cv::Mat &dKF = pKF->mDescriptors.row(idx);
 
-            const int dist = DescriptorDistance(dMP,dKF);
+                const int dist = DescriptorDistance(dMP, dKF);
 
-            if(dist<bestDist)
-            {
-                bestDist = dist;
-                bestIdx = idx;
+                if (dist < bestDist)
+                {
+                    bestDist = dist;
+                    bestIdx = idx;
+                }
             }
-        }
 
-        if(bestDist<=TH_LOW)
-        {
-            vpMatched[bestIdx]=pMP;
-            nmatches++;
+            if (bestDist <= TH_LOW)
+            {
+                vpMatched[bestIdx] = pMP;
+                nmatches++;
+            }
         }
 
+        return nmatches;
     }
 
-    return nmatches;
-}
-
-int ORBmatcher::SearchForInitialization(Frame &F1, Frame &F2, vector<cv::Point2f> &vbPrevMatched, vector<int> &vnMatches12, int windowSize)
-{
-    int nmatches=0;
-    vnMatches12 = vector<int>(F1.mvKeysUn.size(),-1);
+    int ORBmatcher::SearchForInitialization(Frame &F1, Frame &F2, vector<cv::Point2f> &vbPrevMatched, vector<int> &vnMatches12, int windowSize)
+    {
+        int nmatches = 0;
+        vnMatches12 = vector<int>(F1.mvKeysUn.size(), -1);
 
-    vector<int> rotHist[HISTO_LENGTH];
-    for(int i=0;i<HISTO_LENGTH;i++)
-        rotHist[i].reserve(500);
-    const float factor = 1.0f/HISTO_LENGTH;
+        vector<int> rotHist[HISTO_LENGTH];
+        for (int i = 0; i < HISTO_LENGTH; i++)
+            rotHist[i].reserve(500);
+        const float factor = 1.0f / HISTO_LENGTH;
 
-    vector<int> vMatchedDistance(F2.mvKeysUn.size(),INT_MAX);
-    vector<int> vnMatches21(F2.mvKeysUn.size(),-1);
+        vector<int> vMatchedDistance(F2.mvKeysUn.size(), INT_MAX);
+        vector<int> vnMatches21(F2.mvKeysUn.size(), -1);
 
-    for(size_t i1=0, iend1=F1.mvKeysUn.size(); i1<iend1; i1++)
-    {
-        cv::KeyPoint kp1 = F1.mvKeysUn[i1];
-        int level1 = kp1.octave;
-        if(level1>0)
-            continue;
+        for (size_t i1 = 0, iend1 = F1.mvKeysUn.size(); i1 < iend1; i1++)
+        {
+            cv::KeyPoint kp1 = F1.mvKeysUn[i1];
+            int level1 = kp1.octave;
+            if (level1 > 0)
+                continue;
 
-        vector<size_t> vIndices2 = F2.GetFeaturesInArea(vbPrevMatched[i1].x,vbPrevMatched[i1].y, windowSize,level1,level1);
+            vector<size_t> vIndices2 = F2.GetFeaturesInArea(vbPrevMatched[i1].x, vbPrevMatched[i1].y, windowSize, level1, level1);
 
-        if(vIndices2.empty())
-            continue;
+            if (vIndices2.empty())
+                continue;
 
-        cv::Mat d1 = F1.mDescriptors.row(i1);
+            cv::Mat d1 = F1.mDescriptors.row(i1);
 
-        int bestDist = INT_MAX;
-        int bestDist2 = INT_MAX;
-        int bestIdx2 = -1;
+            int bestDist = INT_MAX;
+            int bestDist2 = INT_MAX;
+            int bestIdx2 = -1;
 
-        for(vector<size_t>::iterator vit=vIndices2.begin(); vit!=vIndices2.end(); vit++)
-        {
-            size_t i2 = *vit;
+            for (vector<size_t>::iterator vit = vIndices2.begin(); vit != vIndices2.end(); vit++)
+            {
+                size_t i2 = *vit;
 
-            cv::Mat d2 = F2.mDescriptors.row(i2);
+                cv::Mat d2 = F2.mDescriptors.row(i2);
 
-            int dist = DescriptorDistance(d1,d2);
+                int dist = DescriptorDistance(d1, d2);
 
-            if(vMatchedDistance[i2]<=dist)
-                continue;
+                if (vMatchedDistance[i2] <= dist)
+                    continue;
 
-            if(dist<bestDist)
-            {
-                bestDist2=bestDist;
-                bestDist=dist;
-                bestIdx2=i2;
-            }
-            else if(dist<bestDist2)
-            {
-                bestDist2=dist;
+                if (dist < bestDist)
+                {
+                    bestDist2 = bestDist;
+                    bestDist = dist;
+                    bestIdx2 = i2;
+                }
+                else if (dist < bestDist2)
+                {
+                    bestDist2 = dist;
+                }
             }
-        }
-
-        if(bestDist<=TH_LOW)
-        {
-            if(bestDist<(float)bestDist2*mfNNratio)
+            if (bestDist <= TH_LOW)
             {
-                if(vnMatches21[bestIdx2]>=0)
+                if (bestDist < (float)bestDist2 * mfNNratio)
                 {
-                    vnMatches12[vnMatches21[bestIdx2]]=-1;
-                    nmatches--;
-                }
-                vnMatches12[i1]=bestIdx2;
-                vnMatches21[bestIdx2]=i1;
-                vMatchedDistance[bestIdx2]=bestDist;
-                nmatches++;
+                    if (vnMatches21[bestIdx2] >= 0)
+                    {
+                        vnMatches12[vnMatches21[bestIdx2]] = -1;
+                        nmatches--;
+                    }
+                    vnMatches12[i1] = bestIdx2;
+                    vnMatches21[bestIdx2] = i1;
+                    vMatchedDistance[bestIdx2] = bestDist;
+                    nmatches++;
 
-                if(mbCheckOrientation)
-                {
-                    float rot = F1.mvKeysUn[i1].angle-F2.mvKeysUn[bestIdx2].angle;
-                    if(rot<0.0)
-                        rot+=360.0f;
-                    int bin = round(rot*factor);
-                    if(bin==HISTO_LENGTH)
-                        bin=0;
-                    assert(bin>=0 && bin<HISTO_LENGTH);
-                    rotHist[bin].push_back(i1);
+                    if (mbCheckOrientation)
+                    {
+                        float rot = F1.mvKeysUn[i1].angle - F2.mvKeysUn[bestIdx2].angle;
+                        if (rot < 0.0)
+                            rot += 360.0f;
+                        int bin = round(rot * factor);
+                        if (bin == HISTO_LENGTH)
+                            bin = 0;
+                        assert(bin >= 0 && bin < HISTO_LENGTH);
+                        rotHist[bin].push_back(i1);
+                    }
                 }
             }
         }
 
-    }
-
-    if(mbCheckOrientation)
-    {
-        int ind1=-1;
-        int ind2=-1;
-        int ind3=-1;
+        if (mbCheckOrientation)
+        {
+            int ind1 = -1;
+            int ind2 = -1;
+            int ind3 = -1;
 
-        ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3);
+            ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);
 
-        for(int i=0; i<HISTO_LENGTH; i++)
-        {
-            if(i==ind1 || i==ind2 || i==ind3)
-                continue;
-            for(size_t j=0, jend=rotHist[i].size(); j<jend; j++)
+            for (int i = 0; i < HISTO_LENGTH; i++)
             {
-                int idx1 = rotHist[i][j];
-                if(vnMatches12[idx1]>=0)
+                if (i == ind1 || i == ind2 || i == ind3)
+                    continue;
+                for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
                 {
-                    vnMatches12[idx1]=-1;
-                    nmatches--;
+                    int idx1 = rotHist[i][j];
+                    if (vnMatches12[idx1] >= 0)
+                    {
+                        vnMatches12[idx1] = -1;
+                        nmatches--;
+                    }
                 }
             }
         }
 
-    }
-
-    //Update prev matched
-    for(size_t i1=0, iend1=vnMatches12.size(); i1<iend1; i1++)
-        if(vnMatches12[i1]>=0)
-            vbPrevMatched[i1]=F2.mvKeysUn[vnMatches12[i1]].pt;
+        // Update prev matched
+        for (size_t i1 = 0, iend1 = vnMatches12.size(); i1 < iend1; i1++)
+            if (vnMatches12[i1] >= 0)
+                vbPrevMatched[i1] = F2.mvKeysUn[vnMatches12[i1]].pt;
 
-    return nmatches;
-}
+        return nmatches;
+    }
 
-int ORBmatcher::SearchByBoW(KeyFrame *pKF1, KeyFrame *pKF2, vector<MapPoint *> &vpMatches12)
-{
-    const vector<cv::KeyPoint> &vKeysUn1 = pKF1->mvKeysUn;
-    const DBoW2::FeatureVector &vFeatVec1 = pKF1->mFeatVec;
-    const vector<MapPoint*> vpMapPoints1 = pKF1->GetMapPointMatches();
-    const cv::Mat &Descriptors1 = pKF1->mDescriptors;
+    int ORBmatcher::SearchByBoW(KeyFrame *pKF1, KeyFrame *pKF2, vector<MapPoint *> &vpMatches12)
+    {
+        const vector<cv::KeyPoint> &vKeysUn1 = pKF1->mvKeysUn;
+        const DBoW2::FeatureVector &vFeatVec1 = pKF1->mFeatVec;
+        const vector<MapPoint *> vpMapPoints1 = pKF1->GetMapPointMatches();
+        const cv::Mat &Descriptors1 = pKF1->mDescriptors;
 
-    const vector<cv::KeyPoint> &vKeysUn2 = pKF2->mvKeysUn;
-    const DBoW2::FeatureVector &vFeatVec2 = pKF2->mFeatVec;
-    const vector<MapPoint*> vpMapPoints2 = pKF2->GetMapPointMatches();
-    const cv::Mat &Descriptors2 = pKF2->mDescriptors;
+        const vector<cv::KeyPoint> &vKeysUn2 = pKF2->mvKeysUn;
+        const DBoW2::FeatureVector &vFeatVec2 = pKF2->mFeatVec;
+        const vector<MapPoint *> vpMapPoints2 = pKF2->GetMapPointMatches();
+        const cv::Mat &Descriptors2 = pKF2->mDescriptors;
 
-    vpMatches12 = vector<MapPoint*>(vpMapPoints1.size(),static_cast<MapPoint*>(NULL));
-    vector<bool> vbMatched2(vpMapPoints2.size(),false);
+        vpMatches12 = vector<MapPoint *>(vpMapPoints1.size(), static_cast<MapPoint *>(NULL));
+        vector<bool> vbMatched2(vpMapPoints2.size(), false);
 
-    vector<int> rotHist[HISTO_LENGTH];
-    for(int i=0;i<HISTO_LENGTH;i++)
-        rotHist[i].reserve(500);
+        vector<int> rotHist[HISTO_LENGTH];
+        for (int i = 0; i < HISTO_LENGTH; i++)
+            rotHist[i].reserve(500);
 
-    const float factor = 1.0f/HISTO_LENGTH;
+        const float factor = 1.0f / HISTO_LENGTH;
 
-    int nmatches = 0;
+        int nmatches = 0;
 
-    DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin();
-    DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin();
-    DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end();
-    DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end();
+        DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin();
+        DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin();
+        DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end();
+        DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end();
 
-    while(f1it != f1end && f2it != f2end)
-    {
-        if(f1it->first == f2it->first)
+        while (f1it != f1end && f2it != f2end)
         {
-            for(size_t i1=0, iend1=f1it->second.size(); i1<iend1; i1++)
+            if (f1it->first == f2it->first)
             {
-                const size_t idx1 = f1it->second[i1];
+                for (size_t i1 = 0, iend1 = f1it->second.size(); i1 < iend1; i1++)
+                {
+                    const size_t idx1 = f1it->second[i1];
 
-                MapPoint* pMP1 = vpMapPoints1[idx1];
-                if(!pMP1)
-                    continue;
-                if(pMP1->isBad())
-                    continue;
+                    MapPoint *pMP1 = vpMapPoints1[idx1];
+                    if (!pMP1)
+                        continue;
+                    if (pMP1->isBad())
+                        continue;
 
-                const cv::Mat &d1 = Descriptors1.row(idx1);
+                    const cv::Mat &d1 = Descriptors1.row(idx1);
 
-                int bestDist1=256;
-                int bestIdx2 =-1 ;
-                int bestDist2=256;
+                    int bestDist1 = 256;
+                    int bestIdx2 = -1;
+                    int bestDist2 = 256;
 
-                for(size_t i2=0, iend2=f2it->second.size(); i2<iend2; i2++)
-                {
-                    const size_t idx2 = f2it->second[i2];
+                    for (size_t i2 = 0, iend2 = f2it->second.size(); i2 < iend2; i2++)
+                    {
+                        const size_t idx2 = f2it->second[i2];
 
-                    MapPoint* pMP2 = vpMapPoints2[idx2];
+                        MapPoint *pMP2 = vpMapPoints2[idx2];
 
-                    if(vbMatched2[idx2] || !pMP2)
-                        continue;
+                        if (vbMatched2[idx2] || !pMP2)
+                            continue;
 
-                    if(pMP2->isBad())
-                        continue;
+                        if (pMP2->isBad())
+                            continue;
 
-                    const cv::Mat &d2 = Descriptors2.row(idx2);
+                        const cv::Mat &d2 = Descriptors2.row(idx2);
 
-                    int dist = DescriptorDistance(d1,d2);
+                        int dist = DescriptorDistance(d1, d2);
 
-                    if(dist<bestDist1)
-                    {
-                        bestDist2=bestDist1;
-                        bestDist1=dist;
-                        bestIdx2=idx2;
-                    }
-                    else if(dist<bestDist2)
-                    {
-                        bestDist2=dist;
+                        if (dist < bestDist1)
+                        {
+                            bestDist2 = bestDist1;
+                            bestDist1 = dist;
+                            bestIdx2 = idx2;
+                        }
+                        else if (dist < bestDist2)
+                        {
+                            bestDist2 = dist;
+                        }
                     }
-                }
 
-                if(bestDist1<TH_LOW)
-                {
-                    if(static_cast<float>(bestDist1)<mfNNratio*static_cast<float>(bestDist2))
+                    if (bestDist1 < TH_LOW)
                     {
-                        vpMatches12[idx1]=vpMapPoints2[bestIdx2];
-                        vbMatched2[bestIdx2]=true;
-
-                        if(mbCheckOrientation)
+                        if (static_cast<float>(bestDist1) < mfNNratio * static_cast<float>(bestDist2))
                         {
-                            float rot = vKeysUn1[idx1].angle-vKeysUn2[bestIdx2].angle;
-                            if(rot<0.0)
-                                rot+=360.0f;
-                            int bin = round(rot*factor);
-                            if(bin==HISTO_LENGTH)
-                                bin=0;
-                            assert(bin>=0 && bin<HISTO_LENGTH);
-                            rotHist[bin].push_back(idx1);
+                            vpMatches12[idx1] = vpMapPoints2[bestIdx2];
+                            vbMatched2[bestIdx2] = true;
+
+                            if (mbCheckOrientation)
+                            {
+                                float rot = vKeysUn1[idx1].angle - vKeysUn2[bestIdx2].angle;
+                                if (rot < 0.0)
+                                    rot += 360.0f;
+                                int bin = round(rot * factor);
+                                if (bin == HISTO_LENGTH)
+                                    bin = 0;
+                                assert(bin >= 0 && bin < HISTO_LENGTH);
+                                rotHist[bin].push_back(idx1);
+                            }
+                            nmatches++;
                         }
-                        nmatches++;
                     }
                 }
-            }
 
-            f1it++;
-            f2it++;
-        }
-        else if(f1it->first < f2it->first)
-        {
-            f1it = vFeatVec1.lower_bound(f2it->first);
-        }
-        else
-        {
-            f2it = vFeatVec2.lower_bound(f1it->first);
+                f1it++;
+                f2it++;
+            }
+            else if (f1it->first < f2it->first)
+            {
+                f1it = vFeatVec1.lower_bound(f2it->first);
+            }
+            else
+            {
+                f2it = vFeatVec2.lower_bound(f1it->first);
+            }
         }
-    }
 
-    if(mbCheckOrientation)
-    {
-        int ind1=-1;
-        int ind2=-1;
-        int ind3=-1;
+        if (mbCheckOrientation)
+        {
+            int ind1 = -1;
+            int ind2 = -1;
+            int ind3 = -1;
 
-        ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3);
+            ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);
 
-        for(int i=0; i<HISTO_LENGTH; i++)
-        {
-            if(i==ind1 || i==ind2 || i==ind3)
-                continue;
-            for(size_t j=0, jend=rotHist[i].size(); j<jend; j++)
+            for (int i = 0; i < HISTO_LENGTH; i++)
             {
-                vpMatches12[rotHist[i][j]]=static_cast<MapPoint*>(NULL);
-                nmatches--;
+                if (i == ind1 || i == ind2 || i == ind3)
+                    continue;
+                for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
+                {
+                    vpMatches12[rotHist[i][j]] = static_cast<MapPoint *>(NULL);
+                    nmatches--;
+                }
             }
         }
+
+        return nmatches;
     }
 
-    return nmatches;
-}
+    int ORBmatcher::SearchForTriangulation(KeyFrame *pKF1, KeyFrame *pKF2, cv::Mat F12,
+                                           vector<pair<size_t, size_t>> &vMatchedPairs, const bool bOnlyStereo)
+    {
+        const DBoW2::FeatureVector &vFeatVec1 = pKF1->mFeatVec;
+        const DBoW2::FeatureVector &vFeatVec2 = pKF2->mFeatVec;
+
+        // Compute epipole in second image
+        cv::Mat Cw = pKF1->GetCameraCenter();
+        cv::Mat R2w = pKF2->GetRotation();
+        cv::Mat t2w = pKF2->GetTranslation();
+        cv::Mat C2 = R2w * Cw + t2w;
+        const float invz = 1.0f / C2.at<float>(2);
+        const float ex = pKF2->fx * C2.at<float>(0) * invz + pKF2->cx;
+        const float ey = pKF2->fy * C2.at<float>(1) * invz + pKF2->cy;
+
+        // Find matches between not tracked keypoints
+        // Matching speed-up by ORB Vocabulary
+        // Compare only ORB that share the same node
+
+        int nmatches = 0;
+        vector<bool> vbMatched2(pKF2->N, false);
+        vector<int> vMatches12(pKF1->N, -1);
+
+        vector<int> rotHist[HISTO_LENGTH];
+        for (int i = 0; i < HISTO_LENGTH; i++)
+            rotHist[i].reserve(500);
+
+        const float factor = 1.0f / HISTO_LENGTH;
+
+        DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin();
+        DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin();
+        DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end();
+        DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end();
+
+        while (f1it != f1end && f2it != f2end)
+        {
+            if (f1it->first == f2it->first)
+            {
+                for (size_t i1 = 0, iend1 = f1it->second.size(); i1 < iend1; i1++)
+                {
+                    const size_t idx1 = f1it->second[i1];
 
-int ORBmatcher::SearchForTriangulation(KeyFrame *pKF1, KeyFrame *pKF2, cv::Mat F12,
-                                       vector<pair<size_t, size_t> > &vMatchedPairs, const bool bOnlyStereo)
-{    
-    const DBoW2::FeatureVector &vFeatVec1 = pKF1->mFeatVec;
-    const DBoW2::FeatureVector &vFeatVec2 = pKF2->mFeatVec;
+                    MapPoint *pMP1 = pKF1->GetMapPoint(idx1);
 
-    //Compute epipole in second image
-    cv::Mat Cw = pKF1->GetCameraCenter();
-    cv::Mat R2w = pKF2->GetRotation();
-    cv::Mat t2w = pKF2->GetTranslation();
-    cv::Mat C2 = R2w*Cw+t2w;
-    const float invz = 1.0f/C2.at<float>(2);
-    const float ex =pKF2->fx*C2.at<float>(0)*invz+pKF2->cx;
-    const float ey =pKF2->fy*C2.at<float>(1)*invz+pKF2->cy;
+                    // If there is already a MapPoint skip
+                    if (pMP1)
+                        continue;
 
-    // Find matches between not tracked keypoints
-    // Matching speed-up by ORB Vocabulary
-    // Compare only ORB that share the same node
+                    const bool bStereo1 = pKF1->mvuRight[idx1] >= 0;
 
-    int nmatches=0;
-    vector<bool> vbMatched2(pKF2->N,false);
-    vector<int> vMatches12(pKF1->N,-1);
+                    if (bOnlyStereo)
+                        if (!bStereo1)
+                            continue;
 
-    vector<int> rotHist[HISTO_LENGTH];
-    for(int i=0;i<HISTO_LENGTH;i++)
-        rotHist[i].reserve(500);
+                    const cv::KeyPoint &kp1 = pKF1->mvKeysUn[idx1];
 
-    const float factor = 1.0f/HISTO_LENGTH;
+                    const cv::Mat &d1 = pKF1->mDescriptors.row(idx1);
 
-    DBoW2::FeatureVector::const_iterator f1it = vFeatVec1.begin();
-    DBoW2::FeatureVector::const_iterator f2it = vFeatVec2.begin();
-    DBoW2::FeatureVector::const_iterator f1end = vFeatVec1.end();
-    DBoW2::FeatureVector::const_iterator f2end = vFeatVec2.end();
+                    int bestDist = TH_LOW;
+                    int bestIdx2 = -1;
 
-    while(f1it!=f1end && f2it!=f2end)
-    {
-        if(f1it->first == f2it->first)
-        {
-            for(size_t i1=0, iend1=f1it->second.size(); i1<iend1; i1++)
-            {
-                const size_t idx1 = f1it->second[i1];
-                
-                MapPoint* pMP1 = pKF1->GetMapPoint(idx1);
-                
-                // If there is already a MapPoint skip
-                if(pMP1)
-                    continue;
+                    for (size_t i2 = 0, iend2 = f2it->second.size(); i2 < iend2; i2++)
+                    {
+                        size_t idx2 = f2it->second[i2];
 
-                const bool bStereo1 = pKF1->mvuRight[idx1]>=0;
+                        MapPoint *pMP2 = pKF2->GetMapPoint(idx2);
 
-                if(bOnlyStereo)
-                    if(!bStereo1)
-                        continue;
-                
-                const cv::KeyPoint &kp1 = pKF1->mvKeysUn[idx1];
-                
-                const cv::Mat &d1 = pKF1->mDescriptors.row(idx1);
-                
-                int bestDist = TH_LOW;
-                int bestIdx2 = -1;
-                
-                for(size_t i2=0, iend2=f2it->second.size(); i2<iend2; i2++)
-                {
-                    size_t idx2 = f2it->second[i2];
-                    
-                    MapPoint* pMP2 = pKF2->GetMapPoint(idx2);
-                    
-                    // If we have already matched or there is a MapPoint skip
-                    if(vbMatched2[idx2] || pMP2)
-                        continue;
+                        // If we have already matched or there is a MapPoint skip
+                        if (vbMatched2[idx2] || pMP2)
+                            continue;
 
-                    const bool bStereo2 = pKF2->mvuRight[idx2]>=0;
+                        const bool bStereo2 = pKF2->mvuRight[idx2] >= 0;
 
-                    if(bOnlyStereo)
-                        if(!bStereo2)
-                            continue;
-                    
-                    const cv::Mat &d2 = pKF2->mDescriptors.row(idx2);
-                    
-                    const int dist = DescriptorDistance(d1,d2);
-                    
-                    if(dist>TH_LOW || dist>bestDist)
-                        continue;
+                        if (bOnlyStereo)
+                            if (!bStereo2)
+                                continue;
 
-                    const cv::KeyPoint &kp2 = pKF2->mvKeysUn[idx2];
+                        const cv::Mat &d2 = pKF2->mDescriptors.row(idx2);
 
-                    if(!bStereo1 && !bStereo2)
-                    {
-                        const float distex = ex-kp2.pt.x;
-                        const float distey = ey-kp2.pt.y;
-                        if(distex*distex+distey*distey<100*pKF2->mvScaleFactors[kp2.octave])
+                        const int dist = DescriptorDistance(d1, d2);
+
+                        if (dist > TH_LOW || dist > bestDist)
                             continue;
-                    }
 
-                    if(CheckDistEpipolarLine(kp1,kp2,F12,pKF2))
-                    {
-                        bestIdx2 = idx2;
-                        bestDist = dist;
+                        const cv::KeyPoint &kp2 = pKF2->mvKeysUn[idx2];
+
+                        if (!bStereo1 && !bStereo2)
+                        {
+                            const float distex = ex - kp2.pt.x;
+                            const float distey = ey - kp2.pt.y;
+                            if (distex * distex + distey * distey < 100 * pKF2->mvScaleFactors[kp2.octave])
+                                continue;
+                        }
+
+                        if (CheckDistEpipolarLine(kp1, kp2, F12, pKF2))
+                        {
+                            bestIdx2 = idx2;
+                            bestDist = dist;
+                        }
                     }
-                }
-                
-                if(bestIdx2>=0)
-                {
-                    const cv::KeyPoint &kp2 = pKF2->mvKeysUn[bestIdx2];
-                    vMatches12[idx1]=bestIdx2;
-                    nmatches++;
 
-                    if(mbCheckOrientation)
+                    if (bestIdx2 >= 0)
                     {
-                        float rot = kp1.angle-kp2.angle;
-                        if(rot<0.0)
-                            rot+=360.0f;
-                        int bin = round(rot*factor);
-                        if(bin==HISTO_LENGTH)
-                            bin=0;
-                        assert(bin>=0 && bin<HISTO_LENGTH);
-                        rotHist[bin].push_back(idx1);
+                        const cv::KeyPoint &kp2 = pKF2->mvKeysUn[bestIdx2];
+                        vMatches12[idx1] = bestIdx2;
+                        nmatches++;
+
+                        if (mbCheckOrientation)
+                        {
+                            float rot = kp1.angle - kp2.angle;
+                            if (rot < 0.0)
+                                rot += 360.0f;
+                            int bin = round(rot * factor);
+                            if (bin == HISTO_LENGTH)
+                                bin = 0;
+                            assert(bin >= 0 && bin < HISTO_LENGTH);
+                            rotHist[bin].push_back(idx1);
+                        }
                     }
                 }
-            }
 
-            f1it++;
-            f2it++;
-        }
-        else if(f1it->first < f2it->first)
-        {
-            f1it = vFeatVec1.lower_bound(f2it->first);
-        }
-        else
-        {
-            f2it = vFeatVec2.lower_bound(f1it->first);
+                f1it++;
+                f2it++;
+            }
+            else if (f1it->first < f2it->first)
+            {
+                f1it = vFeatVec1.lower_bound(f2it->first);
+            }
+            else
+            {
+                f2it = vFeatVec2.lower_bound(f1it->first);
+            }
         }
-    }
 
-    if(mbCheckOrientation)
-    {
-        int ind1=-1;
-        int ind2=-1;
-        int ind3=-1;
+        if (mbCheckOrientation)
+        {
+            int ind1 = -1;
+            int ind2 = -1;
+            int ind3 = -1;
 
-        ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3);
+            ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);
 
-        for(int i=0; i<HISTO_LENGTH; i++)
-        {
-            if(i==ind1 || i==ind2 || i==ind3)
-                continue;
-            for(size_t j=0, jend=rotHist[i].size(); j<jend; j++)
+            for (int i = 0; i < HISTO_LENGTH; i++)
             {
-                vMatches12[rotHist[i][j]]=-1;
-                nmatches--;
+                if (i == ind1 || i == ind2 || i == ind3)
+                    continue;
+                for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
+                {
+                    vMatches12[rotHist[i][j]] = -1;
+                    nmatches--;
+                }
             }
         }
 
-    }
+        vMatchedPairs.clear();
+        vMatchedPairs.reserve(nmatches);
 
-    vMatchedPairs.clear();
-    vMatchedPairs.reserve(nmatches);
+        for (size_t i = 0, iend = vMatches12.size(); i < iend; i++)
+        {
+            if (vMatches12[i] < 0)
+                continue;
+            vMatchedPairs.push_back(make_pair(i, vMatches12[i]));
+        }
 
-    for(size_t i=0, iend=vMatches12.size(); i<iend; i++)
-    {
-        if(vMatches12[i]<0)
-            continue;
-        vMatchedPairs.push_back(make_pair(i,vMatches12[i]));
+        return nmatches;
     }
 
-    return nmatches;
-}
-
-int ORBmatcher::Fuse(KeyFrame *pKF, const vector<MapPoint *> &vpMapPoints, const float th)
-{
-    cv::Mat Rcw = pKF->GetRotation();
-    cv::Mat tcw = pKF->GetTranslation();
-
-    const float &fx = pKF->fx;
-    const float &fy = pKF->fy;
-    const float &cx = pKF->cx;
-    const float &cy = pKF->cy;
-    const float &bf = pKF->mbf;
+    int ORBmatcher::Fuse(KeyFrame *pKF, const vector<MapPoint *> &vpMapPoints, const float th)
+    {
+        cv::Mat Rcw = pKF->GetRotation();
+        cv::Mat tcw = pKF->GetTranslation();
 
-    cv::Mat Ow = pKF->GetCameraCenter();
+        const float &fx = pKF->fx;
+        const float &fy = pKF->fy;
+        const float &cx = pKF->cx;
+        const float &cy = pKF->cy;
+        const float &bf = pKF->mbf;
 
-    int nFused=0;
+        cv::Mat Ow = pKF->GetCameraCenter();
 
-    const int nMPs = vpMapPoints.size();
+        int nFused = 0;
 
-    for(int i=0; i<nMPs; i++)
-    {
-        MapPoint* pMP = vpMapPoints[i];
+        const int nMPs = vpMapPoints.size();
 
-        if(!pMP)
-            continue;
+        for (int i = 0; i < nMPs; i++)
+        {
+            MapPoint *pMP = vpMapPoints[i];
 
-        if(pMP->isBad() || pMP->IsInKeyFrame(pKF))
-            continue;
+            if (!pMP)
+                continue;
 
-        cv::Mat p3Dw = pMP->GetWorldPos();
-        cv::Mat p3Dc = Rcw*p3Dw + tcw;
+            if (pMP->isBad() || pMP->IsInKeyFrame(pKF))
+                continue;
 
-        // Depth must be positive
-        if(p3Dc.at<float>(2)<0.0f)
-            continue;
+            cv::Mat p3Dw = pMP->GetWorldPos();
+            cv::Mat p3Dc = Rcw * p3Dw + tcw;
 
-        const float invz = 1/p3Dc.at<float>(2);
-        const float x = p3Dc.at<float>(0)*invz;
-        const float y = p3Dc.at<float>(1)*invz;
+            // Depth must be positive
+            if (p3Dc.at<float>(2) < 0.0f)
+                continue;
 
-        const float u = fx*x+cx;
-        const float v = fy*y+cy;
+            const float invz = 1 / p3Dc.at<float>(2);
+            const float x = p3Dc.at<float>(0) * invz;
+            const float y = p3Dc.at<float>(1) * invz;
 
-        // Point must be inside the image
-        if(!pKF->IsInImage(u,v))
-            continue;
+            const float u = fx * x + cx;
+            const float v = fy * y + cy;
 
-        const float ur = u-bf*invz;
+            // Point must be inside the image
+            if (!pKF->IsInImage(u, v))
+                continue;
 
-        const float maxDistance = pMP->GetMaxDistanceInvariance();
-        const float minDistance = pMP->GetMinDistanceInvariance();
-        cv::Mat PO = p3Dw-Ow;
-        const float dist3D = cv::norm(PO);
+            const float ur = u - bf * invz;
 
-        // Depth must be inside the scale pyramid of the image
-        if(dist3D<minDistance || dist3D>maxDistance )
-            continue;
+            const float maxDistance = pMP->GetMaxDistanceInvariance();
+            const float minDistance = pMP->GetMinDistanceInvariance();
+            cv::Mat PO = p3Dw - Ow;
+            const float dist3D = cv::norm(PO);
 
-        // Viewing angle must be less than 60 deg
-        cv::Mat Pn = pMP->GetNormal();
+            // Depth must be inside the scale pyramid of the image
+            if (dist3D < minDistance || dist3D > maxDistance)
+                continue;
 
-        if(PO.dot(Pn)<0.5*dist3D)
-            continue;
+            // Viewing angle must be less than 60 deg
+            cv::Mat Pn = pMP->GetNormal();
 
-        int nPredictedLevel = pMP->PredictScale(dist3D,pKF->mfLogScaleFactor);
+            if (PO.dot(Pn) < 0.5 * dist3D)
+                continue;
 
-        // Search in a radius
-        const float radius = th*pKF->mvScaleFactors[nPredictedLevel];
+            int nPredictedLevel = pMP->PredictScale(dist3D, pKF->mfLogScaleFactor);
 
-        const vector<size_t> vIndices = pKF->GetFeaturesInArea(u,v,radius);
+            // Search in a radius
+            const float radius = th * pKF->mvScaleFactors[nPredictedLevel];
 
-        if(vIndices.empty())
-            continue;
+            const vector<size_t> vIndices = pKF->GetFeaturesInArea(u, v, radius);
 
-        // Match to the most similar keypoint in the radius
+            if (vIndices.empty())
+                continue;
 
-        const cv::Mat dMP = pMP->GetDescriptor();
+            // Match to the most similar keypoint in the radius
 
-        int bestDist = 256;
-        int bestIdx = -1;
-        for(vector<size_t>::const_iterator vit=vIndices.begin(), vend=vIndices.end(); vit!=vend; vit++)
-        {
-            const size_t idx = *vit;
+            const cv::Mat dMP = pMP->GetDescriptor();
 
-            const cv::KeyPoint &kp = pKF->mvKeysUn[idx];
+            int bestDist = 256;
+            int bestIdx = -1;
+            for (vector<size_t>::const_iterator vit = vIndices.begin(), vend = vIndices.end(); vit != vend; vit++)
+            {
+                const size_t idx = *vit;
 
-            const int &kpLevel= kp.octave;
+                const cv::KeyPoint &kp = pKF->mvKeysUn[idx];
 
-            if(kpLevel<nPredictedLevel-1 || kpLevel>nPredictedLevel)
-                continue;
+                const int &kpLevel = kp.octave;
 
-            if(pKF->mvuRight[idx]>=0)
-            {
-                // Check reprojection error in stereo
-                const float &kpx = kp.pt.x;
-                const float &kpy = kp.pt.y;
-                const float &kpr = pKF->mvuRight[idx];
-                const float ex = u-kpx;
-                const float ey = v-kpy;
-                const float er = ur-kpr;
-                const float e2 = ex*ex+ey*ey+er*er;
-
-                if(e2*pKF->mvInvLevelSigma2[kpLevel]>7.8)
+                if (kpLevel < nPredictedLevel - 1 || kpLevel > nPredictedLevel)
                     continue;
-            }
-            else
-            {
-                const float &kpx = kp.pt.x;
-                const float &kpy = kp.pt.y;
-                const float ex = u-kpx;
-                const float ey = v-kpy;
-                const float e2 = ex*ex+ey*ey;
 
-                if(e2*pKF->mvInvLevelSigma2[kpLevel]>5.99)
-                    continue;
-            }
+                if (pKF->mvuRight[idx] >= 0)
+                {
+                    // Check reprojection error in stereo
+                    const float &kpx = kp.pt.x;
+                    const float &kpy = kp.pt.y;
+                    const float &kpr = pKF->mvuRight[idx];
+                    const float ex = u - kpx;
+                    const float ey = v - kpy;
+                    const float er = ur - kpr;
+                    const float e2 = ex * ex + ey * ey + er * er;
+
+                    if (e2 * pKF->mvInvLevelSigma2[kpLevel] > 7.8)
+                        continue;
+                }
+                else
+                {
+                    const float &kpx = kp.pt.x;
+                    const float &kpy = kp.pt.y;
+                    const float ex = u - kpx;
+                    const float ey = v - kpy;
+                    const float e2 = ex * ex + ey * ey;
 
-            const cv::Mat &dKF = pKF->mDescriptors.row(idx);
+                    if (e2 * pKF->mvInvLevelSigma2[kpLevel] > 5.99)
+                        continue;
+                }
 
-            const int dist = DescriptorDistance(dMP,dKF);
+                const cv::Mat &dKF = pKF->mDescriptors.row(idx);
 
-            if(dist<bestDist)
-            {
-                bestDist = dist;
-                bestIdx = idx;
-            }
-        }
+                const int dist = DescriptorDistance(dMP, dKF);
 
-        // If there is already a MapPoint replace otherwise add new measurement
-        if(bestDist<=TH_LOW)
-        {
-            MapPoint* pMPinKF = pKF->GetMapPoint(bestIdx);
-            if(pMPinKF)
-            {
-                if(!pMPinKF->isBad())
+                if (dist < bestDist)
                 {
-                    if(pMPinKF->Observations()>pMP->Observations())
-                        pMP->Replace(pMPinKF);
-                    else
-                        pMPinKF->Replace(pMP);
+                    bestDist = dist;
+                    bestIdx = idx;
                 }
             }
-            else
+
+            // If there is already a MapPoint replace otherwise add new measurement
+            if (bestDist <= TH_LOW)
             {
-                pMP->AddObservation(pKF,bestIdx);
-                pKF->AddMapPoint(pMP,bestIdx);
+                MapPoint *pMPinKF = pKF->GetMapPoint(bestIdx);
+                if (pMPinKF)
+                {
+                    if (!pMPinKF->isBad())
+                    {
+                        if (pMPinKF->Observations() > pMP->Observations())
+                            pMP->Replace(pMPinKF);
+                        else
+                            pMPinKF->Replace(pMP);
+                    }
+                }
+                else
+                {
+                    pMP->AddObservation(pKF, bestIdx);
+                    pKF->AddMapPoint(pMP, bestIdx);
+                }
+                nFused++;
             }
-            nFused++;
         }
-    }
 
-    return nFused;
-}
+        return nFused;
+    }
 
-int ORBmatcher::Fuse(KeyFrame *pKF, cv::Mat Scw, const vector<MapPoint *> &vpPoints, float th, vector<MapPoint *> &vpReplacePoint)
-{
-    // Get Calibration Parameters for later projection
-    const float &fx = pKF->fx;
-    const float &fy = pKF->fy;
-    const float &cx = pKF->cx;
-    const float &cy = pKF->cy;
+    int ORBmatcher::Fuse(KeyFrame *pKF, cv::Mat Scw, const vector<MapPoint *> &vpPoints, float th, vector<MapPoint *> &vpReplacePoint)
+    {
+        // Get Calibration Parameters for later projection
+        const float &fx = pKF->fx;
+        const float &fy = pKF->fy;
+        const float &cx = pKF->cx;
+        const float &cy = pKF->cy;
 
-    // Decompose Scw
-    cv::Mat sRcw = Scw.rowRange(0,3).colRange(0,3);
-    const float scw = sqrt(sRcw.row(0).dot(sRcw.row(0)));
-    cv::Mat Rcw = sRcw/scw;
-    cv::Mat tcw = Scw.rowRange(0,3).col(3)/scw;
-    cv::Mat Ow = -Rcw.t()*tcw;
+        // Decompose Scw
+        cv::Mat sRcw = Scw.rowRange(0, 3).colRange(0, 3);
+        const float scw = sqrt(sRcw.row(0).dot(sRcw.row(0)));
+        cv::Mat Rcw = sRcw / scw;
+        cv::Mat tcw = Scw.rowRange(0, 3).col(3) / scw;
+        cv::Mat Ow = -Rcw.t() * tcw;
 
-    // Set of MapPoints already found in the KeyFrame
-    const set<MapPoint*> spAlreadyFound = pKF->GetMapPoints();
+        // Set of MapPoints already found in the KeyFrame
+        const set<MapPoint *> spAlreadyFound = pKF->GetMapPoints();
 
-    int nFused=0;
+        int nFused = 0;
 
-    const int nPoints = vpPoints.size();
+        const int nPoints = vpPoints.size();
 
-    // For each candidate MapPoint project and match
-    for(int iMP=0; iMP<nPoints; iMP++)
-    {
-        MapPoint* pMP = vpPoints[iMP];
+        // For each candidate MapPoint project and match
+        for (int iMP = 0; iMP < nPoints; iMP++)
+        {
+            MapPoint *pMP = vpPoints[iMP];
 
-        // Discard Bad MapPoints and already found
-        if(pMP->isBad() || spAlreadyFound.count(pMP))
-            continue;
+            // Discard Bad MapPoints and already found
+            if (pMP->isBad() || spAlreadyFound.count(pMP))
+                continue;
 
-        // Get 3D Coords.
-        cv::Mat p3Dw = pMP->GetWorldPos();
+            // Get 3D Coords.
+            cv::Mat p3Dw = pMP->GetWorldPos();
 
-        // Transform into Camera Coords.
-        cv::Mat p3Dc = Rcw*p3Dw+tcw;
+            // Transform into Camera Coords.
+            cv::Mat p3Dc = Rcw * p3Dw + tcw;
 
-        // Depth must be positive
-        if(p3Dc.at<float>(2)<0.0f)
-            continue;
+            // Depth must be positive
+            if (p3Dc.at<float>(2) < 0.0f)
+                continue;
 
-        // Project into Image
-        const float invz = 1.0/p3Dc.at<float>(2);
-        const float x = p3Dc.at<float>(0)*invz;
-        const float y = p3Dc.at<float>(1)*invz;
+            // Project into Image
+            const float invz = 1.0 / p3Dc.at<float>(2);
+            const float x = p3Dc.at<float>(0) * invz;
+            const float y = p3Dc.at<float>(1) * invz;
 
-        const float u = fx*x+cx;
-        const float v = fy*y+cy;
+            const float u = fx * x + cx;
+            const float v = fy * y + cy;
 
-        // Point must be inside the image
-        if(!pKF->IsInImage(u,v))
-            continue;
+            // Point must be inside the image
+            if (!pKF->IsInImage(u, v))
+                continue;
 
-        // Depth must be inside the scale pyramid of the image
-        const float maxDistance = pMP->GetMaxDistanceInvariance();
-        const float minDistance = pMP->GetMinDistanceInvariance();
-        cv::Mat PO = p3Dw-Ow;
-        const float dist3D = cv::norm(PO);
+            // Depth must be inside the scale pyramid of the image
+            const float maxDistance = pMP->GetMaxDistanceInvariance();
+            const float minDistance = pMP->GetMinDistanceInvariance();
+            cv::Mat PO = p3Dw - Ow;
+            const float dist3D = cv::norm(PO);
 
-        if(dist3D<minDistance || dist3D>maxDistance)
-            continue;
+            if (dist3D < minDistance || dist3D > maxDistance)
+                continue;
 
-        // Viewing angle must be less than 60 deg
-        cv::Mat Pn = pMP->GetNormal();
+            // Viewing angle must be less than 60 deg
+            cv::Mat Pn = pMP->GetNormal();
 
-        if(PO.dot(Pn)<0.5*dist3D)
-            continue;
+            if (PO.dot(Pn) < 0.5 * dist3D)
+                continue;
 
-        // Compute predicted scale level
-        const int nPredictedLevel = pMP->PredictScale(dist3D,pKF->mfLogScaleFactor);
+            // Compute predicted scale level
+            const int nPredictedLevel = pMP->PredictScale(dist3D, pKF->mfLogScaleFactor);
 
-        // Search in a radius
-        const float radius = th*pKF->mvScaleFactors[nPredictedLevel];
+            // Search in a radius
+            const float radius = th * pKF->mvScaleFactors[nPredictedLevel];
 
-        const vector<size_t> vIndices = pKF->GetFeaturesInArea(u,v,radius);
+            const vector<size_t> vIndices = pKF->GetFeaturesInArea(u, v, radius);
 
-        if(vIndices.empty())
-            continue;
+            if (vIndices.empty())
+                continue;
 
-        // Match to the most similar keypoint in the radius
+            // Match to the most similar keypoint in the radius
 
-        const cv::Mat dMP = pMP->GetDescriptor();
+            const cv::Mat dMP = pMP->GetDescriptor();
 
-        int bestDist = INT_MAX;
-        int bestIdx = -1;
-        for(vector<size_t>::const_iterator vit=vIndices.begin(); vit!=vIndices.end(); vit++)
-        {
-            const size_t idx = *vit;
-            const int &kpLevel = pKF->mvKeysUn[idx].octave;
+            int bestDist = INT_MAX;
+            int bestIdx = -1;
+            for (vector<size_t>::const_iterator vit = vIndices.begin(); vit != vIndices.end(); vit++)
+            {
+                const size_t idx = *vit;
+                const int &kpLevel = pKF->mvKeysUn[idx].octave;
 
-            if(kpLevel<nPredictedLevel-1 || kpLevel>nPredictedLevel)
-                continue;
+                if (kpLevel < nPredictedLevel - 1 || kpLevel > nPredictedLevel)
+                    continue;
 
-            const cv::Mat &dKF = pKF->mDescriptors.row(idx);
+                const cv::Mat &dKF = pKF->mDescriptors.row(idx);
 
-            int dist = DescriptorDistance(dMP,dKF);
+                int dist = DescriptorDistance(dMP, dKF);
 
-            if(dist<bestDist)
-            {
-                bestDist = dist;
-                bestIdx = idx;
+                if (dist < bestDist)
+                {
+                    bestDist = dist;
+                    bestIdx = idx;
+                }
             }
-        }
 
-        // If there is already a MapPoint replace otherwise add new measurement
-        if(bestDist<=TH_LOW)
-        {
-            MapPoint* pMPinKF = pKF->GetMapPoint(bestIdx);
-            if(pMPinKF)
+            // If there is already a MapPoint replace otherwise add new measurement
+            if (bestDist <= TH_LOW)
             {
-                if(!pMPinKF->isBad())
-                    vpReplacePoint[iMP] = pMPinKF;
-            }
-            else
-            {
-                pMP->AddObservation(pKF,bestIdx);
-                pKF->AddMapPoint(pMP,bestIdx);
+                MapPoint *pMPinKF = pKF->GetMapPoint(bestIdx);
+                if (pMPinKF)
+                {
+                    if (!pMPinKF->isBad())
+                        vpReplacePoint[iMP] = pMPinKF;
+                }
+                else
+                {
+                    pMP->AddObservation(pKF, bestIdx);
+                    pKF->AddMapPoint(pMP, bestIdx);
+                }
+                nFused++;
             }
-            nFused++;
         }
-    }
 
-    return nFused;
-}
+        return nFused;
+    }
 
-int ORBmatcher::SearchBySim3(KeyFrame *pKF1, KeyFrame *pKF2, vector<MapPoint*> &vpMatches12,
-                             const float &s12, const cv::Mat &R12, const cv::Mat &t12, const float th)
-{
-    const float &fx = pKF1->fx;
-    const float &fy = pKF1->fy;
-    const float &cx = pKF1->cx;
-    const float &cy = pKF1->cy;
+    int ORBmatcher::SearchBySim3(KeyFrame *pKF1, KeyFrame *pKF2, vector<MapPoint *> &vpMatches12,
+                                 const float &s12, const cv::Mat &R12, const cv::Mat &t12, const float th)
+    {
+        const float &fx = pKF1->fx;
+        const float &fy = pKF1->fy;
+        const float &cx = pKF1->cx;
+        const float &cy = pKF1->cy;
 
-    // Camera 1 from world
-    cv::Mat R1w = pKF1->GetRotation();
-    cv::Mat t1w = pKF1->GetTranslation();
+        // Camera 1 from world
+        cv::Mat R1w = pKF1->GetRotation();
+        cv::Mat t1w = pKF1->GetTranslation();
 
-    //Camera 2 from world
-    cv::Mat R2w = pKF2->GetRotation();
-    cv::Mat t2w = pKF2->GetTranslation();
+        // Camera 2 from world
+        cv::Mat R2w = pKF2->GetRotation();
+        cv::Mat t2w = pKF2->GetTranslation();
 
-    //Transformation between cameras
-    cv::Mat sR12 = s12*R12;
-    cv::Mat sR21 = (1.0/s12)*R12.t();
-    cv::Mat t21 = -sR21*t12;
+        // Transformation between cameras
+        cv::Mat sR12 = s12 * R12;
+        cv::Mat sR21 = (1.0 / s12) * R12.t();
+        cv::Mat t21 = -sR21 * t12;
 
-    const vector<MapPoint*> vpMapPoints1 = pKF1->GetMapPointMatches();
-    const int N1 = vpMapPoints1.size();
+        const vector<MapPoint *> vpMapPoints1 = pKF1->GetMapPointMatches();
+        const int N1 = vpMapPoints1.size();
 
-    const vector<MapPoint*> vpMapPoints2 = pKF2->GetMapPointMatches();
-    const int N2 = vpMapPoints2.size();
+        const vector<MapPoint *> vpMapPoints2 = pKF2->GetMapPointMatches();
+        const int N2 = vpMapPoints2.size();
 
-    vector<bool> vbAlreadyMatched1(N1,false);
-    vector<bool> vbAlreadyMatched2(N2,false);
+        vector<bool> vbAlreadyMatched1(N1, false);
+        vector<bool> vbAlreadyMatched2(N2, false);
 
-    for(int i=0; i<N1; i++)
-    {
-        MapPoint* pMP = vpMatches12[i];
-        if(pMP)
+        for (int i = 0; i < N1; i++)
         {
-            vbAlreadyMatched1[i]=true;
-            int idx2 = pMP->GetIndexInKeyFrame(pKF2);
-            if(idx2>=0 && idx2<N2)
-                vbAlreadyMatched2[idx2]=true;
+            MapPoint *pMP = vpMatches12[i];
+            if (pMP)
+            {
+                vbAlreadyMatched1[i] = true;
+                int idx2 = pMP->GetIndexInKeyFrame(pKF2);
+                if (idx2 >= 0 && idx2 < N2)
+                    vbAlreadyMatched2[idx2] = true;
+            }
         }
-    }
 
-    vector<int> vnMatch1(N1,-1);
-    vector<int> vnMatch2(N2,-1);
+        vector<int> vnMatch1(N1, -1);
+        vector<int> vnMatch2(N2, -1);
 
-    // Transform from KF1 to KF2 and search
-    for(int i1=0; i1<N1; i1++)
-    {
-        MapPoint* pMP = vpMapPoints1[i1];
+        // Transform from KF1 to KF2 and search
+        for (int i1 = 0; i1 < N1; i1++)
+        {
+            MapPoint *pMP = vpMapPoints1[i1];
 
-        if(!pMP || vbAlreadyMatched1[i1])
-            continue;
+            if (!pMP || vbAlreadyMatched1[i1])
+                continue;
 
-        if(pMP->isBad())
-            continue;
+            if (pMP->isBad())
+                continue;
 
-        cv::Mat p3Dw = pMP->GetWorldPos();
-        cv::Mat p3Dc1 = R1w*p3Dw + t1w;
-        cv::Mat p3Dc2 = sR21*p3Dc1 + t21;
+            cv::Mat p3Dw = pMP->GetWorldPos();
+            cv::Mat p3Dc1 = R1w * p3Dw + t1w;
+            cv::Mat p3Dc2 = sR21 * p3Dc1 + t21;
 
-        // Depth must be positive
-        if(p3Dc2.at<float>(2)<0.0)
-            continue;
+            // Depth must be positive
+            if (p3Dc2.at<float>(2) < 0.0)
+                continue;
 
-        const float invz = 1.0/p3Dc2.at<float>(2);
-        const float x = p3Dc2.at<float>(0)*invz;
-        const float y = p3Dc2.at<float>(1)*invz;
+            const float invz = 1.0 / p3Dc2.at<float>(2);
+            const float x = p3Dc2.at<float>(0) * invz;
+            const float y = p3Dc2.at<float>(1) * invz;
 
-        const float u = fx*x+cx;
-        const float v = fy*y+cy;
+            const float u = fx * x + cx;
+            const float v = fy * y + cy;
 
-        // Point must be inside the image
-        if(!pKF2->IsInImage(u,v))
-            continue;
+            // Point must be inside the image
+            if (!pKF2->IsInImage(u, v))
+                continue;
+
+            const float maxDistance = pMP->GetMaxDistanceInvariance();
+            const float minDistance = pMP->GetMinDistanceInvariance();
+            const float dist3D = cv::norm(p3Dc2);
 
-        const float maxDistance = pMP->GetMaxDistanceInvariance();
-        const float minDistance = pMP->GetMinDistanceInvariance();
-        const float dist3D = cv::norm(p3Dc2);
+            // Depth must be inside the scale invariance region
+            if (dist3D < minDistance || dist3D > maxDistance)
+                continue;
 
-        // Depth must be inside the scale invariance region
-        if(dist3D<minDistance || dist3D>maxDistance )
-            continue;
+            // Compute predicted octave
+            const int nPredictedLevel = pMP->PredictScale(dist3D, pKF2->mfLogScaleFactor);
 
-        // Compute predicted octave
-        const int nPredictedLevel = pMP->PredictScale(dist3D,pKF2->mfLogScaleFactor);
+            // Search in a radius
+            const float radius = th * pKF2->mvScaleFactors[nPredictedLevel];
 
-        // Search in a radius
-        const float radius = th*pKF2->mvScaleFactors[nPredictedLevel];
+            const vector<size_t> vIndices = pKF2->GetFeaturesInArea(u, v, radius);
 
-        const vector<size_t> vIndices = pKF2->GetFeaturesInArea(u,v,radius);
+            if (vIndices.empty())
+                continue;
 
-        if(vIndices.empty())
-            continue;
+            // Match to the most similar keypoint in the radius
+            const cv::Mat dMP = pMP->GetDescriptor();
 
-        // Match to the most similar keypoint in the radius
-        const cv::Mat dMP = pMP->GetDescriptor();
+            int bestDist = INT_MAX;
+            int bestIdx = -1;
+            for (vector<size_t>::const_iterator vit = vIndices.begin(), vend = vIndices.end(); vit != vend; vit++)
+            {
+                const size_t idx = *vit;
 
-        int bestDist = INT_MAX;
-        int bestIdx = -1;
-        for(vector<size_t>::const_iterator vit=vIndices.begin(), vend=vIndices.end(); vit!=vend; vit++)
-        {
-            const size_t idx = *vit;
+                const cv::KeyPoint &kp = pKF2->mvKeysUn[idx];
 
-            const cv::KeyPoint &kp = pKF2->mvKeysUn[idx];
+                if (kp.octave < nPredictedLevel - 1 || kp.octave > nPredictedLevel)
+                    continue;
 
-            if(kp.octave<nPredictedLevel-1 || kp.octave>nPredictedLevel)
-                continue;
+                const cv::Mat &dKF = pKF2->mDescriptors.row(idx);
 
-            const cv::Mat &dKF = pKF2->mDescriptors.row(idx);
+                const int dist = DescriptorDistance(dMP, dKF);
 
-            const int dist = DescriptorDistance(dMP,dKF);
+                if (dist < bestDist)
+                {
+                    bestDist = dist;
+                    bestIdx = idx;
+                }
+            }
 
-            if(dist<bestDist)
+            if (bestDist <= TH_HIGH)
             {
-                bestDist = dist;
-                bestIdx = idx;
+                vnMatch1[i1] = bestIdx;
             }
         }
 
-        if(bestDist<=TH_HIGH)
+        // Transform from KF2 to KF2 and search
+        for (int i2 = 0; i2 < N2; i2++)
         {
-            vnMatch1[i1]=bestIdx;
-        }
-    }
+            MapPoint *pMP = vpMapPoints2[i2];
 
-    // Transform from KF2 to KF2 and search
-    for(int i2=0; i2<N2; i2++)
-    {
-        MapPoint* pMP = vpMapPoints2[i2];
+            if (!pMP || vbAlreadyMatched2[i2])
+                continue;
 
-        if(!pMP || vbAlreadyMatched2[i2])
-            continue;
+            if (pMP->isBad())
+                continue;
 
-        if(pMP->isBad())
-            continue;
+            cv::Mat p3Dw = pMP->GetWorldPos();
+            cv::Mat p3Dc2 = R2w * p3Dw + t2w;
+            cv::Mat p3Dc1 = sR12 * p3Dc2 + t12;
 
-        cv::Mat p3Dw = pMP->GetWorldPos();
-        cv::Mat p3Dc2 = R2w*p3Dw + t2w;
-        cv::Mat p3Dc1 = sR12*p3Dc2 + t12;
+            // Depth must be positive
+            if (p3Dc1.at<float>(2) < 0.0)
+                continue;
 
-        // Depth must be positive
-        if(p3Dc1.at<float>(2)<0.0)
-            continue;
+            const float invz = 1.0 / p3Dc1.at<float>(2);
+            const float x = p3Dc1.at<float>(0) * invz;
+            const float y = p3Dc1.at<float>(1) * invz;
 
-        const float invz = 1.0/p3Dc1.at<float>(2);
-        const float x = p3Dc1.at<float>(0)*invz;
-        const float y = p3Dc1.at<float>(1)*invz;
+            const float u = fx * x + cx;
+            const float v = fy * y + cy;
 
-        const float u = fx*x+cx;
-        const float v = fy*y+cy;
+            // Point must be inside the image
+            if (!pKF1->IsInImage(u, v))
+                continue;
 
-        // Point must be inside the image
-        if(!pKF1->IsInImage(u,v))
-            continue;
+            const float maxDistance = pMP->GetMaxDistanceInvariance();
+            const float minDistance = pMP->GetMinDistanceInvariance();
+            const float dist3D = cv::norm(p3Dc1);
 
-        const float maxDistance = pMP->GetMaxDistanceInvariance();
-        const float minDistance = pMP->GetMinDistanceInvariance();
-        const float dist3D = cv::norm(p3Dc1);
+            // Depth must be inside the scale pyramid of the image
+            if (dist3D < minDistance || dist3D > maxDistance)
+                continue;
 
-        // Depth must be inside the scale pyramid of the image
-        if(dist3D<minDistance || dist3D>maxDistance)
-            continue;
+            // Compute predicted octave
+            const int nPredictedLevel = pMP->PredictScale(dist3D, pKF1->mfLogScaleFactor);
 
-        // Compute predicted octave
-        const int nPredictedLevel = pMP->PredictScale(dist3D,pKF1->mfLogScaleFactor);
+            // Search in a radius of 2.5*sigma(ScaleLevel)
+            const float radius = th * pKF1->mvScaleFactors[nPredictedLevel];
 
-        // Search in a radius of 2.5*sigma(ScaleLevel)
-        const float radius = th*pKF1->mvScaleFactors[nPredictedLevel];
+            const vector<size_t> vIndices = pKF1->GetFeaturesInArea(u, v, radius);
 
-        const vector<size_t> vIndices = pKF1->GetFeaturesInArea(u,v,radius);
+            if (vIndices.empty())
+                continue;
 
-        if(vIndices.empty())
-            continue;
+            // Match to the most similar keypoint in the radius
+            const cv::Mat dMP = pMP->GetDescriptor();
 
-        // Match to the most similar keypoint in the radius
-        const cv::Mat dMP = pMP->GetDescriptor();
+            int bestDist = INT_MAX;
+            int bestIdx = -1;
+            for (vector<size_t>::const_iterator vit = vIndices.begin(), vend = vIndices.end(); vit != vend; vit++)
+            {
+                const size_t idx = *vit;
 
-        int bestDist = INT_MAX;
-        int bestIdx = -1;
-        for(vector<size_t>::const_iterator vit=vIndices.begin(), vend=vIndices.end(); vit!=vend; vit++)
-        {
-            const size_t idx = *vit;
+                const cv::KeyPoint &kp = pKF1->mvKeysUn[idx];
 
-            const cv::KeyPoint &kp = pKF1->mvKeysUn[idx];
+                if (kp.octave < nPredictedLevel - 1 || kp.octave > nPredictedLevel)
+                    continue;
 
-            if(kp.octave<nPredictedLevel-1 || kp.octave>nPredictedLevel)
-                continue;
+                const cv::Mat &dKF = pKF1->mDescriptors.row(idx);
 
-            const cv::Mat &dKF = pKF1->mDescriptors.row(idx);
+                const int dist = DescriptorDistance(dMP, dKF);
 
-            const int dist = DescriptorDistance(dMP,dKF);
+                if (dist < bestDist)
+                {
+                    bestDist = dist;
+                    bestIdx = idx;
+                }
+            }
 
-            if(dist<bestDist)
+            if (bestDist <= TH_HIGH)
             {
-                bestDist = dist;
-                bestIdx = idx;
+                vnMatch2[i2] = bestIdx;
             }
         }
 
-        if(bestDist<=TH_HIGH)
-        {
-            vnMatch2[i2]=bestIdx;
-        }
-    }
-
-    // Check agreement
-    int nFound = 0;
-
-    for(int i1=0; i1<N1; i1++)
-    {
-        int idx2 = vnMatch1[i1];
+        // Check agreement
+        int nFound = 0;
 
-        if(idx2>=0)
+        for (int i1 = 0; i1 < N1; i1++)
         {
-            int idx1 = vnMatch2[idx2];
-            if(idx1==i1)
+            int idx2 = vnMatch1[i1];
+
+            if (idx2 >= 0)
             {
-                vpMatches12[i1] = vpMapPoints2[idx2];
-                nFound++;
+                int idx1 = vnMatch2[idx2];
+                if (idx1 == i1)
+                {
+                    vpMatches12[i1] = vpMapPoints2[idx2];
+                    nFound++;
+                }
             }
         }
-    }
-
-    return nFound;
-}
 
-int ORBmatcher::SearchByProjection(Frame &CurrentFrame, const Frame &LastFrame, const float th, const bool bMono)
-{
-    int nmatches = 0;
+        return nFound;
+    }
 
-    // Rotation Histogram (to check rotation consistency)
-    vector<int> rotHist[HISTO_LENGTH];
-    for(int i=0;i<HISTO_LENGTH;i++)
-        rotHist[i].reserve(500);
-    const float factor = 1.0f/HISTO_LENGTH;
+    int ORBmatcher::SearchByProjection(Frame &CurrentFrame, const Frame &LastFrame, const float th, const bool bMono)
+    {
+        int nmatches = 0;
 
-    const cv::Mat Rcw = CurrentFrame.mTcw.rowRange(0,3).colRange(0,3);
-    const cv::Mat tcw = CurrentFrame.mTcw.rowRange(0,3).col(3);
+        // Rotation Histogram (to check rotation consistency)
+        vector<int> rotHist[HISTO_LENGTH];
+        for (int i = 0; i < HISTO_LENGTH; i++)
+            rotHist[i].reserve(500);
+        const float factor = 1.0f / HISTO_LENGTH;
 
-    const cv::Mat twc = -Rcw.t()*tcw;
+        const cv::Mat Rcw = CurrentFrame.mTcw.rowRange(0, 3).colRange(0, 3);
+        const cv::Mat tcw = CurrentFrame.mTcw.rowRange(0, 3).col(3);
 
-    const cv::Mat Rlw = LastFrame.mTcw.rowRange(0,3).colRange(0,3);
-    const cv::Mat tlw = LastFrame.mTcw.rowRange(0,3).col(3);
+        const cv::Mat twc = -Rcw.t() * tcw;
 
-    const cv::Mat tlc = Rlw*twc+tlw;
+        const cv::Mat Rlw = LastFrame.mTcw.rowRange(0, 3).colRange(0, 3);
+        const cv::Mat tlw = LastFrame.mTcw.rowRange(0, 3).col(3);
 
-    const bool bForward = tlc.at<float>(2)>CurrentFrame.mb && !bMono;
-    const bool bBackward = -tlc.at<float>(2)>CurrentFrame.mb && !bMono;
+        const cv::Mat tlc = Rlw * twc + tlw;
 
-    for(int i=0; i<LastFrame.N; i++)
-    {
-        MapPoint* pMP = LastFrame.mvpMapPoints[i];
+        const bool bForward = tlc.at<float>(2) > CurrentFrame.mb && !bMono;
+        const bool bBackward = -tlc.at<float>(2) > CurrentFrame.mb && !bMono;
 
-        if(pMP)
+        for (int i = 0; i < LastFrame.N; i++)
         {
-            if(!LastFrame.mvbOutlier[i])
-            {
-                // Project
-                cv::Mat x3Dw = pMP->GetWorldPos();
-                cv::Mat x3Dc = Rcw*x3Dw+tcw;
+            MapPoint *pMP = LastFrame.mvpMapPoints[i];
 
-                const float xc = x3Dc.at<float>(0);
-                const float yc = x3Dc.at<float>(1);
-                const float invzc = 1.0/x3Dc.at<float>(2);
+            if (pMP)
+            {
+                if (!LastFrame.mvbOutlier[i])
+                {
+                    // Project
+                    cv::Mat x3Dw = pMP->GetWorldPos();
+                    cv::Mat x3Dc = Rcw * x3Dw + tcw;
 
-                if(invzc<0)
-                    continue;
+                    const float xc = x3Dc.at<float>(0);
+                    const float yc = x3Dc.at<float>(1);
+                    const float invzc = 1.0 / x3Dc.at<float>(2);
 
-                float u = CurrentFrame.fx*xc*invzc+CurrentFrame.cx;
-                float v = CurrentFrame.fy*yc*invzc+CurrentFrame.cy;
+                    if (invzc < 0)
+                        continue;
 
-                if(u<CurrentFrame.mnMinX || u>CurrentFrame.mnMaxX)
-                    continue;
-                if(v<CurrentFrame.mnMinY || v>CurrentFrame.mnMaxY)
-                    continue;
+                    float u = CurrentFrame.fx * xc * invzc + CurrentFrame.cx;
+                    float v = CurrentFrame.fy * yc * invzc + CurrentFrame.cy;
 
-                int nLastOctave = LastFrame.mvKeys[i].octave;
+                    if (u < CurrentFrame.mnMinX || u > CurrentFrame.mnMaxX)
+                        continue;
+                    if (v < CurrentFrame.mnMinY || v > CurrentFrame.mnMaxY)
+                        continue;
 
-                // Search in a window. Size depends on scale
-                float radius = th*CurrentFrame.mvScaleFactors[nLastOctave];
+                    int nLastOctave = LastFrame.mvKeys[i].octave;
 
-                vector<size_t> vIndices2;
+                    // Search in a window. Size depends on scale
+                    float radius = th * CurrentFrame.mvScaleFactors[nLastOctave];
 
-                if(bForward)
-                    vIndices2 = CurrentFrame.GetFeaturesInArea(u,v, radius, nLastOctave);
-                else if(bBackward)
-                    vIndices2 = CurrentFrame.GetFeaturesInArea(u,v, radius, 0, nLastOctave);
-                else
-                    vIndices2 = CurrentFrame.GetFeaturesInArea(u,v, radius, nLastOctave-1, nLastOctave+1);
+                    vector<size_t> vIndices2;
 
-                if(vIndices2.empty())
-                    continue;
+                    if (bForward)
+                        vIndices2 = CurrentFrame.GetFeaturesInArea(u, v, radius, nLastOctave);
+                    else if (bBackward)
+                        vIndices2 = CurrentFrame.GetFeaturesInArea(u, v, radius, 0, nLastOctave);
+                    else
+                        vIndices2 = CurrentFrame.GetFeaturesInArea(u, v, radius, nLastOctave - 1, nLastOctave + 1);
 
-                const cv::Mat dMP = pMP->GetDescriptor();
+                    if (vIndices2.empty())
+                        continue;
 
-                int bestDist = 256;
-                int bestIdx2 = -1;
+                    const cv::Mat dMP = pMP->GetDescriptor();
 
-                for(vector<size_t>::const_iterator vit=vIndices2.begin(), vend=vIndices2.end(); vit!=vend; vit++)
-                {
-                    const size_t i2 = *vit;
-                    if(CurrentFrame.mvpMapPoints[i2])
-                        if(CurrentFrame.mvpMapPoints[i2]->Observations()>0)
-                            continue;
+                    int bestDist = 256;
+                    int bestIdx2 = -1;
 
-                    if(CurrentFrame.mvuRight[i2]>0)
+                    for (vector<size_t>::const_iterator vit = vIndices2.begin(), vend = vIndices2.end(); vit != vend; vit++)
                     {
-                        const float ur = u - CurrentFrame.mbf*invzc;
-                        const float er = fabs(ur - CurrentFrame.mvuRight[i2]);
-                        if(er>radius)
-                            continue;
-                    }
+                        const size_t i2 = *vit;
+                        if (CurrentFrame.mvpMapPoints[i2])
+                            if (CurrentFrame.mvpMapPoints[i2]->Observations() > 0)
+                                continue;
 
-                    const cv::Mat &d = CurrentFrame.mDescriptors.row(i2);
+                        if (CurrentFrame.mvuRight[i2] > 0)
+                        {
+                            const float ur = u - CurrentFrame.mbf * invzc;
+                            const float er = fabs(ur - CurrentFrame.mvuRight[i2]);
+                            if (er > radius)
+                                continue;
+                        }
 
-                    const int dist = DescriptorDistance(dMP,d);
+                        const cv::Mat &d = CurrentFrame.mDescriptors.row(i2);
 
-                    if(dist<bestDist)
-                    {
-                        bestDist=dist;
-                        bestIdx2=i2;
-                    }
-                }
+                        const int dist = DescriptorDistance(dMP, d);
 
-                if(bestDist<=TH_HIGH)
-                {
-                    CurrentFrame.mvpMapPoints[bestIdx2]=pMP;
-                    nmatches++;
+                        if (dist < bestDist)
+                        {
+                            bestDist = dist;
+                            bestIdx2 = i2;
+                        }
+                    }
 
-                    if(mbCheckOrientation)
+                    if (bestDist <= TH_HIGH)
                     {
-                        float rot = LastFrame.mvKeysUn[i].angle-CurrentFrame.mvKeysUn[bestIdx2].angle;
-                        if(rot<0.0)
-                            rot+=360.0f;
-                        int bin = round(rot*factor);
-                        if(bin==HISTO_LENGTH)
-                            bin=0;
-                        assert(bin>=0 && bin<HISTO_LENGTH);
-                        rotHist[bin].push_back(bestIdx2);
+                        CurrentFrame.mvpMapPoints[bestIdx2] = pMP;
+                        nmatches++;
+
+                        if (mbCheckOrientation)
+                        {
+                            float rot = LastFrame.mvKeysUn[i].angle - CurrentFrame.mvKeysUn[bestIdx2].angle;
+                            if (rot < 0.0)
+                                rot += 360.0f;
+                            int bin = round(rot * factor);
+                            if (bin == HISTO_LENGTH)
+                                bin = 0;
+                            assert(bin >= 0 && bin < HISTO_LENGTH);
+                            rotHist[bin].push_back(bestIdx2);
+                        }
                     }
                 }
             }
         }
-    }
 
-    //Apply rotation consistency
-    if(mbCheckOrientation)
-    {
-        int ind1=-1;
-        int ind2=-1;
-        int ind3=-1;
+        // Apply rotation consistency
+        if (mbCheckOrientation)
+        {
+            int ind1 = -1;
+            int ind2 = -1;
+            int ind3 = -1;
 
-        ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3);
+            ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);
 
-        for(int i=0; i<HISTO_LENGTH; i++)
-        {
-            if(i!=ind1 && i!=ind2 && i!=ind3)
+            for (int i = 0; i < HISTO_LENGTH; i++)
             {
-                for(size_t j=0, jend=rotHist[i].size(); j<jend; j++)
+                if (i != ind1 && i != ind2 && i != ind3)
                 {
-                    CurrentFrame.mvpMapPoints[rotHist[i][j]]=static_cast<MapPoint*>(NULL);
-                    nmatches--;
+                    for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
+                    {
+                        CurrentFrame.mvpMapPoints[rotHist[i][j]] = static_cast<MapPoint *>(NULL);
+                        nmatches--;
+                    }
                 }
             }
         }
-    }
 
-    return nmatches;
-}
-
-int ORBmatcher::SearchByProjection(Frame &CurrentFrame, KeyFrame *pKF, const set<MapPoint*> &sAlreadyFound, const float th , const int ORBdist)
-{
-    int nmatches = 0;
+        return nmatches;
+    }
 
-    const cv::Mat Rcw = CurrentFrame.mTcw.rowRange(0,3).colRange(0,3);
-    const cv::Mat tcw = CurrentFrame.mTcw.rowRange(0,3).col(3);
-    const cv::Mat Ow = -Rcw.t()*tcw;
+    int ORBmatcher::SearchByProjection(Frame &CurrentFrame, KeyFrame *pKF, const set<MapPoint *> &sAlreadyFound, const float th, const int ORBdist)
+    {
+        int nmatches = 0;
 
-    // Rotation Histogram (to check rotation consistency)
-    vector<int> rotHist[HISTO_LENGTH];
-    for(int i=0;i<HISTO_LENGTH;i++)
-        rotHist[i].reserve(500);
-    const float factor = 1.0f/HISTO_LENGTH;
+        const cv::Mat Rcw = CurrentFrame.mTcw.rowRange(0, 3).colRange(0, 3);
+        const cv::Mat tcw = CurrentFrame.mTcw.rowRange(0, 3).col(3);
+        const cv::Mat Ow = -Rcw.t() * tcw;
 
-    const vector<MapPoint*> vpMPs = pKF->GetMapPointMatches();
+        // Rotation Histogram (to check rotation consistency)
+        vector<int> rotHist[HISTO_LENGTH];
+        for (int i = 0; i < HISTO_LENGTH; i++)
+            rotHist[i].reserve(500);
+        const float factor = 1.0f / HISTO_LENGTH;
 
-    for(size_t i=0, iend=vpMPs.size(); i<iend; i++)
-    {
-        MapPoint* pMP = vpMPs[i];
+        const vector<MapPoint *> vpMPs = pKF->GetMapPointMatches();
 
-        if(pMP)
+        for (size_t i = 0, iend = vpMPs.size(); i < iend; i++)
         {
-            if(!pMP->isBad() && !sAlreadyFound.count(pMP))
+            MapPoint *pMP = vpMPs[i];
+
+            if (pMP)
             {
-                //Project
-                cv::Mat x3Dw = pMP->GetWorldPos();
-                cv::Mat x3Dc = Rcw*x3Dw+tcw;
+                if (!pMP->isBad() && !sAlreadyFound.count(pMP))
+                {
+                    // Project
+                    cv::Mat x3Dw = pMP->GetWorldPos();
+                    cv::Mat x3Dc = Rcw * x3Dw + tcw;
 
-                const float xc = x3Dc.at<float>(0);
-                const float yc = x3Dc.at<float>(1);
-                const float invzc = 1.0/x3Dc.at<float>(2);
+                    const float xc = x3Dc.at<float>(0);
+                    const float yc = x3Dc.at<float>(1);
+                    const float invzc = 1.0 / x3Dc.at<float>(2);
 
-                const float u = CurrentFrame.fx*xc*invzc+CurrentFrame.cx;
-                const float v = CurrentFrame.fy*yc*invzc+CurrentFrame.cy;
+                    const float u = CurrentFrame.fx * xc * invzc + CurrentFrame.cx;
+                    const float v = CurrentFrame.fy * yc * invzc + CurrentFrame.cy;
 
-                if(u<CurrentFrame.mnMinX || u>CurrentFrame.mnMaxX)
-                    continue;
-                if(v<CurrentFrame.mnMinY || v>CurrentFrame.mnMaxY)
-                    continue;
+                    if (u < CurrentFrame.mnMinX || u > CurrentFrame.mnMaxX)
+                        continue;
+                    if (v < CurrentFrame.mnMinY || v > CurrentFrame.mnMaxY)
+                        continue;
 
-                // Compute predicted scale level
-                cv::Mat PO = x3Dw-Ow;
-                float dist3D = cv::norm(PO);
+                    // Compute predicted scale level
+                    cv::Mat PO = x3Dw - Ow;
+                    float dist3D = cv::norm(PO);
 
-                const float maxDistance = pMP->GetMaxDistanceInvariance();
-                const float minDistance = pMP->GetMinDistanceInvariance();
+                    const float maxDistance = pMP->GetMaxDistanceInvariance();
+                    const float minDistance = pMP->GetMinDistanceInvariance();
 
-                // Depth must be inside the scale pyramid of the image
-                if(dist3D<minDistance || dist3D>maxDistance)
-                    continue;
+                    // Depth must be inside the scale pyramid of the image
+                    if (dist3D < minDistance || dist3D > maxDistance)
+                        continue;
 
-                int nPredictedLevel = pMP->PredictScale(dist3D,CurrentFrame.mfLogScaleFactor);
+                    int nPredictedLevel = pMP->PredictScale(dist3D, CurrentFrame.mfLogScaleFactor);
 
-                // Search in a window
-                const float radius = th*CurrentFrame.mvScaleFactors[nPredictedLevel];
+                    // Search in a window
+                    const float radius = th * CurrentFrame.mvScaleFactors[nPredictedLevel];
 
-                const vector<size_t> vIndices2 = CurrentFrame.GetFeaturesInArea(u, v, radius, nPredictedLevel-1, nPredictedLevel+1);
+                    const vector<size_t> vIndices2 = CurrentFrame.GetFeaturesInArea(u, v, radius, nPredictedLevel - 1, nPredictedLevel + 1);
 
-                if(vIndices2.empty())
-                    continue;
+                    if (vIndices2.empty())
+                        continue;
 
-                const cv::Mat dMP = pMP->GetDescriptor();
+                    const cv::Mat dMP = pMP->GetDescriptor();
 
-                int bestDist = 256;
-                int bestIdx2 = -1;
+                    int bestDist = 256;
+                    int bestIdx2 = -1;
 
-                for(vector<size_t>::const_iterator vit=vIndices2.begin(); vit!=vIndices2.end(); vit++)
-                {
-                    const size_t i2 = *vit;
-                    if(CurrentFrame.mvpMapPoints[i2])
-                        continue;
+                    for (vector<size_t>::const_iterator vit = vIndices2.begin(); vit != vIndices2.end(); vit++)
+                    {
+                        const size_t i2 = *vit;
+                        if (CurrentFrame.mvpMapPoints[i2])
+                            continue;
 
-                    const cv::Mat &d = CurrentFrame.mDescriptors.row(i2);
+                        const cv::Mat &d = CurrentFrame.mDescriptors.row(i2);
 
-                    const int dist = DescriptorDistance(dMP,d);
+                        const int dist = DescriptorDistance(dMP, d);
 
-                    if(dist<bestDist)
-                    {
-                        bestDist=dist;
-                        bestIdx2=i2;
+                        if (dist < bestDist)
+                        {
+                            bestDist = dist;
+                            bestIdx2 = i2;
+                        }
                     }
-                }
-
-                if(bestDist<=ORBdist)
-                {
-                    CurrentFrame.mvpMapPoints[bestIdx2]=pMP;
-                    nmatches++;
 
-                    if(mbCheckOrientation)
+                    if (bestDist <= ORBdist)
                     {
-                        float rot = pKF->mvKeysUn[i].angle-CurrentFrame.mvKeysUn[bestIdx2].angle;
-                        if(rot<0.0)
-                            rot+=360.0f;
-                        int bin = round(rot*factor);
-                        if(bin==HISTO_LENGTH)
-                            bin=0;
-                        assert(bin>=0 && bin<HISTO_LENGTH);
-                        rotHist[bin].push_back(bestIdx2);
+                        CurrentFrame.mvpMapPoints[bestIdx2] = pMP;
+                        nmatches++;
+
+                        if (mbCheckOrientation)
+                        {
+                            float rot = pKF->mvKeysUn[i].angle - CurrentFrame.mvKeysUn[bestIdx2].angle;
+                            if (rot < 0.0)
+                                rot += 360.0f;
+                            int bin = round(rot * factor);
+                            if (bin == HISTO_LENGTH)
+                                bin = 0;
+                            assert(bin >= 0 && bin < HISTO_LENGTH);
+                            rotHist[bin].push_back(bestIdx2);
+                        }
                     }
                 }
-
             }
         }
-    }
 
-    if(mbCheckOrientation)
-    {
-        int ind1=-1;
-        int ind2=-1;
-        int ind3=-1;
+        if (mbCheckOrientation)
+        {
+            int ind1 = -1;
+            int ind2 = -1;
+            int ind3 = -1;
 
-        ComputeThreeMaxima(rotHist,HISTO_LENGTH,ind1,ind2,ind3);
+            ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);
 
-        for(int i=0; i<HISTO_LENGTH; i++)
-        {
-            if(i!=ind1 && i!=ind2 && i!=ind3)
+            for (int i = 0; i < HISTO_LENGTH; i++)
             {
-                for(size_t j=0, jend=rotHist[i].size(); j<jend; j++)
+                if (i != ind1 && i != ind2 && i != ind3)
                 {
-                    CurrentFrame.mvpMapPoints[rotHist[i][j]]=NULL;
-                    nmatches--;
+                    for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
+                    {
+                        CurrentFrame.mvpMapPoints[rotHist[i][j]] = NULL;
+                        nmatches--;
+                    }
                 }
             }
         }
-    }
 
-    return nmatches;
-}
-
-void ORBmatcher::ComputeThreeMaxima(vector<int>* histo, const int L, int &ind1, int &ind2, int &ind3)
-{
-    int max1=0;
-    int max2=0;
-    int max3=0;
+        return nmatches;
+    }
 
-    for(int i=0; i<L; i++)
+    void ORBmatcher::ComputeThreeMaxima(vector<int> *histo, const int L, int &ind1, int &ind2, int &ind3)
     {
-        const int s = histo[i].size();
-        if(s>max1)
+        int max1 = 0;
+        int max2 = 0;
+        int max3 = 0;
+
+        for (int i = 0; i < L; i++)
         {
-            max3=max2;
-            max2=max1;
-            max1=s;
-            ind3=ind2;
-            ind2=ind1;
-            ind1=i;
+            const int s = histo[i].size();
+            if (s > max1)
+            {
+                max3 = max2;
+                max2 = max1;
+                max1 = s;
+                ind3 = ind2;
+                ind2 = ind1;
+                ind1 = i;
+            }
+            else if (s > max2)
+            {
+                max3 = max2;
+                max2 = s;
+                ind3 = ind2;
+                ind2 = i;
+            }
+            else if (s > max3)
+            {
+                max3 = s;
+                ind3 = i;
+            }
         }
-        else if(s>max2)
+
+        if (max2 < 0.1f * (float)max1)
         {
-            max3=max2;
-            max2=s;
-            ind3=ind2;
-            ind2=i;
+            ind2 = -1;
+            ind3 = -1;
         }
-        else if(s>max3)
+        else if (max3 < 0.1f * (float)max1)
         {
-            max3=s;
-            ind3=i;
+            ind3 = -1;
         }
     }
 
-    if(max2<0.1f*(float)max1)
-    {
-        ind2=-1;
-        ind3=-1;
-    }
-    else if(max3<0.1f*(float)max1)
+    // Bit set count operation from
+    // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
+    int ORBmatcher::DescriptorDistance(const cv::Mat &a, const cv::Mat &b)
     {
-        ind3=-1;
-    }
-}
-
+        const int *pa = a.ptr<int32_t>();
+        const int *pb = b.ptr<int32_t>();
 
-// Bit set count operation from
-// http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
-int ORBmatcher::DescriptorDistance(const cv::Mat &a, const cv::Mat &b)
-{
-    const int *pa = a.ptr<int32_t>();
-    const int *pb = b.ptr<int32_t>();
+        int dist = 0;
 
-    int dist=0;
+        for (int i = 0; i < 8; i++, pa++, pb++)
+        {
+            unsigned int v = *pa ^ *pb;
+            v = v - ((v >> 1) & 0x55555555);
+            v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
+            dist += (((v + (v >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
+        }
 
-    for(int i=0; i<8; i++, pa++, pb++)
-    {
-        unsigned  int v = *pa ^ *pb;
-        v = v - ((v >> 1) & 0x55555555);
-        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
-        dist += (((v + (v >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
+        return dist;
     }
 
-    return dist;
-}
-
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/Optimizer.cc b/slam/src/Optimizer.cc
index 2b913ba..c7a970a 100644
--- a/slam/src/Optimizer.cc
+++ b/slam/src/Optimizer.cc
@@ -19,14 +19,13 @@
 */
 
 #include "Optimizer.h"
-
-#include "../Thirdparty/g2o/g2o/core/block_solver.h"
-#include "../Thirdparty/g2o/g2o/core/optimization_algorithm_levenberg.h"
-#include "../Thirdparty/g2o/g2o/solvers/linear_solver_eigen.h"
-#include "../Thirdparty/g2o/g2o/types/types_six_dof_expmap.h"
-#include "../Thirdparty/g2o/g2o/core/robust_kernel_impl.h"
-#include "../Thirdparty/g2o/g2o/solvers/linear_solver_dense.h"
-#include "../Thirdparty/g2o/g2o/types/types_seven_dof_expmap.h"
+#include "g2o/core/block_solver.h"
+#include "g2o/core/optimization_algorithm_levenberg.h"
+#include "g2o/solvers/linear_solver_eigen.h"
+#include "g2o/types/types_six_dof_expmap.h"
+#include "g2o/core/robust_kernel_impl.h"
+#include "g2o/solvers/linear_solver_dense.h"
+#include "g2o/types/types_seven_dof_expmap.h"
 
 #include<Eigen/StdVector>
 
diff --git a/slam/src/PnPsolver.cc b/slam/src/PnPsolver.cc
index dcf53c7..e9ea9f9 100644
--- a/slam/src/PnPsolver.cc
+++ b/slam/src/PnPsolver.cc
@@ -1,52 +1,52 @@
 /**
-* This file is part of ORB-SLAM2.
-* This file is a modified version of EPnP <http://cvlab.epfl.ch/EPnP/index.php>, see FreeBSD license below.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ * This file is a modified version of EPnP <http://cvlab.epfl.ch/EPnP/index.php>, see FreeBSD license below.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 /**
-* Copyright (c) 2009, V. Lepetit, EPFL
-* All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*
-* 1. Redistributions of source code must retain the above copyright notice, this
-*    list of conditions and the following disclaimer.
-* 2. Redistributions in binary form must reproduce the above copyright notice,
-*    this list of conditions and the following disclaimer in the documentation
-*    and/or other materials provided with the distribution.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-* The views and conclusions contained in the software and documentation are those
-* of the authors and should not be interpreted as representing official policies,
-*   either expressed or implied, of the FreeBSD Project
-*/
+ * Copyright (c) 2009, V. Lepetit, EPFL
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation are those
+ * of the authors and should not be interpreted as representing official policies,
+ *   either expressed or implied, of the FreeBSD Project
+ */
 
 #include <iostream>
 
@@ -55,7 +55,8 @@
 #include <vector>
 #include <cmath>
 #include <opencv2/core/core.hpp>
-#include "../Thirdparty/DBoW2/DUtils/Random.h"
+#include <opencv2/opencv.hpp>
+#include "DUtils/Random.h"
 #include <algorithm>
 
 using namespace std;
@@ -63,11 +64,9 @@ using namespace std;
 namespace ORB_SLAM2
 {
 
-
-PnPsolver::PnPsolver(const Frame &F, const vector<MapPoint*> &vpMapPointMatches):
-    pws(0), us(0), alphas(0), pcs(0), maximum_number_of_correspondences(0), number_of_correspondences(0), mnInliersi(0),
-    mnIterations(0), mnBestInliers(0), N(0)
-{
+  PnPsolver::PnPsolver(const Frame &F, const vector<MapPoint *> &vpMapPointMatches) : pws(0), us(0), alphas(0), pcs(0), maximum_number_of_correspondences(0), number_of_correspondences(0), mnInliersi(0),
+                                                                                      mnIterations(0), mnBestInliers(0), N(0)
+  {
     mvpMapPointMatches = vpMapPointMatches;
     mvP2D.reserve(F.mvpMapPoints.size());
     mvSigma2.reserve(F.mvpMapPoints.size());
@@ -75,29 +74,29 @@ PnPsolver::PnPsolver(const Frame &F, const vector<MapPoint*> &vpMapPointMatches)
     mvKeyPointIndices.reserve(F.mvpMapPoints.size());
     mvAllIndices.reserve(F.mvpMapPoints.size());
 
-    int idx=0;
-    for(size_t i=0, iend=vpMapPointMatches.size(); i<iend; i++)
+    int idx = 0;
+    for (size_t i = 0, iend = vpMapPointMatches.size(); i < iend; i++)
     {
-        MapPoint* pMP = vpMapPointMatches[i];
+      MapPoint *pMP = vpMapPointMatches[i];
 
-        if(pMP)
+      if (pMP)
+      {
+        if (!pMP->isBad())
         {
-            if(!pMP->isBad())
-            {
-                const cv::KeyPoint &kp = F.mvKeysUn[i];
+          const cv::KeyPoint &kp = F.mvKeysUn[i];
 
-                mvP2D.push_back(kp.pt);
-                mvSigma2.push_back(F.mvLevelSigma2[kp.octave]);
+          mvP2D.push_back(kp.pt);
+          mvSigma2.push_back(F.mvLevelSigma2[kp.octave]);
 
-                cv::Mat Pos = pMP->GetWorldPos();
-                mvP3Dw.push_back(cv::Point3f(Pos.at<float>(0),Pos.at<float>(1), Pos.at<float>(2)));
+          cv::Mat Pos = pMP->GetWorldPos();
+          mvP3Dw.push_back(cv::Point3f(Pos.at<float>(0), Pos.at<float>(1), Pos.at<float>(2)));
 
-                mvKeyPointIndices.push_back(i);
-                mvAllIndices.push_back(idx);               
+          mvKeyPointIndices.push_back(i);
+          mvAllIndices.push_back(idx);
 
-                idx++;
-            }
+          idx++;
         }
+      }
     }
 
     // Set camera calibration parameters
@@ -107,19 +106,18 @@ PnPsolver::PnPsolver(const Frame &F, const vector<MapPoint*> &vpMapPointMatches)
     vc = F.cy;
 
     SetRansacParameters();
-}
-
-PnPsolver::~PnPsolver()
-{
-  delete [] pws;
-  delete [] us;
-  delete [] alphas;
-  delete [] pcs;
-}
+  }
 
+  PnPsolver::~PnPsolver()
+  {
+    delete[] pws;
+    delete[] us;
+    delete[] alphas;
+    delete[] pcs;
+  }
 
-void PnPsolver::SetRansacParameters(double probability, int minInliers, int maxIterations, int minSet, float epsilon, float th2)
-{
+  void PnPsolver::SetRansacParameters(double probability, int minInliers, int maxIterations, int minSet, float epsilon, float th2)
+  {
     mRansacProb = probability;
     mRansacMinInliers = minInliers;
     mRansacMaxIts = maxIterations;
@@ -131,155 +129,154 @@ void PnPsolver::SetRansacParameters(double probability, int minInliers, int maxI
     mvbInliersi.resize(N);
 
     // Adjust Parameters according to number of correspondences
-    int nMinInliers = N*mRansacEpsilon;
-    if(nMinInliers<mRansacMinInliers)
-        nMinInliers=mRansacMinInliers;
-    if(nMinInliers<minSet)
-        nMinInliers=minSet;
+    int nMinInliers = N * mRansacEpsilon;
+    if (nMinInliers < mRansacMinInliers)
+      nMinInliers = mRansacMinInliers;
+    if (nMinInliers < minSet)
+      nMinInliers = minSet;
     mRansacMinInliers = nMinInliers;
 
-    if(mRansacEpsilon<(float)mRansacMinInliers/N)
-        mRansacEpsilon=(float)mRansacMinInliers/N;
+    if (mRansacEpsilon < (float)mRansacMinInliers / N)
+      mRansacEpsilon = (float)mRansacMinInliers / N;
 
     // Set RANSAC iterations according to probability, epsilon, and max iterations
     int nIterations;
 
-    if(mRansacMinInliers==N)
-        nIterations=1;
+    if (mRansacMinInliers == N)
+      nIterations = 1;
     else
-        nIterations = ceil(log(1-mRansacProb)/log(1-pow(mRansacEpsilon,3)));
+      nIterations = ceil(log(1 - mRansacProb) / log(1 - pow(mRansacEpsilon, 3)));
 
-    mRansacMaxIts = max(1,min(nIterations,mRansacMaxIts));
+    mRansacMaxIts = max(1, min(nIterations, mRansacMaxIts));
 
     mvMaxError.resize(mvSigma2.size());
-    for(size_t i=0; i<mvSigma2.size(); i++)
-        mvMaxError[i] = mvSigma2[i]*th2;
-}
+    for (size_t i = 0; i < mvSigma2.size(); i++)
+      mvMaxError[i] = mvSigma2[i] * th2;
+  }
 
-cv::Mat PnPsolver::find(vector<bool> &vbInliers, int &nInliers)
-{
+  cv::Mat PnPsolver::find(vector<bool> &vbInliers, int &nInliers)
+  {
     bool bFlag;
-    return iterate(mRansacMaxIts,bFlag,vbInliers,nInliers);    
-}
+    return iterate(mRansacMaxIts, bFlag, vbInliers, nInliers);
+  }
 
-cv::Mat PnPsolver::iterate(int nIterations, bool &bNoMore, vector<bool> &vbInliers, int &nInliers)
-{
+  cv::Mat PnPsolver::iterate(int nIterations, bool &bNoMore, vector<bool> &vbInliers, int &nInliers)
+  {
     bNoMore = false;
     vbInliers.clear();
-    nInliers=0;
+    nInliers = 0;
 
     set_maximum_number_of_correspondences(mRansacMinSet);
 
-    if(N<mRansacMinInliers)
+    if (N < mRansacMinInliers)
     {
-        bNoMore = true;
-        return cv::Mat();
+      bNoMore = true;
+      return cv::Mat();
     }
 
     vector<size_t> vAvailableIndices;
 
     int nCurrentIterations = 0;
-    while(mnIterations<mRansacMaxIts || nCurrentIterations<nIterations)
+    while (mnIterations < mRansacMaxIts || nCurrentIterations < nIterations)
     {
-        nCurrentIterations++;
-        mnIterations++;
-        reset_correspondences();
+      nCurrentIterations++;
+      mnIterations++;
+      reset_correspondences();
 
-        vAvailableIndices = mvAllIndices;
+      vAvailableIndices = mvAllIndices;
 
-        // Get min set of points
-        for(short i = 0; i < mRansacMinSet; ++i)
-        {
-            int randi = DUtils::Random::RandomInt(0, vAvailableIndices.size()-1);
+      // Get min set of points
+      for (short i = 0; i < mRansacMinSet; ++i)
+      {
+        int randi = DUtils::Random::RandomInt(0, vAvailableIndices.size() - 1);
 
-            int idx = vAvailableIndices[randi];
+        int idx = vAvailableIndices[randi];
 
-            add_correspondence(mvP3Dw[idx].x,mvP3Dw[idx].y,mvP3Dw[idx].z,mvP2D[idx].x,mvP2D[idx].y);
+        add_correspondence(mvP3Dw[idx].x, mvP3Dw[idx].y, mvP3Dw[idx].z, mvP2D[idx].x, mvP2D[idx].y);
 
-            vAvailableIndices[idx] = vAvailableIndices.back();
-            vAvailableIndices.pop_back();
-        }
+        vAvailableIndices[idx] = vAvailableIndices.back();
+        vAvailableIndices.pop_back();
+      }
 
-        // Compute camera pose
-        compute_pose(mRi, mti);
+      // Compute camera pose
+      compute_pose(mRi, mti);
 
-        // Check inliers
-        CheckInliers();
+      // Check inliers
+      CheckInliers();
 
-        //cout << "iterate: CP mnInliersi = " << mnInliersi << " mRansacMinInliers = "<< mRansacMinInliers << endl;
+      // cout << "iterate: CP mnInliersi = " << mnInliersi << " mRansacMinInliers = "<< mRansacMinInliers << endl;
 
-        if(mnInliersi>=mRansacMinInliers)
+      if (mnInliersi >= mRansacMinInliers)
+      {
+        // If it is the best solution so far, save it
+        if (mnInliersi > mnBestInliers)
         {
-            // If it is the best solution so far, save it
-            if(mnInliersi>mnBestInliers)
-            {
-                mvbBestInliers = mvbInliersi;
-                mnBestInliers = mnInliersi;
-
-                cv::Mat Rcw(3,3,CV_64F,mRi);
-                cv::Mat tcw(3,1,CV_64F,mti);
-                Rcw.convertTo(Rcw,CV_32F);
-                tcw.convertTo(tcw,CV_32F);
-                mBestTcw = cv::Mat::eye(4,4,CV_32F);
-                Rcw.copyTo(mBestTcw.rowRange(0,3).colRange(0,3));
-                tcw.copyTo(mBestTcw.rowRange(0,3).col(3));
-            }
-
-            if(Refine())
-            {
-                nInliers = mnRefinedInliers;
-                vbInliers = vector<bool>(mvpMapPointMatches.size(),false);
-                for(int i=0; i<N; i++)
-                {
-                    if(mvbRefinedInliers[i])
-                        vbInliers[mvKeyPointIndices[i]] = true;
-                }
-                return mRefinedTcw.clone();
-            }
+          mvbBestInliers = mvbInliersi;
+          mnBestInliers = mnInliersi;
+
+          cv::Mat Rcw(3, 3, CV_64F, mRi);
+          cv::Mat tcw(3, 1, CV_64F, mti);
+          Rcw.convertTo(Rcw, CV_32F);
+          tcw.convertTo(tcw, CV_32F);
+          mBestTcw = cv::Mat::eye(4, 4, CV_32F);
+          Rcw.copyTo(mBestTcw.rowRange(0, 3).colRange(0, 3));
+          tcw.copyTo(mBestTcw.rowRange(0, 3).col(3));
+        }
 
+        if (Refine())
+        {
+          nInliers = mnRefinedInliers;
+          vbInliers = vector<bool>(mvpMapPointMatches.size(), false);
+          for (int i = 0; i < N; i++)
+          {
+            if (mvbRefinedInliers[i])
+              vbInliers[mvKeyPointIndices[i]] = true;
+          }
+          return mRefinedTcw.clone();
         }
+      }
     }
 
-    if(mnIterations>=mRansacMaxIts)
+    if (mnIterations >= mRansacMaxIts)
     {
-        bNoMore=true;
-        if(mnBestInliers>=mRansacMinInliers)
+      bNoMore = true;
+      if (mnBestInliers >= mRansacMinInliers)
+      {
+        nInliers = mnBestInliers;
+        vbInliers = vector<bool>(mvpMapPointMatches.size(), false);
+        for (int i = 0; i < N; i++)
         {
-            nInliers=mnBestInliers;
-            vbInliers = vector<bool>(mvpMapPointMatches.size(),false);
-            for(int i=0; i<N; i++)
-            {
-                if(mvbBestInliers[i])
-                    vbInliers[mvKeyPointIndices[i]] = true;
-            }
-            return mBestTcw.clone();
+          if (mvbBestInliers[i])
+            vbInliers[mvKeyPointIndices[i]] = true;
         }
+        return mBestTcw.clone();
+      }
     }
 
     return cv::Mat();
-}
+  }
 
-bool PnPsolver::Refine()
-{
+  bool PnPsolver::Refine()
+  {
     vector<int> vIndices;
     vIndices.reserve(mvbBestInliers.size());
 
-    for(size_t i=0; i<mvbBestInliers.size(); i++)
+    for (size_t i = 0; i < mvbBestInliers.size(); i++)
     {
-        if(mvbBestInliers[i])
-        {
-            vIndices.push_back(i);
-        }
+      if (mvbBestInliers[i])
+      {
+        vIndices.push_back(i);
+      }
     }
 
     set_maximum_number_of_correspondences(vIndices.size());
 
     reset_correspondences();
 
-    for(size_t i=0; i<vIndices.size(); i++)
+    for (size_t i = 0; i < vIndices.size(); i++)
     {
-        int idx = vIndices[i];
-        add_correspondence(mvP3Dw[idx].x,mvP3Dw[idx].y,mvP3Dw[idx].z,mvP2D[idx].x,mvP2D[idx].y);
+      int idx = vIndices[i];
+      add_correspondence(mvP3Dw[idx].x, mvP3Dw[idx].y, mvP3Dw[idx].z, mvP2D[idx].x, mvP2D[idx].y);
     }
 
     // Compute camera pose
@@ -288,738 +285,786 @@ bool PnPsolver::Refine()
     // Check inliers
     CheckInliers();
 
-    mnRefinedInliers =mnInliersi;
+    mnRefinedInliers = mnInliersi;
     mvbRefinedInliers = mvbInliersi;
 
-    if(mnInliersi>mRansacMinInliers)
+    if (mnInliersi > mRansacMinInliers)
     {
-        cv::Mat Rcw(3,3,CV_64F,mRi);
-        cv::Mat tcw(3,1,CV_64F,mti);
-        Rcw.convertTo(Rcw,CV_32F);
-        tcw.convertTo(tcw,CV_32F);
-        mRefinedTcw = cv::Mat::eye(4,4,CV_32F);
-        Rcw.copyTo(mRefinedTcw.rowRange(0,3).colRange(0,3));
-        tcw.copyTo(mRefinedTcw.rowRange(0,3).col(3));
-        return true;
+      cv::Mat Rcw(3, 3, CV_64F, mRi);
+      cv::Mat tcw(3, 1, CV_64F, mti);
+      Rcw.convertTo(Rcw, CV_32F);
+      tcw.convertTo(tcw, CV_32F);
+      mRefinedTcw = cv::Mat::eye(4, 4, CV_32F);
+      Rcw.copyTo(mRefinedTcw.rowRange(0, 3).colRange(0, 3));
+      tcw.copyTo(mRefinedTcw.rowRange(0, 3).col(3));
+      return true;
     }
 
     return false;
-}
-
+  }
 
-void PnPsolver::CheckInliers()
-{
-    mnInliersi=0;
+  void PnPsolver::CheckInliers()
+  {
+    mnInliersi = 0;
 
-    for(int i=0; i<N; i++)
+    for (int i = 0; i < N; i++)
     {
-        cv::Point3f P3Dw = mvP3Dw[i];
-        cv::Point2f P2D = mvP2D[i];
+      cv::Point3f P3Dw = mvP3Dw[i];
+      cv::Point2f P2D = mvP2D[i];
 
-        float Xc = mRi[0][0]*P3Dw.x+mRi[0][1]*P3Dw.y+mRi[0][2]*P3Dw.z+mti[0];
-        float Yc = mRi[1][0]*P3Dw.x+mRi[1][1]*P3Dw.y+mRi[1][2]*P3Dw.z+mti[1];
-        float invZc = 1/(mRi[2][0]*P3Dw.x+mRi[2][1]*P3Dw.y+mRi[2][2]*P3Dw.z+mti[2]);
+      float Xc = mRi[0][0] * P3Dw.x + mRi[0][1] * P3Dw.y + mRi[0][2] * P3Dw.z + mti[0];
+      float Yc = mRi[1][0] * P3Dw.x + mRi[1][1] * P3Dw.y + mRi[1][2] * P3Dw.z + mti[1];
+      float invZc = 1 / (mRi[2][0] * P3Dw.x + mRi[2][1] * P3Dw.y + mRi[2][2] * P3Dw.z + mti[2]);
 
-        double ue = uc + fu * Xc * invZc;
-        double ve = vc + fv * Yc * invZc;
+      double ue = uc + fu * Xc * invZc;
+      double ve = vc + fv * Yc * invZc;
 
-        float distX = P2D.x-ue;
-        float distY = P2D.y-ve;
+      float distX = P2D.x - ue;
+      float distY = P2D.y - ve;
 
-        float error2 = distX*distX+distY*distY;
+      float error2 = distX * distX + distY * distY;
 
-        if(error2<mvMaxError[i])
-        {
+      if (error2 < mvMaxError[i])
+      {
 
-            mvbInliersi[i]=true;
-            mnInliersi++;
-        }
-        else
-        {
-            mvbInliersi[i]=false;
-        }
+        mvbInliersi[i] = true;
+        mnInliersi++;
+      }
+      else
+      {
+        mvbInliersi[i] = false;
+      }
     }
-}
+  }
 
+  void PnPsolver::set_maximum_number_of_correspondences(int n)
+  {
+    if (maximum_number_of_correspondences < n)
+    {
+      if (pws != 0)
+        delete[] pws;
+      if (us != 0)
+        delete[] us;
+      if (alphas != 0)
+        delete[] alphas;
+      if (pcs != 0)
+        delete[] pcs;
+
+      maximum_number_of_correspondences = n;
+      pws = new double[3 * maximum_number_of_correspondences];
+      us = new double[2 * maximum_number_of_correspondences];
+      alphas = new double[4 * maximum_number_of_correspondences];
+      pcs = new double[3 * maximum_number_of_correspondences];
+    }
+  }
 
-void PnPsolver::set_maximum_number_of_correspondences(int n)
-{
-  if (maximum_number_of_correspondences < n) {
-    if (pws != 0) delete [] pws;
-    if (us != 0) delete [] us;
-    if (alphas != 0) delete [] alphas;
-    if (pcs != 0) delete [] pcs;
-
-    maximum_number_of_correspondences = n;
-    pws = new double[3 * maximum_number_of_correspondences];
-    us = new double[2 * maximum_number_of_correspondences];
-    alphas = new double[4 * maximum_number_of_correspondences];
-    pcs = new double[3 * maximum_number_of_correspondences];
+  void PnPsolver::reset_correspondences(void)
+  {
+    number_of_correspondences = 0;
   }
-}
 
-void PnPsolver::reset_correspondences(void)
-{
-  number_of_correspondences = 0;
-}
+  void PnPsolver::add_correspondence(double X, double Y, double Z, double u, double v)
+  {
+    pws[3 * number_of_correspondences] = X;
+    pws[3 * number_of_correspondences + 1] = Y;
+    pws[3 * number_of_correspondences + 2] = Z;
 
-void PnPsolver::add_correspondence(double X, double Y, double Z, double u, double v)
-{
-  pws[3 * number_of_correspondences    ] = X;
-  pws[3 * number_of_correspondences + 1] = Y;
-  pws[3 * number_of_correspondences + 2] = Z;
+    us[2 * number_of_correspondences] = u;
+    us[2 * number_of_correspondences + 1] = v;
 
-  us[2 * number_of_correspondences    ] = u;
-  us[2 * number_of_correspondences + 1] = v;
+    number_of_correspondences++;
+  }
 
-  number_of_correspondences++;
-}
+  void PnPsolver::choose_control_points(void)
+  {
+    // Take C0 as the reference points centroid:
+    cws[0][0] = cws[0][1] = cws[0][2] = 0;
+    for (int i = 0; i < number_of_correspondences; i++)
+      for (int j = 0; j < 3; j++)
+        cws[0][j] += pws[3 * i + j];
 
-void PnPsolver::choose_control_points(void)
-{
-  // Take C0 as the reference points centroid:
-  cws[0][0] = cws[0][1] = cws[0][2] = 0;
-  for(int i = 0; i < number_of_correspondences; i++)
-    for(int j = 0; j < 3; j++)
-      cws[0][j] += pws[3 * i + j];
+    for (int j = 0; j < 3; j++)
+      cws[0][j] /= number_of_correspondences;
 
-  for(int j = 0; j < 3; j++)
-    cws[0][j] /= number_of_correspondences;
+    // Take C1, C2, and C3 from PCA on the reference points:
+    CvMat *PW0 = cvCreateMat(number_of_correspondences, 3, CV_64F);
 
+    double pw0tpw0[3 * 3], dc[3], uct[3 * 3];
+    CvMat PW0tPW0 = cvMat(3, 3, CV_64F, pw0tpw0);
+    CvMat DC = cvMat(3, 1, CV_64F, dc);
+    CvMat UCt = cvMat(3, 3, CV_64F, uct);
 
-  // Take C1, C2, and C3 from PCA on the reference points:
-  CvMat * PW0 = cvCreateMat(number_of_correspondences, 3, CV_64F);
+    for (int i = 0; i < number_of_correspondences; i++)
+      for (int j = 0; j < 3; j++)
+        PW0->data.db[3 * i + j] = pws[3 * i + j] - cws[0][j];
 
-  double pw0tpw0[3 * 3], dc[3], uct[3 * 3];
-  CvMat PW0tPW0 = cvMat(3, 3, CV_64F, pw0tpw0);
-  CvMat DC      = cvMat(3, 1, CV_64F, dc);
-  CvMat UCt     = cvMat(3, 3, CV_64F, uct);
+    cvMulTransposed(PW0, &PW0tPW0, 1);
+    cvSVD(&PW0tPW0, &DC, &UCt, 0, CV_SVD_MODIFY_A | CV_SVD_U_T);
 
-  for(int i = 0; i < number_of_correspondences; i++)
-    for(int j = 0; j < 3; j++)
-      PW0->data.db[3 * i + j] = pws[3 * i + j] - cws[0][j];
+    cvReleaseMat(&PW0);
 
-  cvMulTransposed(PW0, &PW0tPW0, 1);
-  cvSVD(&PW0tPW0, &DC, &UCt, 0, CV_SVD_MODIFY_A | CV_SVD_U_T);
+    for (int i = 1; i < 4; i++)
+    {
+      double k = sqrt(dc[i - 1] / number_of_correspondences);
+      for (int j = 0; j < 3; j++)
+        cws[i][j] = cws[0][j] + k * uct[3 * (i - 1) + j];
+    }
+  }
 
-  cvReleaseMat(&PW0);
+  void PnPsolver::compute_barycentric_coordinates(void)
+  {
+    double cc[3 * 3], cc_inv[3 * 3];
+    CvMat CC = cvMat(3, 3, CV_64F, cc);
+    CvMat CC_inv = cvMat(3, 3, CV_64F, cc_inv);
 
-  for(int i = 1; i < 4; i++) {
-    double k = sqrt(dc[i - 1] / number_of_correspondences);
-    for(int j = 0; j < 3; j++)
-      cws[i][j] = cws[0][j] + k * uct[3 * (i - 1) + j];
-  }
-}
+    for (int i = 0; i < 3; i++)
+      for (int j = 1; j < 4; j++)
+        cc[3 * i + j - 1] = cws[j][i] - cws[0][i];
 
-void PnPsolver::compute_barycentric_coordinates(void)
-{
-  double cc[3 * 3], cc_inv[3 * 3];
-  CvMat CC     = cvMat(3, 3, CV_64F, cc);
-  CvMat CC_inv = cvMat(3, 3, CV_64F, cc_inv);
-
-  for(int i = 0; i < 3; i++)
-    for(int j = 1; j < 4; j++)
-      cc[3 * i + j - 1] = cws[j][i] - cws[0][i];
-
-  cvInvert(&CC, &CC_inv, CV_SVD);
-  double * ci = cc_inv;
-  for(int i = 0; i < number_of_correspondences; i++) {
-    double * pi = pws + 3 * i;
-    double * a = alphas + 4 * i;
-
-    for(int j = 0; j < 3; j++)
-      a[1 + j] =
-	ci[3 * j    ] * (pi[0] - cws[0][0]) +
-	ci[3 * j + 1] * (pi[1] - cws[0][1]) +
-	ci[3 * j + 2] * (pi[2] - cws[0][2]);
-    a[0] = 1.0f - a[1] - a[2] - a[3];
+    cvInvert(&CC, &CC_inv, CV_SVD);
+    double *ci = cc_inv;
+    for (int i = 0; i < number_of_correspondences; i++)
+    {
+      double *pi = pws + 3 * i;
+      double *a = alphas + 4 * i;
+
+      for (int j = 0; j < 3; j++)
+        a[1 + j] =
+            ci[3 * j] * (pi[0] - cws[0][0]) +
+            ci[3 * j + 1] * (pi[1] - cws[0][1]) +
+            ci[3 * j + 2] * (pi[2] - cws[0][2]);
+      a[0] = 1.0f - a[1] - a[2] - a[3];
+    }
   }
-}
 
-void PnPsolver::fill_M(CvMat * M,
-		  const int row, const double * as, const double u, const double v)
-{
-  double * M1 = M->data.db + row * 12;
-  double * M2 = M1 + 12;
+  void PnPsolver::fill_M(CvMat *M,
+                         const int row, const double *as, const double u, const double v)
+  {
+    double *M1 = M->data.db + row * 12;
+    double *M2 = M1 + 12;
 
-  for(int i = 0; i < 4; i++) {
-    M1[3 * i    ] = as[i] * fu;
-    M1[3 * i + 1] = 0.0;
-    M1[3 * i + 2] = as[i] * (uc - u);
+    for (int i = 0; i < 4; i++)
+    {
+      M1[3 * i] = as[i] * fu;
+      M1[3 * i + 1] = 0.0;
+      M1[3 * i + 2] = as[i] * (uc - u);
 
-    M2[3 * i    ] = 0.0;
-    M2[3 * i + 1] = as[i] * fv;
-    M2[3 * i + 2] = as[i] * (vc - v);
+      M2[3 * i] = 0.0;
+      M2[3 * i + 1] = as[i] * fv;
+      M2[3 * i + 2] = as[i] * (vc - v);
+    }
   }
-}
 
-void PnPsolver::compute_ccs(const double * betas, const double * ut)
-{
-  for(int i = 0; i < 4; i++)
-    ccs[i][0] = ccs[i][1] = ccs[i][2] = 0.0f;
-
-  for(int i = 0; i < 4; i++) {
-    const double * v = ut + 12 * (11 - i);
-    for(int j = 0; j < 4; j++)
-      for(int k = 0; k < 3; k++)
-	ccs[j][k] += betas[i] * v[3 * j + k];
+  void PnPsolver::compute_ccs(const double *betas, const double *ut)
+  {
+    for (int i = 0; i < 4; i++)
+      ccs[i][0] = ccs[i][1] = ccs[i][2] = 0.0f;
+
+    for (int i = 0; i < 4; i++)
+    {
+      const double *v = ut + 12 * (11 - i);
+      for (int j = 0; j < 4; j++)
+        for (int k = 0; k < 3; k++)
+          ccs[j][k] += betas[i] * v[3 * j + k];
+    }
   }
-}
 
-void PnPsolver::compute_pcs(void)
-{
-  for(int i = 0; i < number_of_correspondences; i++) {
-    double * a = alphas + 4 * i;
-    double * pc = pcs + 3 * i;
+  void PnPsolver::compute_pcs(void)
+  {
+    for (int i = 0; i < number_of_correspondences; i++)
+    {
+      double *a = alphas + 4 * i;
+      double *pc = pcs + 3 * i;
 
-    for(int j = 0; j < 3; j++)
-      pc[j] = a[0] * ccs[0][j] + a[1] * ccs[1][j] + a[2] * ccs[2][j] + a[3] * ccs[3][j];
+      for (int j = 0; j < 3; j++)
+        pc[j] = a[0] * ccs[0][j] + a[1] * ccs[1][j] + a[2] * ccs[2][j] + a[3] * ccs[3][j];
+    }
   }
-}
 
-double PnPsolver::compute_pose(double R[3][3], double t[3])
-{
-  choose_control_points();
-  compute_barycentric_coordinates();
+  double PnPsolver::compute_pose(double R[3][3], double t[3])
+  {
+    choose_control_points();
+    compute_barycentric_coordinates();
 
-  CvMat * M = cvCreateMat(2 * number_of_correspondences, 12, CV_64F);
+    CvMat *M = cvCreateMat(2 * number_of_correspondences, 12, CV_64F);
 
-  for(int i = 0; i < number_of_correspondences; i++)
-    fill_M(M, 2 * i, alphas + 4 * i, us[2 * i], us[2 * i + 1]);
+    for (int i = 0; i < number_of_correspondences; i++)
+      fill_M(M, 2 * i, alphas + 4 * i, us[2 * i], us[2 * i + 1]);
 
-  double mtm[12 * 12], d[12], ut[12 * 12];
-  CvMat MtM = cvMat(12, 12, CV_64F, mtm);
-  CvMat D   = cvMat(12,  1, CV_64F, d);
-  CvMat Ut  = cvMat(12, 12, CV_64F, ut);
+    double mtm[12 * 12], d[12], ut[12 * 12];
+    CvMat MtM = cvMat(12, 12, CV_64F, mtm);
+    CvMat D = cvMat(12, 1, CV_64F, d);
+    CvMat Ut = cvMat(12, 12, CV_64F, ut);
 
-  cvMulTransposed(M, &MtM, 1);
-  cvSVD(&MtM, &D, &Ut, 0, CV_SVD_MODIFY_A | CV_SVD_U_T);
-  cvReleaseMat(&M);
+    cvMulTransposed(M, &MtM, 1);
+    cvSVD(&MtM, &D, &Ut, 0, CV_SVD_MODIFY_A | CV_SVD_U_T);
+    cvReleaseMat(&M);
 
-  double l_6x10[6 * 10], rho[6];
-  CvMat L_6x10 = cvMat(6, 10, CV_64F, l_6x10);
-  CvMat Rho    = cvMat(6,  1, CV_64F, rho);
+    double l_6x10[6 * 10], rho[6];
+    CvMat L_6x10 = cvMat(6, 10, CV_64F, l_6x10);
+    CvMat Rho = cvMat(6, 1, CV_64F, rho);
 
-  compute_L_6x10(ut, l_6x10);
-  compute_rho(rho);
+    compute_L_6x10(ut, l_6x10);
+    compute_rho(rho);
 
-  double Betas[4][4], rep_errors[4];
-  double Rs[4][3][3], ts[4][3];
+    double Betas[4][4], rep_errors[4];
+    double Rs[4][3][3], ts[4][3];
 
-  find_betas_approx_1(&L_6x10, &Rho, Betas[1]);
-  gauss_newton(&L_6x10, &Rho, Betas[1]);
-  rep_errors[1] = compute_R_and_t(ut, Betas[1], Rs[1], ts[1]);
+    find_betas_approx_1(&L_6x10, &Rho, Betas[1]);
+    gauss_newton(&L_6x10, &Rho, Betas[1]);
+    rep_errors[1] = compute_R_and_t(ut, Betas[1], Rs[1], ts[1]);
 
-  find_betas_approx_2(&L_6x10, &Rho, Betas[2]);
-  gauss_newton(&L_6x10, &Rho, Betas[2]);
-  rep_errors[2] = compute_R_and_t(ut, Betas[2], Rs[2], ts[2]);
+    find_betas_approx_2(&L_6x10, &Rho, Betas[2]);
+    gauss_newton(&L_6x10, &Rho, Betas[2]);
+    rep_errors[2] = compute_R_and_t(ut, Betas[2], Rs[2], ts[2]);
 
-  find_betas_approx_3(&L_6x10, &Rho, Betas[3]);
-  gauss_newton(&L_6x10, &Rho, Betas[3]);
-  rep_errors[3] = compute_R_and_t(ut, Betas[3], Rs[3], ts[3]);
+    find_betas_approx_3(&L_6x10, &Rho, Betas[3]);
+    gauss_newton(&L_6x10, &Rho, Betas[3]);
+    rep_errors[3] = compute_R_and_t(ut, Betas[3], Rs[3], ts[3]);
 
-  int N = 1;
-  if (rep_errors[2] < rep_errors[1]) N = 2;
-  if (rep_errors[3] < rep_errors[N]) N = 3;
+    int N = 1;
+    if (rep_errors[2] < rep_errors[1])
+      N = 2;
+    if (rep_errors[3] < rep_errors[N])
+      N = 3;
 
-  copy_R_and_t(Rs[N], ts[N], R, t);
+    copy_R_and_t(Rs[N], ts[N], R, t);
 
-  return rep_errors[N];
-}
+    return rep_errors[N];
+  }
 
-void PnPsolver::copy_R_and_t(const double R_src[3][3], const double t_src[3],
-			double R_dst[3][3], double t_dst[3])
-{
-  for(int i = 0; i < 3; i++) {
-    for(int j = 0; j < 3; j++)
-      R_dst[i][j] = R_src[i][j];
-    t_dst[i] = t_src[i];
+  void PnPsolver::copy_R_and_t(const double R_src[3][3], const double t_src[3],
+                               double R_dst[3][3], double t_dst[3])
+  {
+    for (int i = 0; i < 3; i++)
+    {
+      for (int j = 0; j < 3; j++)
+        R_dst[i][j] = R_src[i][j];
+      t_dst[i] = t_src[i];
+    }
   }
-}
 
-double PnPsolver::dist2(const double * p1, const double * p2)
-{
-  return
-    (p1[0] - p2[0]) * (p1[0] - p2[0]) +
-    (p1[1] - p2[1]) * (p1[1] - p2[1]) +
-    (p1[2] - p2[2]) * (p1[2] - p2[2]);
-}
+  double PnPsolver::dist2(const double *p1, const double *p2)
+  {
+    return (p1[0] - p2[0]) * (p1[0] - p2[0]) +
+           (p1[1] - p2[1]) * (p1[1] - p2[1]) +
+           (p1[2] - p2[2]) * (p1[2] - p2[2]);
+  }
 
-double PnPsolver::dot(const double * v1, const double * v2)
-{
-  return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
-}
+  double PnPsolver::dot(const double *v1, const double *v2)
+  {
+    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
+  }
 
-double PnPsolver::reprojection_error(const double R[3][3], const double t[3])
-{
-  double sum2 = 0.0;
-
-  for(int i = 0; i < number_of_correspondences; i++) {
-    double * pw = pws + 3 * i;
-    double Xc = dot(R[0], pw) + t[0];
-    double Yc = dot(R[1], pw) + t[1];
-    double inv_Zc = 1.0 / (dot(R[2], pw) + t[2]);
-    double ue = uc + fu * Xc * inv_Zc;
-    double ve = vc + fv * Yc * inv_Zc;
-    double u = us[2 * i], v = us[2 * i + 1];
-
-    sum2 += sqrt( (u - ue) * (u - ue) + (v - ve) * (v - ve) );
+  double PnPsolver::reprojection_error(const double R[3][3], const double t[3])
+  {
+    double sum2 = 0.0;
+
+    for (int i = 0; i < number_of_correspondences; i++)
+    {
+      double *pw = pws + 3 * i;
+      double Xc = dot(R[0], pw) + t[0];
+      double Yc = dot(R[1], pw) + t[1];
+      double inv_Zc = 1.0 / (dot(R[2], pw) + t[2]);
+      double ue = uc + fu * Xc * inv_Zc;
+      double ve = vc + fv * Yc * inv_Zc;
+      double u = us[2 * i], v = us[2 * i + 1];
+
+      sum2 += sqrt((u - ue) * (u - ue) + (v - ve) * (v - ve));
+    }
+
+    return sum2 / number_of_correspondences;
   }
 
-  return sum2 / number_of_correspondences;
-}
+  void PnPsolver::estimate_R_and_t(double R[3][3], double t[3])
+  {
+    double pc0[3], pw0[3];
 
-void PnPsolver::estimate_R_and_t(double R[3][3], double t[3])
-{
-  double pc0[3], pw0[3];
+    pc0[0] = pc0[1] = pc0[2] = 0.0;
+    pw0[0] = pw0[1] = pw0[2] = 0.0;
+
+    for (int i = 0; i < number_of_correspondences; i++)
+    {
+      const double *pc = pcs + 3 * i;
+      const double *pw = pws + 3 * i;
+
+      for (int j = 0; j < 3; j++)
+      {
+        pc0[j] += pc[j];
+        pw0[j] += pw[j];
+      }
+    }
+    for (int j = 0; j < 3; j++)
+    {
+      pc0[j] /= number_of_correspondences;
+      pw0[j] /= number_of_correspondences;
+    }
+
+    double abt[3 * 3], abt_d[3], abt_u[3 * 3], abt_v[3 * 3];
+    CvMat ABt = cvMat(3, 3, CV_64F, abt);
+    CvMat ABt_D = cvMat(3, 1, CV_64F, abt_d);
+    CvMat ABt_U = cvMat(3, 3, CV_64F, abt_u);
+    CvMat ABt_V = cvMat(3, 3, CV_64F, abt_v);
+
+    cvSetZero(&ABt);
+    for (int i = 0; i < number_of_correspondences; i++)
+    {
+      double *pc = pcs + 3 * i;
+      double *pw = pws + 3 * i;
+
+      for (int j = 0; j < 3; j++)
+      {
+        abt[3 * j] += (pc[j] - pc0[j]) * (pw[0] - pw0[0]);
+        abt[3 * j + 1] += (pc[j] - pc0[j]) * (pw[1] - pw0[1]);
+        abt[3 * j + 2] += (pc[j] - pc0[j]) * (pw[2] - pw0[2]);
+      }
+    }
 
-  pc0[0] = pc0[1] = pc0[2] = 0.0;
-  pw0[0] = pw0[1] = pw0[2] = 0.0;
+    cvSVD(&ABt, &ABt_D, &ABt_U, &ABt_V, CV_SVD_MODIFY_A);
 
-  for(int i = 0; i < number_of_correspondences; i++) {
-    const double * pc = pcs + 3 * i;
-    const double * pw = pws + 3 * i;
+    for (int i = 0; i < 3; i++)
+      for (int j = 0; j < 3; j++)
+        R[i][j] = dot(abt_u + 3 * i, abt_v + 3 * j);
 
-    for(int j = 0; j < 3; j++) {
-      pc0[j] += pc[j];
-      pw0[j] += pw[j];
+    const double det =
+        R[0][0] * R[1][1] * R[2][2] + R[0][1] * R[1][2] * R[2][0] + R[0][2] * R[1][0] * R[2][1] -
+        R[0][2] * R[1][1] * R[2][0] - R[0][1] * R[1][0] * R[2][2] - R[0][0] * R[1][2] * R[2][1];
+
+    if (det < 0)
+    {
+      R[2][0] = -R[2][0];
+      R[2][1] = -R[2][1];
+      R[2][2] = -R[2][2];
     }
+
+    t[0] = pc0[0] - dot(R[0], pw0);
+    t[1] = pc0[1] - dot(R[1], pw0);
+    t[2] = pc0[2] - dot(R[2], pw0);
   }
-  for(int j = 0; j < 3; j++) {
-    pc0[j] /= number_of_correspondences;
-    pw0[j] /= number_of_correspondences;
+
+  void PnPsolver::print_pose(const double R[3][3], const double t[3])
+  {
+    cout << R[0][0] << " " << R[0][1] << " " << R[0][2] << " " << t[0] << endl;
+    cout << R[1][0] << " " << R[1][1] << " " << R[1][2] << " " << t[1] << endl;
+    cout << R[2][0] << " " << R[2][1] << " " << R[2][2] << " " << t[2] << endl;
   }
 
-  double abt[3 * 3], abt_d[3], abt_u[3 * 3], abt_v[3 * 3];
-  CvMat ABt   = cvMat(3, 3, CV_64F, abt);
-  CvMat ABt_D = cvMat(3, 1, CV_64F, abt_d);
-  CvMat ABt_U = cvMat(3, 3, CV_64F, abt_u);
-  CvMat ABt_V = cvMat(3, 3, CV_64F, abt_v);
-
-  cvSetZero(&ABt);
-  for(int i = 0; i < number_of_correspondences; i++) {
-    double * pc = pcs + 3 * i;
-    double * pw = pws + 3 * i;
-
-    for(int j = 0; j < 3; j++) {
-      abt[3 * j    ] += (pc[j] - pc0[j]) * (pw[0] - pw0[0]);
-      abt[3 * j + 1] += (pc[j] - pc0[j]) * (pw[1] - pw0[1]);
-      abt[3 * j + 2] += (pc[j] - pc0[j]) * (pw[2] - pw0[2]);
+  void PnPsolver::solve_for_sign(void)
+  {
+    if (pcs[2] < 0.0)
+    {
+      for (int i = 0; i < 4; i++)
+        for (int j = 0; j < 3; j++)
+          ccs[i][j] = -ccs[i][j];
+
+      for (int i = 0; i < number_of_correspondences; i++)
+      {
+        pcs[3 * i] = -pcs[3 * i];
+        pcs[3 * i + 1] = -pcs[3 * i + 1];
+        pcs[3 * i + 2] = -pcs[3 * i + 2];
+      }
     }
   }
 
-  cvSVD(&ABt, &ABt_D, &ABt_U, &ABt_V, CV_SVD_MODIFY_A);
+  double PnPsolver::compute_R_and_t(const double *ut, const double *betas,
+                                    double R[3][3], double t[3])
+  {
+    compute_ccs(betas, ut);
+    compute_pcs();
 
-  for(int i = 0; i < 3; i++)
-    for(int j = 0; j < 3; j++)
-      R[i][j] = dot(abt_u + 3 * i, abt_v + 3 * j);
+    solve_for_sign();
 
-  const double det =
-    R[0][0] * R[1][1] * R[2][2] + R[0][1] * R[1][2] * R[2][0] + R[0][2] * R[1][0] * R[2][1] -
-    R[0][2] * R[1][1] * R[2][0] - R[0][1] * R[1][0] * R[2][2] - R[0][0] * R[1][2] * R[2][1];
+    estimate_R_and_t(R, t);
 
-  if (det < 0) {
-    R[2][0] = -R[2][0];
-    R[2][1] = -R[2][1];
-    R[2][2] = -R[2][2];
+    return reprojection_error(R, t);
   }
 
-  t[0] = pc0[0] - dot(R[0], pw0);
-  t[1] = pc0[1] - dot(R[1], pw0);
-  t[2] = pc0[2] - dot(R[2], pw0);
-}
+  // betas10        = [B11 B12 B22 B13 B23 B33 B14 B24 B34 B44]
+  // betas_approx_1 = [B11 B12     B13         B14]
 
-void PnPsolver::print_pose(const double R[3][3], const double t[3])
-{
-  cout << R[0][0] << " " << R[0][1] << " " << R[0][2] << " " << t[0] << endl;
-  cout << R[1][0] << " " << R[1][1] << " " << R[1][2] << " " << t[1] << endl;
-  cout << R[2][0] << " " << R[2][1] << " " << R[2][2] << " " << t[2] << endl;
-}
+  void PnPsolver::find_betas_approx_1(const CvMat *L_6x10, const CvMat *Rho,
+                                      double *betas)
+  {
+    double l_6x4[6 * 4], b4[4];
+    CvMat L_6x4 = cvMat(6, 4, CV_64F, l_6x4);
+    CvMat B4 = cvMat(4, 1, CV_64F, b4);
 
-void PnPsolver::solve_for_sign(void)
-{
-  if (pcs[2] < 0.0) {
-    for(int i = 0; i < 4; i++)
-      for(int j = 0; j < 3; j++)
-	ccs[i][j] = -ccs[i][j];
-
-    for(int i = 0; i < number_of_correspondences; i++) {
-      pcs[3 * i    ] = -pcs[3 * i];
-      pcs[3 * i + 1] = -pcs[3 * i + 1];
-      pcs[3 * i + 2] = -pcs[3 * i + 2];
+    for (int i = 0; i < 6; i++)
+    {
+      cvmSet(&L_6x4, i, 0, cvmGet(L_6x10, i, 0));
+      cvmSet(&L_6x4, i, 1, cvmGet(L_6x10, i, 1));
+      cvmSet(&L_6x4, i, 2, cvmGet(L_6x10, i, 3));
+      cvmSet(&L_6x4, i, 3, cvmGet(L_6x10, i, 6));
     }
-  }
-}
 
-double PnPsolver::compute_R_and_t(const double * ut, const double * betas,
-			     double R[3][3], double t[3])
-{
-  compute_ccs(betas, ut);
-  compute_pcs();
+    cvSolve(&L_6x4, Rho, &B4, CV_SVD);
 
-  solve_for_sign();
+    if (b4[0] < 0)
+    {
+      betas[0] = sqrt(-b4[0]);
+      betas[1] = -b4[1] / betas[0];
+      betas[2] = -b4[2] / betas[0];
+      betas[3] = -b4[3] / betas[0];
+    }
+    else
+    {
+      betas[0] = sqrt(b4[0]);
+      betas[1] = b4[1] / betas[0];
+      betas[2] = b4[2] / betas[0];
+      betas[3] = b4[3] / betas[0];
+    }
+  }
 
-  estimate_R_and_t(R, t);
+  // betas10        = [B11 B12 B22 B13 B23 B33 B14 B24 B34 B44]
+  // betas_approx_2 = [B11 B12 B22                            ]
 
-  return reprojection_error(R, t);
-}
+  void PnPsolver::find_betas_approx_2(const CvMat *L_6x10, const CvMat *Rho,
+                                      double *betas)
+  {
+    double l_6x3[6 * 3], b3[3];
+    CvMat L_6x3 = cvMat(6, 3, CV_64F, l_6x3);
+    CvMat B3 = cvMat(3, 1, CV_64F, b3);
 
-// betas10        = [B11 B12 B22 B13 B23 B33 B14 B24 B34 B44]
-// betas_approx_1 = [B11 B12     B13         B14]
+    for (int i = 0; i < 6; i++)
+    {
+      cvmSet(&L_6x3, i, 0, cvmGet(L_6x10, i, 0));
+      cvmSet(&L_6x3, i, 1, cvmGet(L_6x10, i, 1));
+      cvmSet(&L_6x3, i, 2, cvmGet(L_6x10, i, 2));
+    }
 
-void PnPsolver::find_betas_approx_1(const CvMat * L_6x10, const CvMat * Rho,
-			       double * betas)
-{
-  double l_6x4[6 * 4], b4[4];
-  CvMat L_6x4 = cvMat(6, 4, CV_64F, l_6x4);
-  CvMat B4    = cvMat(4, 1, CV_64F, b4);
-
-  for(int i = 0; i < 6; i++) {
-    cvmSet(&L_6x4, i, 0, cvmGet(L_6x10, i, 0));
-    cvmSet(&L_6x4, i, 1, cvmGet(L_6x10, i, 1));
-    cvmSet(&L_6x4, i, 2, cvmGet(L_6x10, i, 3));
-    cvmSet(&L_6x4, i, 3, cvmGet(L_6x10, i, 6));
-  }
+    cvSolve(&L_6x3, Rho, &B3, CV_SVD);
 
-  cvSolve(&L_6x4, Rho, &B4, CV_SVD);
-
-  if (b4[0] < 0) {
-    betas[0] = sqrt(-b4[0]);
-    betas[1] = -b4[1] / betas[0];
-    betas[2] = -b4[2] / betas[0];
-    betas[3] = -b4[3] / betas[0];
-  } else {
-    betas[0] = sqrt(b4[0]);
-    betas[1] = b4[1] / betas[0];
-    betas[2] = b4[2] / betas[0];
-    betas[3] = b4[3] / betas[0];
-  }
-}
+    if (b3[0] < 0)
+    {
+      betas[0] = sqrt(-b3[0]);
+      betas[1] = (b3[2] < 0) ? sqrt(-b3[2]) : 0.0;
+    }
+    else
+    {
+      betas[0] = sqrt(b3[0]);
+      betas[1] = (b3[2] > 0) ? sqrt(b3[2]) : 0.0;
+    }
 
-// betas10        = [B11 B12 B22 B13 B23 B33 B14 B24 B34 B44]
-// betas_approx_2 = [B11 B12 B22                            ]
+    if (b3[1] < 0)
+      betas[0] = -betas[0];
 
-void PnPsolver::find_betas_approx_2(const CvMat * L_6x10, const CvMat * Rho,
-			       double * betas)
-{
-  double l_6x3[6 * 3], b3[3];
-  CvMat L_6x3  = cvMat(6, 3, CV_64F, l_6x3);
-  CvMat B3     = cvMat(3, 1, CV_64F, b3);
-
-  for(int i = 0; i < 6; i++) {
-    cvmSet(&L_6x3, i, 0, cvmGet(L_6x10, i, 0));
-    cvmSet(&L_6x3, i, 1, cvmGet(L_6x10, i, 1));
-    cvmSet(&L_6x3, i, 2, cvmGet(L_6x10, i, 2));
+    betas[2] = 0.0;
+    betas[3] = 0.0;
   }
 
-  cvSolve(&L_6x3, Rho, &B3, CV_SVD);
+  // betas10        = [B11 B12 B22 B13 B23 B33 B14 B24 B34 B44]
+  // betas_approx_3 = [B11 B12 B22 B13 B23                    ]
 
-  if (b3[0] < 0) {
-    betas[0] = sqrt(-b3[0]);
-    betas[1] = (b3[2] < 0) ? sqrt(-b3[2]) : 0.0;
-  } else {
-    betas[0] = sqrt(b3[0]);
-    betas[1] = (b3[2] > 0) ? sqrt(b3[2]) : 0.0;
-  }
-
-  if (b3[1] < 0) betas[0] = -betas[0];
+  void PnPsolver::find_betas_approx_3(const CvMat *L_6x10, const CvMat *Rho,
+                                      double *betas)
+  {
+    double l_6x5[6 * 5], b5[5];
+    CvMat L_6x5 = cvMat(6, 5, CV_64F, l_6x5);
+    CvMat B5 = cvMat(5, 1, CV_64F, b5);
 
-  betas[2] = 0.0;
-  betas[3] = 0.0;
-}
+    for (int i = 0; i < 6; i++)
+    {
+      cvmSet(&L_6x5, i, 0, cvmGet(L_6x10, i, 0));
+      cvmSet(&L_6x5, i, 1, cvmGet(L_6x10, i, 1));
+      cvmSet(&L_6x5, i, 2, cvmGet(L_6x10, i, 2));
+      cvmSet(&L_6x5, i, 3, cvmGet(L_6x10, i, 3));
+      cvmSet(&L_6x5, i, 4, cvmGet(L_6x10, i, 4));
+    }
 
-// betas10        = [B11 B12 B22 B13 B23 B33 B14 B24 B34 B44]
-// betas_approx_3 = [B11 B12 B22 B13 B23                    ]
+    cvSolve(&L_6x5, Rho, &B5, CV_SVD);
 
-void PnPsolver::find_betas_approx_3(const CvMat * L_6x10, const CvMat * Rho,
-			       double * betas)
-{
-  double l_6x5[6 * 5], b5[5];
-  CvMat L_6x5 = cvMat(6, 5, CV_64F, l_6x5);
-  CvMat B5    = cvMat(5, 1, CV_64F, b5);
-
-  for(int i = 0; i < 6; i++) {
-    cvmSet(&L_6x5, i, 0, cvmGet(L_6x10, i, 0));
-    cvmSet(&L_6x5, i, 1, cvmGet(L_6x10, i, 1));
-    cvmSet(&L_6x5, i, 2, cvmGet(L_6x10, i, 2));
-    cvmSet(&L_6x5, i, 3, cvmGet(L_6x10, i, 3));
-    cvmSet(&L_6x5, i, 4, cvmGet(L_6x10, i, 4));
+    if (b5[0] < 0)
+    {
+      betas[0] = sqrt(-b5[0]);
+      betas[1] = (b5[2] < 0) ? sqrt(-b5[2]) : 0.0;
+    }
+    else
+    {
+      betas[0] = sqrt(b5[0]);
+      betas[1] = (b5[2] > 0) ? sqrt(b5[2]) : 0.0;
+    }
+    if (b5[1] < 0)
+      betas[0] = -betas[0];
+    betas[2] = b5[3] / betas[0];
+    betas[3] = 0.0;
   }
 
-  cvSolve(&L_6x5, Rho, &B5, CV_SVD);
+  void PnPsolver::compute_L_6x10(const double *ut, double *l_6x10)
+  {
+    const double *v[4];
 
-  if (b5[0] < 0) {
-    betas[0] = sqrt(-b5[0]);
-    betas[1] = (b5[2] < 0) ? sqrt(-b5[2]) : 0.0;
-  } else {
-    betas[0] = sqrt(b5[0]);
-    betas[1] = (b5[2] > 0) ? sqrt(b5[2]) : 0.0;
-  }
-  if (b5[1] < 0) betas[0] = -betas[0];
-  betas[2] = b5[3] / betas[0];
-  betas[3] = 0.0;
-}
+    v[0] = ut + 12 * 11;
+    v[1] = ut + 12 * 10;
+    v[2] = ut + 12 * 9;
+    v[3] = ut + 12 * 8;
 
-void PnPsolver::compute_L_6x10(const double * ut, double * l_6x10)
-{
-  const double * v[4];
-
-  v[0] = ut + 12 * 11;
-  v[1] = ut + 12 * 10;
-  v[2] = ut + 12 *  9;
-  v[3] = ut + 12 *  8;
-
-  double dv[4][6][3];
-
-  for(int i = 0; i < 4; i++) {
-    int a = 0, b = 1;
-    for(int j = 0; j < 6; j++) {
-      dv[i][j][0] = v[i][3 * a    ] - v[i][3 * b];
-      dv[i][j][1] = v[i][3 * a + 1] - v[i][3 * b + 1];
-      dv[i][j][2] = v[i][3 * a + 2] - v[i][3 * b + 2];
-
-      b++;
-      if (b > 3) {
-	a++;
-	b = a + 1;
+    double dv[4][6][3];
+
+    for (int i = 0; i < 4; i++)
+    {
+      int a = 0, b = 1;
+      for (int j = 0; j < 6; j++)
+      {
+        dv[i][j][0] = v[i][3 * a] - v[i][3 * b];
+        dv[i][j][1] = v[i][3 * a + 1] - v[i][3 * b + 1];
+        dv[i][j][2] = v[i][3 * a + 2] - v[i][3 * b + 2];
+
+        b++;
+        if (b > 3)
+        {
+          a++;
+          b = a + 1;
+        }
       }
     }
-  }
 
-  for(int i = 0; i < 6; i++) {
-    double * row = l_6x10 + 10 * i;
-
-    row[0] =        dot(dv[0][i], dv[0][i]);
-    row[1] = 2.0f * dot(dv[0][i], dv[1][i]);
-    row[2] =        dot(dv[1][i], dv[1][i]);
-    row[3] = 2.0f * dot(dv[0][i], dv[2][i]);
-    row[4] = 2.0f * dot(dv[1][i], dv[2][i]);
-    row[5] =        dot(dv[2][i], dv[2][i]);
-    row[6] = 2.0f * dot(dv[0][i], dv[3][i]);
-    row[7] = 2.0f * dot(dv[1][i], dv[3][i]);
-    row[8] = 2.0f * dot(dv[2][i], dv[3][i]);
-    row[9] =        dot(dv[3][i], dv[3][i]);
+    for (int i = 0; i < 6; i++)
+    {
+      double *row = l_6x10 + 10 * i;
+
+      row[0] = dot(dv[0][i], dv[0][i]);
+      row[1] = 2.0f * dot(dv[0][i], dv[1][i]);
+      row[2] = dot(dv[1][i], dv[1][i]);
+      row[3] = 2.0f * dot(dv[0][i], dv[2][i]);
+      row[4] = 2.0f * dot(dv[1][i], dv[2][i]);
+      row[5] = dot(dv[2][i], dv[2][i]);
+      row[6] = 2.0f * dot(dv[0][i], dv[3][i]);
+      row[7] = 2.0f * dot(dv[1][i], dv[3][i]);
+      row[8] = 2.0f * dot(dv[2][i], dv[3][i]);
+      row[9] = dot(dv[3][i], dv[3][i]);
+    }
   }
-}
 
-void PnPsolver::compute_rho(double * rho)
-{
-  rho[0] = dist2(cws[0], cws[1]);
-  rho[1] = dist2(cws[0], cws[2]);
-  rho[2] = dist2(cws[0], cws[3]);
-  rho[3] = dist2(cws[1], cws[2]);
-  rho[4] = dist2(cws[1], cws[3]);
-  rho[5] = dist2(cws[2], cws[3]);
-}
-
-void PnPsolver::compute_A_and_b_gauss_newton(const double * l_6x10, const double * rho,
-					double betas[4], CvMat * A, CvMat * b)
-{
-  for(int i = 0; i < 6; i++) {
-    const double * rowL = l_6x10 + i * 10;
-    double * rowA = A->data.db + i * 4;
-
-    rowA[0] = 2 * rowL[0] * betas[0] +     rowL[1] * betas[1] +     rowL[3] * betas[2] +     rowL[6] * betas[3];
-    rowA[1] =     rowL[1] * betas[0] + 2 * rowL[2] * betas[1] +     rowL[4] * betas[2] +     rowL[7] * betas[3];
-    rowA[2] =     rowL[3] * betas[0] +     rowL[4] * betas[1] + 2 * rowL[5] * betas[2] +     rowL[8] * betas[3];
-    rowA[3] =     rowL[6] * betas[0] +     rowL[7] * betas[1] +     rowL[8] * betas[2] + 2 * rowL[9] * betas[3];
-
-    cvmSet(b, i, 0, rho[i] -
-	   (
-	    rowL[0] * betas[0] * betas[0] +
-	    rowL[1] * betas[0] * betas[1] +
-	    rowL[2] * betas[1] * betas[1] +
-	    rowL[3] * betas[0] * betas[2] +
-	    rowL[4] * betas[1] * betas[2] +
-	    rowL[5] * betas[2] * betas[2] +
-	    rowL[6] * betas[0] * betas[3] +
-	    rowL[7] * betas[1] * betas[3] +
-	    rowL[8] * betas[2] * betas[3] +
-	    rowL[9] * betas[3] * betas[3]
-	    ));
+  void PnPsolver::compute_rho(double *rho)
+  {
+    rho[0] = dist2(cws[0], cws[1]);
+    rho[1] = dist2(cws[0], cws[2]);
+    rho[2] = dist2(cws[0], cws[3]);
+    rho[3] = dist2(cws[1], cws[2]);
+    rho[4] = dist2(cws[1], cws[3]);
+    rho[5] = dist2(cws[2], cws[3]);
   }
-}
-
-void PnPsolver::gauss_newton(const CvMat * L_6x10, const CvMat * Rho,
-			double betas[4])
-{
-  const int iterations_number = 5;
 
-  double a[6*4], b[6], x[4];
-  CvMat A = cvMat(6, 4, CV_64F, a);
-  CvMat B = cvMat(6, 1, CV_64F, b);
-  CvMat X = cvMat(4, 1, CV_64F, x);
+  void PnPsolver::compute_A_and_b_gauss_newton(const double *l_6x10, const double *rho,
+                                               double betas[4], CvMat *A, CvMat *b)
+  {
+    for (int i = 0; i < 6; i++)
+    {
+      const double *rowL = l_6x10 + i * 10;
+      double *rowA = A->data.db + i * 4;
 
-  for(int k = 0; k < iterations_number; k++) {
-    compute_A_and_b_gauss_newton(L_6x10->data.db, Rho->data.db,
-				 betas, &A, &B);
-    qr_solve(&A, &B, &X);
+      rowA[0] = 2 * rowL[0] * betas[0] + rowL[1] * betas[1] + rowL[3] * betas[2] + rowL[6] * betas[3];
+      rowA[1] = rowL[1] * betas[0] + 2 * rowL[2] * betas[1] + rowL[4] * betas[2] + rowL[7] * betas[3];
+      rowA[2] = rowL[3] * betas[0] + rowL[4] * betas[1] + 2 * rowL[5] * betas[2] + rowL[8] * betas[3];
+      rowA[3] = rowL[6] * betas[0] + rowL[7] * betas[1] + rowL[8] * betas[2] + 2 * rowL[9] * betas[3];
 
-    for(int i = 0; i < 4; i++)
-      betas[i] += x[i];
+      cvmSet(b, i, 0, rho[i] - (rowL[0] * betas[0] * betas[0] + rowL[1] * betas[0] * betas[1] + rowL[2] * betas[1] * betas[1] + rowL[3] * betas[0] * betas[2] + rowL[4] * betas[1] * betas[2] + rowL[5] * betas[2] * betas[2] + rowL[6] * betas[0] * betas[3] + rowL[7] * betas[1] * betas[3] + rowL[8] * betas[2] * betas[3] + rowL[9] * betas[3] * betas[3]));
+    }
   }
-}
 
-void PnPsolver::qr_solve(CvMat * A, CvMat * b, CvMat * X)
-{
-  static int max_nr = 0;
-  static double * A1, * A2;
+  void PnPsolver::gauss_newton(const CvMat *L_6x10, const CvMat *Rho,
+                               double betas[4])
+  {
+    const int iterations_number = 5;
 
-  const int nr = A->rows;
-  const int nc = A->cols;
+    double a[6 * 4], b[6], x[4];
+    CvMat A = cvMat(6, 4, CV_64F, a);
+    CvMat B = cvMat(6, 1, CV_64F, b);
+    CvMat X = cvMat(4, 1, CV_64F, x);
 
-  if (max_nr != 0 && max_nr < nr) {
-    delete [] A1;
-    delete [] A2;
-  }
-  if (max_nr < nr) {
-    max_nr = nr;
-    A1 = new double[nr];
-    A2 = new double[nr];
+    for (int k = 0; k < iterations_number; k++)
+    {
+      compute_A_and_b_gauss_newton(L_6x10->data.db, Rho->data.db,
+                                   betas, &A, &B);
+      qr_solve(&A, &B, &X);
+
+      for (int i = 0; i < 4; i++)
+        betas[i] += x[i];
+    }
   }
 
-  double * pA = A->data.db, * ppAkk = pA;
-  for(int k = 0; k < nc; k++) {
-    double * ppAik = ppAkk, eta = fabs(*ppAik);
-    for(int i = k + 1; i < nr; i++) {
-      double elt = fabs(*ppAik);
-      if (eta < elt) eta = elt;
-      ppAik += nc;
+  void PnPsolver::qr_solve(CvMat *A, CvMat *b, CvMat *X)
+  {
+    static int max_nr = 0;
+    static double *A1, *A2;
+
+    const int nr = A->rows;
+    const int nc = A->cols;
+
+    if (max_nr != 0 && max_nr < nr)
+    {
+      delete[] A1;
+      delete[] A2;
+    }
+    if (max_nr < nr)
+    {
+      max_nr = nr;
+      A1 = new double[nr];
+      A2 = new double[nr];
     }
 
-    if (eta == 0) {
-      A1[k] = A2[k] = 0.0;
-      cerr << "God damnit, A is singular, this shouldn't happen." << endl;
-      return;
-    } else {
-      double * ppAik = ppAkk, sum = 0.0, inv_eta = 1. / eta;
-      for(int i = k; i < nr; i++) {
-	*ppAik *= inv_eta;
-	sum += *ppAik * *ppAik;
-	ppAik += nc;
+    double *pA = A->data.db, *ppAkk = pA;
+    for (int k = 0; k < nc; k++)
+    {
+      double *ppAik = ppAkk, eta = fabs(*ppAik);
+      for (int i = k + 1; i < nr; i++)
+      {
+        double elt = fabs(*ppAik);
+        if (eta < elt)
+          eta = elt;
+        ppAik += nc;
       }
-      double sigma = sqrt(sum);
-      if (*ppAkk < 0)
-	sigma = -sigma;
-      *ppAkk += sigma;
-      A1[k] = sigma * *ppAkk;
-      A2[k] = -eta * sigma;
-      for(int j = k + 1; j < nc; j++) {
-	double * ppAik = ppAkk, sum = 0;
-	for(int i = k; i < nr; i++) {
-	  sum += *ppAik * ppAik[j - k];
-	  ppAik += nc;
-	}
-	double tau = sum / A1[k];
-	ppAik = ppAkk;
-	for(int i = k; i < nr; i++) {
-	  ppAik[j - k] -= tau * *ppAik;
-	  ppAik += nc;
-	}
+
+      if (eta == 0)
+      {
+        A1[k] = A2[k] = 0.0;
+        cerr << "God damnit, A is singular, this shouldn't happen." << endl;
+        return;
       }
+      else
+      {
+        double *ppAik = ppAkk, sum = 0.0, inv_eta = 1. / eta;
+        for (int i = k; i < nr; i++)
+        {
+          *ppAik *= inv_eta;
+          sum += *ppAik * *ppAik;
+          ppAik += nc;
+        }
+        double sigma = sqrt(sum);
+        if (*ppAkk < 0)
+          sigma = -sigma;
+        *ppAkk += sigma;
+        A1[k] = sigma * *ppAkk;
+        A2[k] = -eta * sigma;
+        for (int j = k + 1; j < nc; j++)
+        {
+          double *ppAik = ppAkk, sum = 0;
+          for (int i = k; i < nr; i++)
+          {
+            sum += *ppAik * ppAik[j - k];
+            ppAik += nc;
+          }
+          double tau = sum / A1[k];
+          ppAik = ppAkk;
+          for (int i = k; i < nr; i++)
+          {
+            ppAik[j - k] -= tau * *ppAik;
+            ppAik += nc;
+          }
+        }
+      }
+      ppAkk += nc + 1;
     }
-    ppAkk += nc + 1;
-  }
 
-  // b <- Qt b
-  double * ppAjj = pA, * pb = b->data.db;
-  for(int j = 0; j < nc; j++) {
-    double * ppAij = ppAjj, tau = 0;
-    for(int i = j; i < nr; i++)	{
-      tau += *ppAij * pb[i];
-      ppAij += nc;
-    }
-    tau /= A1[j];
-    ppAij = ppAjj;
-    for(int i = j; i < nr; i++) {
-      pb[i] -= tau * *ppAij;
-      ppAij += nc;
+    // b <- Qt b
+    double *ppAjj = pA, *pb = b->data.db;
+    for (int j = 0; j < nc; j++)
+    {
+      double *ppAij = ppAjj, tau = 0;
+      for (int i = j; i < nr; i++)
+      {
+        tau += *ppAij * pb[i];
+        ppAij += nc;
+      }
+      tau /= A1[j];
+      ppAij = ppAjj;
+      for (int i = j; i < nr; i++)
+      {
+        pb[i] -= tau * *ppAij;
+        ppAij += nc;
+      }
+      ppAjj += nc + 1;
     }
-    ppAjj += nc + 1;
-  }
 
-  // X = R-1 b
-  double * pX = X->data.db;
-  pX[nc - 1] = pb[nc - 1] / A2[nc - 1];
-  for(int i = nc - 2; i >= 0; i--) {
-    double * ppAij = pA + i * nc + (i + 1), sum = 0;
+    // X = R-1 b
+    double *pX = X->data.db;
+    pX[nc - 1] = pb[nc - 1] / A2[nc - 1];
+    for (int i = nc - 2; i >= 0; i--)
+    {
+      double *ppAij = pA + i * nc + (i + 1), sum = 0;
 
-    for(int j = i + 1; j < nc; j++) {
-      sum += *ppAij * pX[j];
-      ppAij++;
+      for (int j = i + 1; j < nc; j++)
+      {
+        sum += *ppAij * pX[j];
+        ppAij++;
+      }
+      pX[i] = (pb[i] - sum) / A2[i];
     }
-    pX[i] = (pb[i] - sum) / A2[i];
   }
-}
-
-
 
-void PnPsolver::relative_error(double & rot_err, double & transl_err,
-			  const double Rtrue[3][3], const double ttrue[3],
-			  const double Rest[3][3],  const double test[3])
-{
-  double qtrue[4], qest[4];
-
-  mat_to_quat(Rtrue, qtrue);
-  mat_to_quat(Rest, qest);
-
-  double rot_err1 = sqrt((qtrue[0] - qest[0]) * (qtrue[0] - qest[0]) +
-			 (qtrue[1] - qest[1]) * (qtrue[1] - qest[1]) +
-			 (qtrue[2] - qest[2]) * (qtrue[2] - qest[2]) +
-			 (qtrue[3] - qest[3]) * (qtrue[3] - qest[3]) ) /
-    sqrt(qtrue[0] * qtrue[0] + qtrue[1] * qtrue[1] + qtrue[2] * qtrue[2] + qtrue[3] * qtrue[3]);
-
-  double rot_err2 = sqrt((qtrue[0] + qest[0]) * (qtrue[0] + qest[0]) +
-			 (qtrue[1] + qest[1]) * (qtrue[1] + qest[1]) +
-			 (qtrue[2] + qest[2]) * (qtrue[2] + qest[2]) +
-			 (qtrue[3] + qest[3]) * (qtrue[3] + qest[3]) ) /
-    sqrt(qtrue[0] * qtrue[0] + qtrue[1] * qtrue[1] + qtrue[2] * qtrue[2] + qtrue[3] * qtrue[3]);
+  void PnPsolver::relative_error(double &rot_err, double &transl_err,
+                                 const double Rtrue[3][3], const double ttrue[3],
+                                 const double Rest[3][3], const double test[3])
+  {
+    double qtrue[4], qest[4];
+
+    mat_to_quat(Rtrue, qtrue);
+    mat_to_quat(Rest, qest);
+
+    double rot_err1 = sqrt((qtrue[0] - qest[0]) * (qtrue[0] - qest[0]) +
+                           (qtrue[1] - qest[1]) * (qtrue[1] - qest[1]) +
+                           (qtrue[2] - qest[2]) * (qtrue[2] - qest[2]) +
+                           (qtrue[3] - qest[3]) * (qtrue[3] - qest[3])) /
+                      sqrt(qtrue[0] * qtrue[0] + qtrue[1] * qtrue[1] + qtrue[2] * qtrue[2] + qtrue[3] * qtrue[3]);
+
+    double rot_err2 = sqrt((qtrue[0] + qest[0]) * (qtrue[0] + qest[0]) +
+                           (qtrue[1] + qest[1]) * (qtrue[1] + qest[1]) +
+                           (qtrue[2] + qest[2]) * (qtrue[2] + qest[2]) +
+                           (qtrue[3] + qest[3]) * (qtrue[3] + qest[3])) /
+                      sqrt(qtrue[0] * qtrue[0] + qtrue[1] * qtrue[1] + qtrue[2] * qtrue[2] + qtrue[3] * qtrue[3]);
+
+    rot_err = min(rot_err1, rot_err2);
+
+    transl_err =
+        sqrt((ttrue[0] - test[0]) * (ttrue[0] - test[0]) +
+             (ttrue[1] - test[1]) * (ttrue[1] - test[1]) +
+             (ttrue[2] - test[2]) * (ttrue[2] - test[2])) /
+        sqrt(ttrue[0] * ttrue[0] + ttrue[1] * ttrue[1] + ttrue[2] * ttrue[2]);
+  }
 
-  rot_err = min(rot_err1, rot_err2);
+  void PnPsolver::mat_to_quat(const double R[3][3], double q[4])
+  {
+    double tr = R[0][0] + R[1][1] + R[2][2];
+    double n4;
 
-  transl_err =
-    sqrt((ttrue[0] - test[0]) * (ttrue[0] - test[0]) +
-	 (ttrue[1] - test[1]) * (ttrue[1] - test[1]) +
-	 (ttrue[2] - test[2]) * (ttrue[2] - test[2])) /
-    sqrt(ttrue[0] * ttrue[0] + ttrue[1] * ttrue[1] + ttrue[2] * ttrue[2]);
-}
+    if (tr > 0.0f)
+    {
+      q[0] = R[1][2] - R[2][1];
+      q[1] = R[2][0] - R[0][2];
+      q[2] = R[0][1] - R[1][0];
+      q[3] = tr + 1.0f;
+      n4 = q[3];
+    }
+    else if ((R[0][0] > R[1][1]) && (R[0][0] > R[2][2]))
+    {
+      q[0] = 1.0f + R[0][0] - R[1][1] - R[2][2];
+      q[1] = R[1][0] + R[0][1];
+      q[2] = R[2][0] + R[0][2];
+      q[3] = R[1][2] - R[2][1];
+      n4 = q[0];
+    }
+    else if (R[1][1] > R[2][2])
+    {
+      q[0] = R[1][0] + R[0][1];
+      q[1] = 1.0f + R[1][1] - R[0][0] - R[2][2];
+      q[2] = R[2][1] + R[1][2];
+      q[3] = R[2][0] - R[0][2];
+      n4 = q[1];
+    }
+    else
+    {
+      q[0] = R[2][0] + R[0][2];
+      q[1] = R[2][1] + R[1][2];
+      q[2] = 1.0f + R[2][2] - R[0][0] - R[1][1];
+      q[3] = R[0][1] - R[1][0];
+      n4 = q[2];
+    }
+    double scale = 0.5f / double(sqrt(n4));
 
-void PnPsolver::mat_to_quat(const double R[3][3], double q[4])
-{
-  double tr = R[0][0] + R[1][1] + R[2][2];
-  double n4;
-
-  if (tr > 0.0f) {
-    q[0] = R[1][2] - R[2][1];
-    q[1] = R[2][0] - R[0][2];
-    q[2] = R[0][1] - R[1][0];
-    q[3] = tr + 1.0f;
-    n4 = q[3];
-  } else if ( (R[0][0] > R[1][1]) && (R[0][0] > R[2][2]) ) {
-    q[0] = 1.0f + R[0][0] - R[1][1] - R[2][2];
-    q[1] = R[1][0] + R[0][1];
-    q[2] = R[2][0] + R[0][2];
-    q[3] = R[1][2] - R[2][1];
-    n4 = q[0];
-  } else if (R[1][1] > R[2][2]) {
-    q[0] = R[1][0] + R[0][1];
-    q[1] = 1.0f + R[1][1] - R[0][0] - R[2][2];
-    q[2] = R[2][1] + R[1][2];
-    q[3] = R[2][0] - R[0][2];
-    n4 = q[1];
-  } else {
-    q[0] = R[2][0] + R[0][2];
-    q[1] = R[2][1] + R[1][2];
-    q[2] = 1.0f + R[2][2] - R[0][0] - R[1][1];
-    q[3] = R[0][1] - R[1][0];
-    n4 = q[2];
+    q[0] *= scale;
+    q[1] *= scale;
+    q[2] *= scale;
+    q[3] *= scale;
   }
-  double scale = 0.5f / double(sqrt(n4));
-
-  q[0] *= scale;
-  q[1] *= scale;
-  q[2] *= scale;
-  q[3] *= scale;
-}
 
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/RaspberryKeyFrame.cc b/slam/src/RaspberryKeyFrame.cc
deleted file mode 100644
index 584e439..0000000
--- a/slam/src/RaspberryKeyFrame.cc
+++ /dev/null
@@ -1,17 +0,0 @@
-#include "RaspberryKeyFrame.h"
-// #include "KeyFrame.h"
-// #include "ORBmatcher.h"
-// #include<mutex>
-
-namespace ORB_SLAM2
-{
-
-    RaspberryKeyFrame::RaspberryKeyFrame(KeyFrame &kf) : image(kf.image), fx(kf.fx), fy(kf.fy), cx(kf.cx), cy(kf.cy),
-                                                         invfx(kf.invfx), invfy(kf.invfy),
-                                                         mvKeys(kf.mvKeys), mvKeysUn(kf.mvKeysUn),
-                                                         mDescriptors(kf.mDescriptors.clone()), Tcw(kf.GetPose()),
-                                                         mvpMapPoints(kf.GetMapPointMatches())
-    {
-    }
-
-}
diff --git a/slam/src/Sim3Solver.cc b/slam/src/Sim3Solver.cc
index e4ef2e3..4551c86 100644
--- a/slam/src/Sim3Solver.cc
+++ b/slam/src/Sim3Solver.cc
@@ -28,7 +28,7 @@
 #include "KeyFrame.h"
 #include "ORBmatcher.h"
 
-#include "../Thirdparty/DBoW2/DUtils/Random.h"
+#include "DUtils/Random.h"
 
 namespace ORB_SLAM2
 {
diff --git a/slam/src/System.cc b/slam/src/System.cc
index be5c167..6e33007 100644
--- a/slam/src/System.cc
+++ b/slam/src/System.cc
@@ -1,24 +1,22 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
-
-
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "System.h"
 #include "Converter.h"
@@ -26,24 +24,28 @@
 #include <pangolin/pangolin.h>
 #include <iomanip>
 
-bool has_suffix(const std::string &str, const std::string &suffix) {
+bool has_suffix(const std::string &str, const std::string &suffix)
+{
     std::size_t index = str.find(suffix, str.size() - suffix.size());
     return (index != std::string::npos);
 }
 
-namespace ORB_SLAM2 {
+namespace ORB_SLAM2
+{
 
     System::System(const string &strVocFile, const string &strSettingsFile, const eSensor sensor,
                    const bool bUseViewer, const bool bUseFrameDrawer, bool bReuse, std::string mapName,
                    bool continue_mapping,
                    bool isPangolinExists) : mSensor(sensor), mbReset(false), mbActivateLocalizationMode(bReuse),
-                                            mbDeactivateLocalizationMode(false) {
+                                            mbDeactivateLocalizationMode(false)
+    {
         // Output welcome message
-        cout << endl <<
-             "ORB-SLAM2 Copyright (C) 2014-2016 Raul Mur-Artal, University of Zaragoza." << endl <<
-             "This program comes with ABSOLUTELY NO WARRANTY;" << endl <<
-             "This is free software, and you are welcome to redistribute it" << endl <<
-             "under certain conditions. See LICENSE.txt." << endl << endl;
+        cout << endl
+             << "ORB-SLAM2 Copyright (C) 2014-2016 Raul Mur-Artal, University of Zaragoza." << endl
+             << "This program comes with ABSOLUTELY NO WARRANTY;" << endl
+             << "This is free software, and you are welcome to redistribute it" << endl
+             << "under certain conditions. See LICENSE.txt." << endl
+             << endl;
 
         cout << "Input sensor was set to: ";
 
@@ -54,46 +56,54 @@ namespace ORB_SLAM2 {
         else if (mSensor == RGBD)
             cout << "RGB-D" << endl;
 
-        //Check settings file
+        // Check settings file
         cv::FileStorage fsSettings(strSettingsFile.c_str(), cv::FileStorage::READ);
-        if (!fsSettings.isOpened()) {
+        if (!fsSettings.isOpened())
+        {
             cerr << "Failed to open settings file at: " << strSettingsFile << endl;
             exit(-1);
         }
 
-
-        //Load ORB Vocabulary
+        // Load ORB Vocabulary
         mpVocabulary = new ORBVocabulary();
-        cout << endl << "Loading ORB Vocabulary. This could take a while..." << endl;
+        cout << endl
+             << "Loading ORB Vocabulary. This could take a while..." << endl;
         bool bVocLoad = false; // chose loading method based on file extension
-        if (has_suffix(strVocFile, ".txt"))
+        if (has_suffix(strVocFile, ".txt")) {
             bVocLoad = mpVocabulary->loadFromTextFile(strVocFile);
-        //else
-        //bVocLoad = mpVocabulary->loadFromBinaryFile(strVocFile);
+        }
+        else {
+            bVocLoad = mpVocabulary->loadFromBinaryFile(strVocFile);
 
+        }
 
-        //bool bVocLoad = mpVocabulary->loadFromTextFile(strVocFile);
-        if (!bVocLoad) {
+        // bool bVocLoad = mpVocabulary->loadFromTextFile(strVocFile);
+        if (!bVocLoad)
+        {
             cerr << "Wrong path to vocabulary. " << endl;
             cerr << "Falied to open at: " << strVocFile << endl;
             exit(-1);
         }
-        cout << "Vocabulary loaded!" << endl << endl;
-        //Create KeyFrame Database
+        cout << "Vocabulary loaded!" << endl
+             << endl;
+        // Create KeyFrame Database
         mpKeyFrameDatabase = new KeyFrameDatabase(*mpVocabulary);
 
-        //Create the Map
-        if (!bReuse) {
+        // Create the Map
+        if (!bReuse)
+        {
             mpMap = new Map();
         }
 
-        if (bReuse) {
+        if (bReuse)
+        {
             LoadMap(mapName);
 
-            //mpKeyFrameDatabase->set_vocab(mpVocabulary);
+            // mpKeyFrameDatabase->set_vocab(mpVocabulary);
 
             vector<ORB_SLAM2::KeyFrame *> vpKFs = mpMap->GetAllKeyFrames();
-            for (vector<ORB_SLAM2::KeyFrame *>::iterator it = vpKFs.begin(); it != vpKFs.end(); ++it) {
+            for (vector<ORB_SLAM2::KeyFrame *>::iterator it = vpKFs.begin(); it != vpKFs.end(); ++it)
+            {
                 (*it)->SetKeyFrameDatabase(mpKeyFrameDatabase);
                 (*it)->SetORBvocabulary(mpVocabulary);
                 (*it)->SetMap(mpMap);
@@ -104,38 +114,35 @@ namespace ORB_SLAM2 {
                 (*it)->SetGridParams(vpKFs);
 
                 // Reconstruct map points Observation
-
             }
 
             vector<ORB_SLAM2::MapPoint *> vpMPs = mpMap->GetAllMapPoints();
-            for (vector<ORB_SLAM2::MapPoint *>::iterator mit = vpMPs.begin(); mit != vpMPs.end(); ++mit) {
+            for (vector<ORB_SLAM2::MapPoint *>::iterator mit = vpMPs.begin(); mit != vpMPs.end(); ++mit)
+            {
                 (*mit)->SetMap(mpMap);
                 (*mit)->SetObservations(vpKFs);
-
             }
 
-            for (vector<ORB_SLAM2::KeyFrame *>::iterator it = vpKFs.begin(); it != vpKFs.end(); ++it) {
+            for (vector<ORB_SLAM2::KeyFrame *>::iterator it = vpKFs.begin(); it != vpKFs.end(); ++it)
+            {
                 (*it)->UpdateConnections();
             }
-
-
         }
-        cout << endl << mpMap << " : is the created map address" << endl;
-
-        // BAR
         if (continue_mapping)
             this->DeactivateLocalizationMode();
 
-
-        //Create Drawers. These are used by the Viewer
-        if (bUseFrameDrawer) {
+        // Create Drawers. These are used by the Viewer
+        if (bUseFrameDrawer)
+        {
             mpFrameDrawer = new FrameDrawer(mpMap, bReuse);
-        } else {
+        }
+        else
+        {
             mpFrameDrawer = nullptr;
         }
         mpMapDrawer = new MapDrawer(mpMap, strSettingsFile);
 
-        //Initialize the Tracking thread
+        // Initialize the Tracking thread
         //(it will live in the main thread of execution, the one that called this constructor)
         mpTracker = new Tracking(this, mpVocabulary, mpFrameDrawer, mpMapDrawer,
                                  mpMap, mpKeyFrameDatabase, strSettingsFile, mSensor, bReuse);
@@ -144,22 +151,22 @@ namespace ORB_SLAM2 {
         if (continue_mapping)
             mpTracker->InformOnlyTracking(false);
 
-        //Initialize the Local Mapping thread and launch
+        // Initialize the Local Mapping thread and launch
         mpLocalMapper = new LocalMapping(mpMap, mSensor == MONOCULAR);
         mptLocalMapping = new thread(&ORB_SLAM2::LocalMapping::Run, mpLocalMapper);
 
-        //Initialize the Loop Closing thread and launch
+        // Initialize the Loop Closing thread and launch
         mpLoopCloser = new LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor != MONOCULAR);
         mptLoopClosing = new thread(&ORB_SLAM2::LoopClosing::Run, mpLoopCloser);
 
-        //Initialize the Viewer thread and launch
+        // Initialize the Viewer thread and launch
         mpViewer = new Viewer(this, mpFrameDrawer, mpMapDrawer, mpTracker, strSettingsFile, bReuse, isPangolinExists);
         if (bUseViewer)
             mptViewer = new thread(&Viewer::Run, mpViewer);
 
         mpTracker->SetViewer(mpViewer);
 
-        //Set pointers between threads
+        // Set pointers between threads
         mpTracker->SetLocalMapper(mpLocalMapper);
         mpTracker->SetLoopClosing(mpLoopCloser);
 
@@ -170,8 +177,10 @@ namespace ORB_SLAM2 {
         mpLoopCloser->SetLocalMapper(mpLocalMapper);
     }
 
-    cv::Mat System::TrackStereo(const cv::Mat &imLeft, const cv::Mat &imRight, const double &timestamp) {
-        if (mSensor != STEREO) {
+    cv::Mat System::TrackStereo(const cv::Mat &imLeft, const cv::Mat &imRight, const double &timestamp)
+    {
+        if (mSensor != STEREO)
+        {
             cerr << "ERROR: you called TrackStereo but input sensor was not set to STEREO." << endl;
             exit(-1);
         }
@@ -179,18 +188,21 @@ namespace ORB_SLAM2 {
         // Check mode change
         {
             unique_lock<mutex> lock(mMutexMode);
-            if (mbActivateLocalizationMode) {
+            if (mbActivateLocalizationMode)
+            {
                 mpLocalMapper->RequestStop();
 
                 // Wait until Local Mapping has effectively stopped
-                while (!mpLocalMapper->isStopped()) {
-                    usleep(1000);
+                while (!mpLocalMapper->isStopped())
+                {
+                    Sleep(1);
                 }
 
                 mpTracker->InformOnlyTracking(true);
                 mbActivateLocalizationMode = false;
             }
-            if (mbDeactivateLocalizationMode) {
+            if (mbDeactivateLocalizationMode)
+            {
                 mpTracker->InformOnlyTracking(false);
                 mpLocalMapper->Release();
                 mbDeactivateLocalizationMode = false;
@@ -200,7 +212,8 @@ namespace ORB_SLAM2 {
         // Check reset
         {
             unique_lock<mutex> lock(mMutexReset);
-            if (mbReset) {
+            if (mbReset)
+            {
                 mpTracker->Reset();
                 mbReset = false;
             }
@@ -209,8 +222,10 @@ namespace ORB_SLAM2 {
         return mpTracker->GrabImageStereo(imLeft, imRight, timestamp);
     }
 
-    cv::Mat System::TrackRGBD(const cv::Mat &im, const cv::Mat &depthmap, const double &timestamp) {
-        if (mSensor != RGBD) {
+    cv::Mat System::TrackRGBD(const cv::Mat &im, const cv::Mat &depthmap, const double &timestamp)
+    {
+        if (mSensor != RGBD)
+        {
             cerr << "ERROR: you called TrackRGBD but input sensor was not set to RGBD." << endl;
             exit(-1);
         }
@@ -218,18 +233,21 @@ namespace ORB_SLAM2 {
         // Check mode change
         {
             unique_lock<mutex> lock(mMutexMode);
-            if (mbActivateLocalizationMode) {
+            if (mbActivateLocalizationMode)
+            {
                 mpLocalMapper->RequestStop();
 
                 // Wait until Local Mapping has effectively stopped
-                while (!mpLocalMapper->isStopped()) {
-                    usleep(1000);
+                while (!mpLocalMapper->isStopped())
+                {
+                    Sleep(1);
                 }
 
                 mpTracker->InformOnlyTracking(true);
                 mbActivateLocalizationMode = false;
             }
-            if (mbDeactivateLocalizationMode) {
+            if (mbDeactivateLocalizationMode)
+            {
                 mpTracker->InformOnlyTracking(false);
                 mpLocalMapper->Release();
                 mbDeactivateLocalizationMode = false;
@@ -239,7 +257,8 @@ namespace ORB_SLAM2 {
         // Check reset
         {
             unique_lock<mutex> lock(mMutexReset);
-            if (mbReset) {
+            if (mbReset)
+            {
                 mpTracker->Reset();
                 mbReset = false;
             }
@@ -249,9 +268,11 @@ namespace ORB_SLAM2 {
     }
 
     cv::Mat
-    System::TrackMonocular(const cv::Mat &descriptors, std::vector<cv::KeyPoint> &keyPoints, const double &timestamp) {
+    System::TrackMonocular(const cv::Mat &descriptors, std::vector<cv::KeyPoint> &keyPoints, const double &timestamp)
+    {
         cv::Mat Tcw;
-        if (mSensor != MONOCULAR) {
+        if (mSensor != MONOCULAR)
+        {
             cerr << "ERROR: you called TrackMonocular but input sensor was not set to Monocular." << endl;
             exit(-1);
         }
@@ -259,18 +280,21 @@ namespace ORB_SLAM2 {
         // Check mode change
         {
             unique_lock<mutex> lock(mMutexMode);
-            if (mbActivateLocalizationMode) {
+            if (mbActivateLocalizationMode)
+            {
                 mpLocalMapper->RequestStop();
 
                 // Wait until Local Mapping has effectively stopped
-                while (!mpLocalMapper->isStopped()) {
-                    usleep(1000);
+                while (!mpLocalMapper->isStopped())
+                {
+                    Sleep(1);
                 }
 
                 mpTracker->InformOnlyTracking(true);
                 mbActivateLocalizationMode = false;
             }
-            if (mbDeactivateLocalizationMode) {
+            if (mbDeactivateLocalizationMode)
+            {
                 mpTracker->InformOnlyTracking(false);
                 mpLocalMapper->Release();
                 mbDeactivateLocalizationMode = false;
@@ -280,21 +304,26 @@ namespace ORB_SLAM2 {
         // Check reset
         {
             unique_lock<mutex> lock(mMutexReset);
-            if (mbReset) {
+            if (mbReset)
+            {
                 mpTracker->Reset();
                 mbReset = false;
             }
         }
 
-        //return (mpTracker->GrabImageMonocular(im,timestamp)).clone();
+        // return (mpTracker->GrabImageMonocular(im,timestamp)).clone();
         return (mpTracker->GrabImageMonocular(descriptors, keyPoints, mpViewer->GetImageWidth(),
                                               mpViewer->GetImageHeight(), timestamp));
-
     }
 
-    cv::Mat System::TrackMonocular(const cv::Mat &im, const double &timestamp) {
+    cv::Mat System::TrackMonocular(const cv::Mat &im, const double &timestamp)
+    {
+        if(im.empty()){
+            std::cout << "why?" <<std::endl;
+        }
         cv::Mat Tcw;
-        if (mSensor != MONOCULAR) {
+        if (mSensor != MONOCULAR)
+        {
             cerr << "ERROR: you called TrackMonocular but input sensor was not set to Monocular." << endl;
             exit(-1);
         }
@@ -302,18 +331,21 @@ namespace ORB_SLAM2 {
         // Check mode change
         {
             unique_lock<mutex> lock(mMutexMode);
-            if (mbActivateLocalizationMode) {
+            if (mbActivateLocalizationMode)
+            {
                 mpLocalMapper->RequestStop();
 
                 // Wait until Local Mapping has effectively stopped
-                while (!mpLocalMapper->isStopped()) {
-                    usleep(1000);
+                while (!mpLocalMapper->isStopped())
+                {
+                    Sleep(1);
                 }
 
                 mpTracker->InformOnlyTracking(true);
                 mbActivateLocalizationMode = false;
             }
-            if (mbDeactivateLocalizationMode) {
+            if (mbDeactivateLocalizationMode)
+            {
                 mpTracker->InformOnlyTracking(false);
                 mpLocalMapper->Release();
                 mbDeactivateLocalizationMode = false;
@@ -323,63 +355,69 @@ namespace ORB_SLAM2 {
         // Check reset
         {
             unique_lock<mutex> lock(mMutexReset);
-            if (mbReset) {
+            if (mbReset)
+            {
                 mpTracker->Reset();
                 mbReset = false;
             }
         }
 
-        //return (mpTracker->GrabImageMonocular(im,timestamp)).clone();
+        // return (mpTracker->GrabImageMonocular(im,timestamp)).clone();
         return (mpTracker->GrabImageMonocular(im, timestamp));
-
     }
 
-    void System::ActivateLocalizationMode() {
+    void System::ActivateLocalizationMode()
+    {
         unique_lock<mutex> lock(mMutexMode);
         mbActivateLocalizationMode = true;
     }
 
-    void System::DeactivateLocalizationMode() {
+    void System::DeactivateLocalizationMode()
+    {
         unique_lock<mutex> lock(mMutexMode);
         mbDeactivateLocalizationMode = true;
     }
 
-    void System::Reset() {
+    void System::Reset()
+    {
         unique_lock<mutex> lock(mMutexReset);
         mbReset = true;
     }
 
-    Map *System::GetMap() {
+    Map *System::GetMap()
+    {
         return mpMap;
     }
 
-    Tracking *System::GetTracker() {
+    Tracking *System::GetTracker()
+    {
         return mpTracker;
     }
 
-    void System::Shutdown() {
+    void System::Shutdown()
+    {
         mpLocalMapper->RequestFinish();
         mpLoopCloser->RequestFinish();
         mpViewer->RequestFinish();
 
         // Wait until all thread have effectively stopped
         while (!mpLocalMapper->isFinished() || !mpLoopCloser->isFinished() ||
-               !mpViewer->isFinished() || mpLoopCloser->isRunningGBA()) {
-            sleep(3);
+               !mpViewer->isFinished() || mpLoopCloser->isRunningGBA())
+        {
+            Sleep(3000);
         }
-        //if(mpViewer)
-        //   pangolin::BindToContext("ORB-SLAM2: Map Viewer");
+        // if(mpViewer)
+        //    pangolin::BindToContext("ORB-SLAM2: Map Viewer");
     }
 
-    void System::LoadMap(const string &filename) {
+    void System::LoadMap(const string &filename)
+    {
         {
             std::ifstream is(filename);
 
-
             boost::archive::binary_iarchive ia(is, boost::archive::no_header);
-            //ia >> mpKeyFrameDatabase;
+            // ia >> mpKeyFrameDatabase;
             ia >> mpMap;
-
         }
 
         // std::ifstream fin("Slam_latest_Map_morning.bin", ios::binary);
@@ -394,23 +432,24 @@ namespace ORB_SLAM2 {
         auto my_str = string();
         copy_n(std::istream_iterator<char>(file), 5, std::back_inserter(my_str));
         cout << my_str << endl;
-
     }
 
-    void System::SaveMap(const string &filename) {
+    void System::SaveMap(const string &filename)
+    {
         std::ofstream os(filename);
         {
             ::boost::archive::binary_oarchive oa(os, ::boost::archive::no_header);
-            //oa << mpKeyFrameDatabase;
+            // oa << mpKeyFrameDatabase;
             oa << mpMap;
         }
-        cout << endl << "Map saved to " << filename << endl;
-
+        cout << endl
+             << "Map saved to " << filename << endl;
     }
 
-
-    void System::SaveTrajectoryTUM(const string &filename) {
-        cout << endl << "Saving camera trajectory to " << filename << " ..." << endl;
+    void System::SaveTrajectoryTUM(const string &filename)
+    {
+        cout << endl
+             << "Saving camera trajectory to " << filename << " ..." << endl;
 
         vector<KeyFrame *> vpKFs = mpMap->GetAllKeyFrames();
         sort(vpKFs.begin(), vpKFs.end(), KeyFrame::lId);
@@ -433,7 +472,9 @@ namespace ORB_SLAM2 {
         list<double>::iterator lT = mpTracker->mlFrameTimes.begin();
         list<bool>::iterator lbL = mpTracker->mlbLost.begin();
         for (list<cv::Mat>::iterator lit = mpTracker->mlRelativeFramePoses.begin(),
-                     lend = mpTracker->mlRelativeFramePoses.end(); lit != lend; lit++, lRit++, lT++, lbL++) {
+                                     lend = mpTracker->mlRelativeFramePoses.end();
+             lit != lend; lit++, lRit++, lT++, lbL++)
+        {
             if (*lbL)
                 continue;
 
@@ -442,7 +483,8 @@ namespace ORB_SLAM2 {
             cv::Mat Trw = cv::Mat::eye(4, 4, CV_32F);
 
             // If the reference keyframe was culled, traverse the spanning tree to get a suitable keyframe.
-            while (pKF->isBad()) {
+            while (pKF->isBad())
+            {
                 Trw = Trw * pKF->mTcp;
                 pKF = pKF->GetParent();
             }
@@ -459,25 +501,28 @@ namespace ORB_SLAM2 {
               << twc.at<float>(2) << " " << q[0] << " " << q[1] << " " << q[2] << " " << q[3] << endl;
         }
         f.close();
-        cout << endl << "trajectory saved!" << endl;
+        cout << endl
+             << "trajectory saved!" << endl;
     }
 
-
-    void System::SaveKeyFrameTrajectoryTUM(const string &filename) {
-        cout << endl << "Saving keyframe trajectory to " << filename << " ..." << endl;
+    void System::SaveKeyFrameTrajectoryTUM(const string &filename)
+    {
+        cout << endl
+             << "Saving keyframe trajectory to " << filename << " ..." << endl;
 
         vector<KeyFrame *> vpKFs = mpMap->GetAllKeyFrames();
         sort(vpKFs.begin(), vpKFs.end(), KeyFrame::lId);
 
         // Transform all keyframes so that the first keyframe is at the origin.
         // After a loop closure the first keyframe might not be at the origin.
-        //cv::Mat Two = vpKFs[0]->GetPoseInverse();
+        // cv::Mat Two = vpKFs[0]->GetPoseInverse();
 
         ofstream f;
         f.open(filename.c_str());
         f << fixed;
 
-        for (size_t i = 0; i < vpKFs.size(); i++) {
+        for (size_t i = 0; i < vpKFs.size(); i++)
+        {
             KeyFrame *pKF = vpKFs[i];
 
             // pKF->SetPose(pKF->GetPose()*Two);
@@ -491,15 +536,17 @@ namespace ORB_SLAM2 {
             f << setprecision(6) << pKF->mTimeStamp << setprecision(7) << " " << t.at<float>(0) << " " << t.at<float>(1)
               << " " << t.at<float>(2)
               << " " << q[0] << " " << q[1] << " " << q[2] << " " << q[3] << endl;
-
         }
 
         f.close();
-        cout << endl << "trajectory saved!" << endl;
+        cout << endl
+             << "trajectory saved!" << endl;
     }
 
-    void System::SaveTrajectoryKITTI(const string &filename) {
-        cout << endl << "Saving camera trajectory to " << filename << " ..." << endl;
+    void System::SaveTrajectoryKITTI(const string &filename)
+    {
+        cout << endl
+             << "Saving camera trajectory to " << filename << " ..." << endl;
 
         vector<KeyFrame *> vpKFs = mpMap->GetAllKeyFrames();
         sort(vpKFs.begin(), vpKFs.end(), KeyFrame::lId);
@@ -521,12 +568,14 @@ namespace ORB_SLAM2 {
         list<ORB_SLAM2::KeyFrame *>::iterator lRit = mpTracker->mlpReferences.begin();
         list<double>::iterator lT = mpTracker->mlFrameTimes.begin();
         for (list<cv::Mat>::iterator lit = mpTracker->mlRelativeFramePoses.begin(), lend = mpTracker->mlRelativeFramePoses.end();
-             lit != lend; lit++, lRit++, lT++) {
+             lit != lend; lit++, lRit++, lT++)
+        {
             ORB_SLAM2::KeyFrame *pKF = *lRit;
 
             cv::Mat Trw = cv::Mat::eye(4, 4, CV_32F);
 
-            while (pKF->isBad()) {
+            while (pKF->isBad())
+            {
                 //  cout << "bad parent" << endl;
                 Trw = Trw * pKF->mTcp;
                 pKF = pKF->GetParent();
@@ -539,15 +588,13 @@ namespace ORB_SLAM2 {
             cv::Mat twc = -Rwc * Tcw.rowRange(0, 3).col(3);
 
             f << setprecision(9) << Rwc.at<float>(0, 0) << " " << Rwc.at<float>(0, 1) << " " << Rwc.at<float>(0, 2)
-              << " " << twc.at<float>(0) << " " <<
-              Rwc.at<float>(1, 0) << " " << Rwc.at<float>(1, 1) << " " << Rwc.at<float>(1, 2) << " " << twc.at<float>(1)
-              << " " <<
-              Rwc.at<float>(2, 0) << " " << Rwc.at<float>(2, 1) << " " << Rwc.at<float>(2, 2) << " " << twc.at<float>(2)
+              << " " << twc.at<float>(0) << " " << Rwc.at<float>(1, 0) << " " << Rwc.at<float>(1, 1) << " " << Rwc.at<float>(1, 2) << " " << twc.at<float>(1)
+              << " " << Rwc.at<float>(2, 0) << " " << Rwc.at<float>(2, 1) << " " << Rwc.at<float>(2, 2) << " " << twc.at<float>(2)
               << endl;
         }
         f.close();
-        cout << endl << "trajectory saved!" << endl;
+        cout << endl
+             << "trajectory saved!" << endl;
     }
 
-
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/Tracking.cc b/slam/src/Tracking.cc
index 3ae2d83..649154f 100644
--- a/slam/src/Tracking.cc
+++ b/slam/src/Tracking.cc
@@ -1,52 +1,51 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
-
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "Tracking.h"
 
-#include<opencv2/core/core.hpp>
-#include<opencv2/features2d/features2d.hpp>
-
-#include"ORBmatcher.h"
-#include"FrameDrawer.h"
-#include"Converter.h"
-#include"Map.h"
-#include"Initializer.h"
+#include <opencv2/core/core.hpp>
+#include <opencv2/features2d/features2d.hpp>
+#include <opencv2/opencv.hpp>
+#include "ORBmatcher.h"
+#include "FrameDrawer.h"
+#include "Converter.h"
+#include "Map.h"
+#include "Initializer.h"
 
-#include"Optimizer.h"
-#include"PnPsolver.h"
+#include "Optimizer.h"
+#include "PnPsolver.h"
 
-#include<iostream>
-
-#include<mutex>
+#include <iostream>
 
+#include <mutex>
 
 using namespace std;
 
-namespace ORB_SLAM2 {
+namespace ORB_SLAM2
+{
 
     Tracking::Tracking(System *pSys, ORBVocabulary *pVoc, FrameDrawer *pFrameDrawer, MapDrawer *pMapDrawer, Map *pMap,
-                       KeyFrameDatabase *pKFDB, const string &strSettingPath, const int sensor, const bool bReuse) :
-            mState(NO_IMAGES_YET), mSensor(sensor), mbOnlyTracking(bReuse), mbVO(false), mpORBVocabulary(pVoc),
-            mpKeyFrameDB(pKFDB), mpInitializer(static_cast<Initializer *>(NULL)), mpSystem(pSys),
-            mpFrameDrawer(pFrameDrawer), mpMapDrawer(pMapDrawer), mpMap(pMap), mnLastRelocFrameId(0) {
+                       KeyFrameDatabase *pKFDB, const string &strSettingPath, const int sensor, const bool bReuse) : mState(NO_IMAGES_YET), mSensor(sensor), mbOnlyTracking(bReuse), mbVO(false), mpORBVocabulary(pVoc),
+                                                                                                                     mpKeyFrameDB(pKFDB), mpInitializer(static_cast<Initializer *>(NULL)), mpSystem(pSys),
+                                                                                                                     mpFrameDrawer(pFrameDrawer), mpMapDrawer(pMapDrawer), mpMap(pMap), mnLastRelocFrameId(0)
+    {
         // Load camera parameters from settings file
 
         cv::FileStorage fSettings(strSettingPath, cv::FileStorage::READ);
@@ -78,7 +77,8 @@ namespace ORB_SLAM2 {
         DistCoef.at<float>(2) = fSettings["Camera.p1"];
         DistCoef.at<float>(3) = fSettings["Camera.p2"];
         const float k3 = fSettings["Camera.k3"];
-        if (k3 != 0) {
+        if (k3 != 0)
+        {
             DistCoef.resize(5);
             DistCoef.at<float>(4) = k3;
         }
@@ -91,7 +91,8 @@ namespace ORB_SLAM2 {
             fps = 30;
 
         is_preloaded = bReuse;
-        if (is_preloaded) {
+        if (is_preloaded)
+        {
             mnLastKeyFrameId = 0;
             mState = LOST;
         }
@@ -99,7 +100,8 @@ namespace ORB_SLAM2 {
         mMinFrames = 0;
         mMaxFrames = fps;
 
-        cout << endl << "Camera Parameters: " << endl;
+        cout << endl
+             << "Camera Parameters: " << endl;
         cout << "- fx: " << fx << endl;
         cout << "- fy: " << fy << endl;
         cout << "- cx: " << cx << endl;
@@ -112,7 +114,6 @@ namespace ORB_SLAM2 {
         cout << "- p2: " << DistCoef.at<float>(3) << endl;
         cout << "- fps: " << fps << endl;
 
-
         int nRGB = fSettings["Camera.RGB"];
         mbRGB = nRGB;
 
@@ -137,58 +138,73 @@ namespace ORB_SLAM2 {
         if (sensor == System::MONOCULAR)
             mpIniORBextractor = new ORBextractor(2 * nFeatures, fScaleFactor, nLevels, fIniThFAST, fMinThFAST);
 
-        cout << endl << "ORB Extractor Parameters: " << endl;
+        cout << endl
+             << "ORB Extractor Parameters: " << endl;
         cout << "- Number of Features: " << nFeatures << endl;
         cout << "- Scale Levels: " << nLevels << endl;
         cout << "- Scale Factor: " << fScaleFactor << endl;
         cout << "- Initial Fast Threshold: " << fIniThFAST << endl;
         cout << "- Minimum Fast Threshold: " << fMinThFAST << endl;
         cout << "- Reuse Map ?: " << is_preloaded << endl;
-        if (sensor == System::STEREO || sensor == System::RGBD) {
-            mThDepth = mbf * (float) fSettings["ThDepth"] / fx;
-            cout << endl << "Depth Threshold (Close/Far Points): " << mThDepth << endl;
+        if (sensor == System::STEREO || sensor == System::RGBD)
+        {
+            mThDepth = mbf * (float)fSettings["ThDepth"] / fx;
+            cout << endl
+                 << "Depth Threshold (Close/Far Points): " << mThDepth << endl;
         }
 
-        if (sensor == System::RGBD) {
+        if (sensor == System::RGBD)
+        {
             mDepthMapFactor = fSettings["DepthMapFactor"];
             if (mDepthMapFactor == 0)
                 mDepthMapFactor = 1;
             else
                 mDepthMapFactor = 1.0f / mDepthMapFactor;
         }
-
     }
 
-    void Tracking::SetLocalMapper(LocalMapping *pLocalMapper) {
+    void Tracking::SetLocalMapper(LocalMapping *pLocalMapper)
+    {
         mpLocalMapper = pLocalMapper;
     }
 
-    void Tracking::SetLoopClosing(LoopClosing *pLoopClosing) {
+    void Tracking::SetLoopClosing(LoopClosing *pLoopClosing)
+    {
         mpLoopClosing = pLoopClosing;
     }
 
-    void Tracking::SetViewer(Viewer *pViewer) {
+    void Tracking::SetViewer(Viewer *pViewer)
+    {
         mpViewer = pViewer;
     }
 
-
-    cv::Mat Tracking::GrabImageStereo(const cv::Mat &imRectLeft, const cv::Mat &imRectRight, const double &timestamp) {
+    cv::Mat Tracking::GrabImageStereo(const cv::Mat &imRectLeft, const cv::Mat &imRectRight, const double &timestamp)
+    {
         mImGray = imRectLeft;
         cv::Mat imGrayRight = imRectRight;
 
-        if (mImGray.channels() == 3) {
-            if (mbRGB) {
+        if (mImGray.channels() == 3)
+        {
+            if (mbRGB)
+            {
                 cvtColor(mImGray, mImGray, CV_RGB2GRAY);
                 cvtColor(imGrayRight, imGrayRight, CV_RGB2GRAY);
-            } else {
+            }
+            else
+            {
                 cvtColor(mImGray, mImGray, CV_BGR2GRAY);
                 cvtColor(imGrayRight, imGrayRight, CV_BGR2GRAY);
             }
-        } else if (mImGray.channels() == 4) {
-            if (mbRGB) {
+        }
+        else if (mImGray.channels() == 4)
+        {
+            if (mbRGB)
+            {
                 cvtColor(mImGray, mImGray, CV_RGBA2GRAY);
                 cvtColor(imGrayRight, imGrayRight, CV_RGBA2GRAY);
-            } else {
+            }
+            else
+            {
                 cvtColor(mImGray, mImGray, CV_BGRA2GRAY);
                 cvtColor(imGrayRight, imGrayRight, CV_BGRA2GRAY);
             }
@@ -202,24 +218,28 @@ namespace ORB_SLAM2 {
         return mCurrentFrame.mTcw.clone();
     }
 
-
-    cv::Mat Tracking::GrabImageRGBD(const cv::Mat &imRGB, const cv::Mat &imD, const double &timestamp) {
+    cv::Mat Tracking::GrabImageRGBD(const cv::Mat &imRGB, const cv::Mat &imD, const double &timestamp)
+    {
         mImGray = imRGB;
         cv::Mat imDepth = imD;
 
-        if (mImGray.channels() == 3) {
+        if (mImGray.channels() == 3)
+        {
             if (mbRGB)
                 cvtColor(mImGray, mImGray, CV_RGB2GRAY);
             else
                 cvtColor(mImGray, mImGray, CV_BGR2GRAY);
-        } else if (mImGray.channels() == 4) {
+        }
+        else if (mImGray.channels() == 4)
+        {
             if (mbRGB)
                 cvtColor(mImGray, mImGray, CV_RGBA2GRAY);
             else
                 cvtColor(mImGray, mImGray, CV_BGRA2GRAY);
         }
 
-        if (mDepthMapFactor != 1 || imDepth.type() != CV_32F);
+        if (mDepthMapFactor != 1 || imDepth.type() != CV_32F)
+            ;
         imDepth.convertTo(imDepth, CV_32F, mDepthMapFactor);
 
         mCurrentFrame = Frame(mImGray, imDepth, timestamp, mpORBextractorLeft, mpORBVocabulary, mK, mDistCoef, mbf,
@@ -233,24 +253,28 @@ namespace ORB_SLAM2 {
     cv::Mat
     Tracking::GrabImageMonocular(const cv::Mat &descriptors, std::vector<cv::KeyPoint> &keyPoints, const float cols,
                                  const float rows,
-                                 const double &timestamp) {
+                                 const double &timestamp)
+    {
 
-        if (mImGray.channels() == 3) {
+        if (mImGray.channels() == 3)
+        {
             if (mbRGB)
                 cvtColor(mImGray, mImGray, CV_RGB2GRAY);
             else
                 cvtColor(mImGray, mImGray, CV_BGR2GRAY);
-        } else if (mImGray.channels() == 4) {
+        }
+        else if (mImGray.channels() == 4)
+        {
             if (mbRGB)
                 cvtColor(mImGray, mImGray, CV_RGBA2GRAY);
             else
                 cvtColor(mImGray, mImGray, CV_BGRA2GRAY);
         }
-//        if (mState == NOT_INITIALIZED || mState == NO_IMAGES_YET) {
-//            //mCurrentFrame = Frame(mImGray,timestamp,mpIniORBextractor,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);
-//            std::cout << "first frame must be with image " << std::endl;
-//            return {};
-//        } else {
+        //        if (mState == NOT_INITIALIZED || mState == NO_IMAGES_YET) {
+        //            //mCurrentFrame = Frame(mImGray,timestamp,mpIniORBextractor,mpORBVocabulary,mK,mDistCoef,mbf,mThDepth);
+        //            std::cout << "first frame must be with image " << std::endl;
+        //            return {};
+        //        } else {
         mCurrentFrame = Frame(descriptors, keyPoints, cols, rows, timestamp, mpORBextractorLeft, mpORBVocabulary, mK,
                               mDistCoef,
                               mbf,
@@ -261,16 +285,19 @@ namespace ORB_SLAM2 {
         return mCurrentFrame.mTcw.clone();
     }
 
-
-    cv::Mat Tracking::GrabImageMonocular(const cv::Mat &im, const double &timestamp) {
+    cv::Mat Tracking::GrabImageMonocular(const cv::Mat &im, const double &timestamp)
+    {
         mImGray = im;
 
-        if (mImGray.channels() == 3) {
+        if (mImGray.channels() == 3)
+        {
             if (mbRGB)
                 cvtColor(mImGray, mImGray, CV_RGB2GRAY);
             else
                 cvtColor(mImGray, mImGray, CV_BGR2GRAY);
-        } else if (mImGray.channels() == 4) {
+        }
+        else if (mImGray.channels() == 4)
+        {
             if (mbRGB)
                 cvtColor(mImGray, mImGray, CV_RGBA2GRAY);
             else
@@ -288,8 +315,10 @@ namespace ORB_SLAM2 {
         return mCurrentFrame.mTcw.clone();
     }
 
-    void Tracking::Track() {
-        if (mState == NO_IMAGES_YET) {
+    void Tracking::Track()
+    {
+        if (mState == NO_IMAGES_YET)
+        {
             mState = NOT_INITIALIZED;
         }
 
@@ -298,8 +327,10 @@ namespace ORB_SLAM2 {
         // Get Map Mutex -> Map cannot be changed
         unique_lock<mutex> lock(mpMap->mMutexMapUpdate);
 
-        if (mState == NOT_INITIALIZED) {
-            if (is_preloaded) {
+        if (mState == NOT_INITIALIZED)
+        {
+            if (is_preloaded)
+            {
                 mState = LOST;
                 return;
             }
@@ -307,51 +338,72 @@ namespace ORB_SLAM2 {
                 StereoInitialization();
             else
                 MonocularInitialization();
-            if (mpFrameDrawer != nullptr) {
+            if (mpFrameDrawer != nullptr)
+            {
                 mpFrameDrawer->Update(this);
             }
 
             if (mState != OK)
                 return;
-        } else {
+        }
+        else
+        {
             // System is initialized. Track Frame.
             bool bOK;
 
             // Initial camera pose estimation using motion model or relocalization (if tracking is lost)
-            if (!mbOnlyTracking) {
+            if (!mbOnlyTracking)
+            {
                 // Local Mapping is activated. This is the normal behaviour, unless
                 // you explicitly activate the "only tracking" mode.
-                //mState = LOST;
-                if (mState == OK) {
+                // mState = LOST;
+                if (mState == OK)
+                {
                     // Local Mapping might have changed some MapPoints tracked in last frame
                     CheckReplacedInLastFrame();
 
-                    if (mVelocity.empty() || mCurrentFrame.mnId < mnLastRelocFrameId + 2) {
+                    if (mVelocity.empty() || mCurrentFrame.mnId < mnLastRelocFrameId + 2)
+                    {
                         bOK = TrackReferenceKeyFrame();
-                    } else {
+                    }
+                    else
+                    {
                         bOK = TrackWithMotionModel();
                         if (!bOK)
                             bOK = TrackReferenceKeyFrame();
                     }
-                } else {
+                }
+                else
+                {
                     bOK = Relocalization();
                 }
-            } else {
+            }
+            else
+            {
                 // Only Tracking: Local Mapping is deactivated
                 // BAR
                 // mState = LOST;
-                if (mState == LOST) {
+                if (mState == LOST)
+                {
                     bOK = Relocalization();
-                } else {
-                    if (!mbVO) {
+                }
+                else
+                {
+                    if (!mbVO)
+                    {
                         // In last frame we tracked enough MapPoints in the map
 
-                        if (!mVelocity.empty()) {
+                        if (!mVelocity.empty())
+                        {
                             bOK = TrackWithMotionModel();
-                        } else {
+                        }
+                        else
+                        {
                             bOK = TrackReferenceKeyFrame();
                         }
-                    } else {
+                    }
+                    else
+                    {
                         // In last frame we tracked mainly "visual odometry" points.
 
                         // We compute two camera poses, one from motion model and one doing relocalization.
@@ -363,7 +415,8 @@ namespace ORB_SLAM2 {
                         vector<MapPoint *> vpMPsMM;
                         vector<bool> vbOutMM;
                         cv::Mat TcwMM;
-                        if (!mVelocity.empty()) {
+                        if (!mVelocity.empty())
+                        {
                             bOKMM = TrackWithMotionModel();
                             vpMPsMM = mCurrentFrame.mvpMapPoints;
                             vbOutMM = mCurrentFrame.mvbOutlier;
@@ -371,19 +424,25 @@ namespace ORB_SLAM2 {
                         }
                         bOKReloc = Relocalization();
 
-                        if (bOKMM && !bOKReloc) {
+                        if (bOKMM && !bOKReloc)
+                        {
                             mCurrentFrame.SetPose(TcwMM);
                             mCurrentFrame.mvpMapPoints = vpMPsMM;
                             mCurrentFrame.mvbOutlier = vbOutMM;
 
-                            if (mbVO) {
-                                for (int i = 0; i < mCurrentFrame.N; i++) {
-                                    if (mCurrentFrame.mvpMapPoints[i] && !mCurrentFrame.mvbOutlier[i]) {
+                            if (mbVO)
+                            {
+                                for (int i = 0; i < mCurrentFrame.N; i++)
+                                {
+                                    if (mCurrentFrame.mvpMapPoints[i] && !mCurrentFrame.mvbOutlier[i])
+                                    {
                                         mCurrentFrame.mvpMapPoints[i]->IncreaseFound();
                                     }
                                 }
                             }
-                        } else if (bOKReloc) {
+                        }
+                        else if (bOKReloc)
+                        {
                             mbVO = false;
                         }
 
@@ -392,14 +451,16 @@ namespace ORB_SLAM2 {
                 }
             }
 
-
             mCurrentFrame.mpReferenceKF = mpReferenceKF;
 
             // If we have an initial estimation of the camera pose and matching. Track the local map.
-            if (!mbOnlyTracking) {
+            if (!mbOnlyTracking)
+            {
                 if (bOK)
                     bOK = TrackLocalMap();
-            } else {
+            }
+            else
+            {
                 // mbVO true means that there are few matches to MapPoints in the map. We cannot retrieve
                 // a local map and therefore we do not perform TrackLocalMap(). Once the system relocalizes
                 // the camera we will use the local map again.
@@ -413,28 +474,34 @@ namespace ORB_SLAM2 {
                 mState = LOST;
 
             // Update drawer
-            if (mpFrameDrawer != nullptr) {
+            if (mpFrameDrawer != nullptr)
+            {
                 mpFrameDrawer->Update(this);
             }
 
             // If tracking were good, check if we insert a keyframe
-            if (bOK) {
+            if (bOK)
+            {
                 // Update motion model
-                if (!mLastFrame.mTcw.empty()) {
+                if (!mLastFrame.mTcw.empty())
+                {
                     cv::Mat LastTwc = cv::Mat::eye(4, 4, CV_32F);
                     mLastFrame.GetRotationInverse().copyTo(LastTwc.rowRange(0, 3).colRange(0, 3));
                     mLastFrame.GetCameraCenter().copyTo(LastTwc.rowRange(0, 3).col(3));
                     mVelocity = mCurrentFrame.mTcw * LastTwc;
-                } else
+                }
+                else
                     mVelocity = cv::Mat();
 
                 mpMapDrawer->SetCurrentCameraPose(mCurrentFrame.mTcw);
 
                 // Clean temporal point matches
-                for (int i = 0; i < mCurrentFrame.N; i++) {
+                for (int i = 0; i < mCurrentFrame.N; i++)
+                {
                     MapPoint *pMP = mCurrentFrame.mvpMapPoints[i];
                     if (pMP)
-                        if (pMP->Observations() < 1) {
+                        if (pMP->Observations() < 1)
+                        {
                             mCurrentFrame.mvbOutlier[i] = false;
                             mCurrentFrame.mvpMapPoints[i] = static_cast<MapPoint *>(NULL);
                         }
@@ -442,7 +509,8 @@ namespace ORB_SLAM2 {
 
                 // Delete temporal MapPoints
                 for (list<MapPoint *>::iterator lit = mlpTemporalPoints.begin(), lend = mlpTemporalPoints.end();
-                     lit != lend; lit++) {
+                     lit != lend; lit++)
+                {
                     MapPoint *pMP = *lit;
                     delete pMP;
                 }
@@ -456,15 +524,18 @@ namespace ORB_SLAM2 {
                 // pass to the new keyframe, so that bundle adjustment will finally decide
                 // if they are outliers or not. We don't want next frame to estimate its position
                 // with those points so we discard them in the frame.
-                for (int i = 0; i < mCurrentFrame.N; i++) {
+                for (int i = 0; i < mCurrentFrame.N; i++)
+                {
                     if (mCurrentFrame.mvpMapPoints[i] && mCurrentFrame.mvbOutlier[i])
                         mCurrentFrame.mvpMapPoints[i] = static_cast<MapPoint *>(NULL);
                 }
             }
 
             // Reset if the camera get lost soon after initialization
-            if (mState == LOST) {
-                if (mpMap->KeyFramesInMap() <= 5) {
+            if (mState == LOST)
+            {
+                if (mpMap->KeyFramesInMap() <= 5)
+                {
                     cout << "Track lost soon after initialisation, reseting..." << endl;
                     mpSystem->Reset();
                     return;
@@ -477,20 +548,22 @@ namespace ORB_SLAM2 {
             mLastFrame = Frame(mCurrentFrame);
         }
 
-
         // Store frame pose information to retrieve the complete camera trajectory afterwards.
-        if (!mCurrentFrame.mTcw.empty() && mCurrentFrame.mpReferenceKF) {
+        if (!mCurrentFrame.mTcw.empty() && mCurrentFrame.mpReferenceKF)
+        {
             cv::Mat Tcr = mCurrentFrame.mTcw * mCurrentFrame.mpReferenceKF->GetPoseInverse();
             mlRelativeFramePoses.push_back(Tcr);
             mlpReferences.push_back(mpReferenceKF);
             mlFrameTimes.push_back(mCurrentFrame.mTimeStamp);
             mlbLost.push_back(mState == LOST);
-        } else {
+        }
+        else
+        {
             // This can happen if tracking is lost
-            //mlRelativeFramePoses.push_back(mlRelativeFramePoses.back());
-            //mlpReferences.push_back(mlpReferences.back());
-            //mlFrameTimes.push_back(mlFrameTimes.back());
-            //mlbLost.push_back(mState==LOST);
+            // mlRelativeFramePoses.push_back(mlRelativeFramePoses.back());
+            // mlpReferences.push_back(mlpReferences.back());
+            // mlFrameTimes.push_back(mlFrameTimes.back());
+            // mlbLost.push_back(mState==LOST);
         }
     }
 
@@ -501,9 +574,10 @@ namespace ORB_SLAM2 {
     }
 #endif
 
-
-    void Tracking::StereoInitialization() {
-        if (mCurrentFrame.N > 500) {
+    void Tracking::StereoInitialization()
+    {
+        if (mCurrentFrame.N > 500)
+        {
             // Set Frame pose to the origin
             mCurrentFrame.SetPose(cv::Mat::eye(4, 4, CV_32F));
 
@@ -514,9 +588,11 @@ namespace ORB_SLAM2 {
             mpMap->AddKeyFrame(pKFini);
 
             // Create MapPoints and asscoiate to KeyFrame
-            for (int i = 0; i < mCurrentFrame.N; i++) {
+            for (int i = 0; i < mCurrentFrame.N; i++)
+            {
                 float z = mCurrentFrame.mvDepth[i];
-                if (z > 0) {
+                if (z > 0)
+                {
                     cv::Mat x3D = mCurrentFrame.UnprojectStereo(i);
                     MapPoint *pNewMP = new MapPoint(x3D, pKFini, mpMap);
                     pNewMP->AddObservation(pKFini, i);
@@ -552,11 +628,14 @@ namespace ORB_SLAM2 {
         }
     }
 
-    void Tracking::MonocularInitialization() {
+    void Tracking::MonocularInitialization()
+    {
 
-        if (!mpInitializer) {
+        if (!mpInitializer)
+        {
             // Set Reference Frame
-            if (mCurrentFrame.mvKeys.size() > 100) {
+            if (mCurrentFrame.mvKeys.size() > 100)
+            {
                 mInitialFrame = Frame(mCurrentFrame);
                 mLastFrame = Frame(mCurrentFrame);
                 mvbPrevMatched.resize(mCurrentFrame.mvKeysUn.size());
@@ -571,13 +650,16 @@ namespace ORB_SLAM2 {
                 fill(mvIniMatches.begin(), mvIniMatches.end(), -1);
 
                 return;
-            } //else
-            //cout << __FUNCTION__ << "The Key Frame-s points are less: " << mCurrentFrame.mvKeys.size() << endl;
-        } else {
+            } // else
+            // cout << __FUNCTION__ << "The Key Frame-s points are less: " << mCurrentFrame.mvKeys.size() << endl;
+        }
+        else
+        {
             // Try to initialize
-            if ((int) mCurrentFrame.mvKeys.size() <= 100) {
+            if ((int)mCurrentFrame.mvKeys.size() <= 100)
+            {
 
-                //cout << __FUNCTION__ << "old.The Key Frame-s points are less: " << mCurrentFrame.mvKeys.size() << endl;
+                // cout << __FUNCTION__ << "old.The Key Frame-s points are less: " << mCurrentFrame.mvKeys.size() << endl;
                 delete mpInitializer;
                 mpInitializer = static_cast<Initializer *>(NULL);
                 fill(mvIniMatches.begin(), mvIniMatches.end(), -1);
@@ -586,24 +668,26 @@ namespace ORB_SLAM2 {
 
             // Find correspondences
             ORBmatcher matcher(0.9, true);
-            int nmatches = matcher.SearchForInitialization(mInitialFrame, mCurrentFrame, mvbPrevMatched, mvIniMatches,
-                                                           100);
-
+            int nmatches = matcher.SearchForInitialization(mInitialFrame, mCurrentFrame, mvbPrevMatched, mvIniMatches);
             // Check if there are enough correspondences
-            if (nmatches < 100) {
+            if (nmatches < 100)
+            {
                 cout << __FUNCTION__ << "ORB extraction : No enough correspondesnces(<100) " << nmatches << endl;
                 delete mpInitializer;
                 mpInitializer = static_cast<Initializer *>(NULL);
                 return;
             }
 
-            cv::Mat Rcw; // Current Camera Rotation
-            cv::Mat tcw; // Current Camera Translation
+            cv::Mat Rcw;                 // Current Camera Rotation
+            cv::Mat tcw;                 // Current Camera Translation
             vector<bool> vbTriangulated; // Triangulated Correspondences (mvIniMatches)
 
-            if (mpInitializer->Initialize(mCurrentFrame, mvIniMatches, Rcw, tcw, mvIniP3D, vbTriangulated)) {
-                for (size_t i = 0, iend = mvIniMatches.size(); i < iend; i++) {
-                    if (mvIniMatches[i] >= 0 && !vbTriangulated[i]) {
+            if (mpInitializer->Initialize(mCurrentFrame, mvIniMatches, Rcw, tcw, mvIniP3D, vbTriangulated))
+            {
+                for (size_t i = 0, iend = mvIniMatches.size(); i < iend; i++)
+                {
+                    if (mvIniMatches[i] >= 0 && !vbTriangulated[i])
+                    {
                         mvIniMatches[i] = -1;
                         nmatches--;
                     }
@@ -621,14 +705,14 @@ namespace ORB_SLAM2 {
         }
     }
 
-    void Tracking::CreateInitialMapMonocular() {
+    void Tracking::CreateInitialMapMonocular()
+    {
 
         cout << __FUNCTION__ << ": Starting Initial Map Creation..." << endl;
         // Create KeyFrames
         KeyFrame *pKFini = new KeyFrame(mInitialFrame, mpMap, mpKeyFrameDB);
         KeyFrame *pKFcur = new KeyFrame(mCurrentFrame, mpMap, mpKeyFrameDB);
 
-
         pKFini->ComputeBoW();
         pKFcur->ComputeBoW();
 
@@ -637,11 +721,12 @@ namespace ORB_SLAM2 {
         mpMap->AddKeyFrame(pKFcur);
 
         // Create MapPoints and asscoiate to keyframes
-        for (size_t i = 0; i < mvIniMatches.size(); i++) {
+        for (size_t i = 0; i < mvIniMatches.size(); i++)
+        {
             if (mvIniMatches[i] < 0)
                 continue;
 
-            //Create MapPoint.
+            // Create MapPoint.
             cv::Mat worldPos(mvIniP3D[i]);
 
             MapPoint *pMP = new MapPoint(worldPos, pKFcur, mpMap);
@@ -655,11 +740,11 @@ namespace ORB_SLAM2 {
             pMP->ComputeDistinctiveDescriptors();
             pMP->UpdateNormalAndDepth();
 
-            //Fill Current Frame structure
+            // Fill Current Frame structure
             mCurrentFrame.mvpMapPoints[mvIniMatches[i]] = pMP;
             mCurrentFrame.mvbOutlier[mvIniMatches[i]] = false;
 
-            //Add to Map
+            // Add to Map
             mpMap->AddMapPoint(pMP);
         }
 
@@ -676,7 +761,8 @@ namespace ORB_SLAM2 {
         float medianDepth = pKFini->ComputeSceneMedianDepth(2);
         float invMedianDepth = 1.0f / medianDepth;
 
-        if (medianDepth < 0 || pKFcur->TrackedMapPoints(1) < 100) {
+        if (medianDepth < 0 || pKFcur->TrackedMapPoints(1) < 100)
+        {
             cout << "Wrong initialization, reseting... map points(100):"
                  << pKFcur->TrackedMapPoints(1)
                  << " medianDepth = " << medianDepth << endl;
@@ -691,8 +777,10 @@ namespace ORB_SLAM2 {
 
         // Scale points
         vector<MapPoint *> vpAllMapPoints = pKFini->GetMapPointMatches();
-        for (size_t iMP = 0; iMP < vpAllMapPoints.size(); iMP++) {
-            if (vpAllMapPoints[iMP]) {
+        for (size_t iMP = 0; iMP < vpAllMapPoints.size(); iMP++)
+        {
+            if (vpAllMapPoints[iMP])
+            {
                 MapPoint *pMP = vpAllMapPoints[iMP];
                 pMP->SetWorldPos(pMP->GetWorldPos() * invMedianDepth);
             }
@@ -722,21 +810,25 @@ namespace ORB_SLAM2 {
         mState = OK;
     }
 
-    void Tracking::CheckReplacedInLastFrame() {
-        for (int i = 0; i < mLastFrame.N; i++) {
+    void Tracking::CheckReplacedInLastFrame()
+    {
+        for (int i = 0; i < mLastFrame.N; i++)
+        {
             MapPoint *pMP = mLastFrame.mvpMapPoints[i];
 
-            if (pMP) {
+            if (pMP)
+            {
                 MapPoint *pRep = pMP->GetReplaced();
-                if (pRep) {
+                if (pRep)
+                {
                     mLastFrame.mvpMapPoints[i] = pRep;
                 }
             }
         }
     }
 
-
-    bool Tracking::TrackReferenceKeyFrame() {
+    bool Tracking::TrackReferenceKeyFrame()
+    {
         // Compute Bag of Words vector
         mCurrentFrame.ComputeBoW();
 
@@ -757,9 +849,12 @@ namespace ORB_SLAM2 {
 
         // Discard outliers
         int nmatchesMap = 0;
-        for (int i = 0; i < mCurrentFrame.N; i++) {
-            if (mCurrentFrame.mvpMapPoints[i]) {
-                if (mCurrentFrame.mvbOutlier[i]) {
+        for (int i = 0; i < mCurrentFrame.N; i++)
+        {
+            if (mCurrentFrame.mvpMapPoints[i])
+            {
+                if (mCurrentFrame.mvbOutlier[i])
+                {
                     MapPoint *pMP = mCurrentFrame.mvpMapPoints[i];
 
                     mCurrentFrame.mvpMapPoints[i] = static_cast<MapPoint *>(NULL);
@@ -767,7 +862,8 @@ namespace ORB_SLAM2 {
                     pMP->mbTrackInView = false;
                     pMP->mnLastFrameSeen = mCurrentFrame.mnId;
                     nmatches--;
-                } else if (mCurrentFrame.mvpMapPoints[i]->Observations() > 0)
+                }
+                else if (mCurrentFrame.mvpMapPoints[i]->Observations() > 0)
                     nmatchesMap++;
             }
         }
@@ -775,7 +871,8 @@ namespace ORB_SLAM2 {
         return nmatchesMap >= 10;
     }
 
-    void Tracking::UpdateLastFrame() {
+    void Tracking::UpdateLastFrame()
+    {
         // Update pose according to reference keyframe
         KeyFrame *pRef = mLastFrame.mpReferenceKF;
         cv::Mat Tlr = mlRelativeFramePoses.back();
@@ -787,11 +884,13 @@ namespace ORB_SLAM2 {
 
         // Create "visual odometry" MapPoints
         // We sort points according to their measured depth by the stereo/RGB-D sensor
-        vector<pair<float, int> > vDepthIdx;
+        vector<pair<float, int>> vDepthIdx;
         vDepthIdx.reserve(mLastFrame.N);
-        for (int i = 0; i < mLastFrame.N; i++) {
+        for (int i = 0; i < mLastFrame.N; i++)
+        {
             float z = mLastFrame.mvDepth[i];
-            if (z > 0) {
+            if (z > 0)
+            {
                 vDepthIdx.push_back(make_pair(z, i));
             }
         }
@@ -804,7 +903,8 @@ namespace ORB_SLAM2 {
         // We insert all close points (depth<mThDepth)
         // If less than 100 close points, we insert the 100 closest ones.
         int nPoints = 0;
-        for (size_t j = 0; j < vDepthIdx.size(); j++) {
+        for (size_t j = 0; j < vDepthIdx.size(); j++)
+        {
             int i = vDepthIdx[j].second;
 
             bool bCreateNew = false;
@@ -812,11 +912,13 @@ namespace ORB_SLAM2 {
             MapPoint *pMP = mLastFrame.mvpMapPoints[i];
             if (!pMP)
                 bCreateNew = true;
-            else if (pMP->Observations() < 1) {
+            else if (pMP->Observations() < 1)
+            {
                 bCreateNew = true;
             }
 
-            if (bCreateNew) {
+            if (bCreateNew)
+            {
                 cv::Mat x3D = mLastFrame.UnprojectStereo(i);
                 MapPoint *pNewMP = new MapPoint(x3D, mpMap, &mLastFrame, i);
 
@@ -824,7 +926,9 @@ namespace ORB_SLAM2 {
 
                 mlpTemporalPoints.push_back(pNewMP);
                 nPoints++;
-            } else {
+            }
+            else
+            {
                 nPoints++;
             }
 
@@ -833,7 +937,8 @@ namespace ORB_SLAM2 {
         }
     }
 
-    bool Tracking::TrackWithMotionModel() {
+    bool Tracking::TrackWithMotionModel()
+    {
         ORBmatcher matcher(0.9, true);
 
         // Update last frame pose according to its reference keyframe
@@ -853,7 +958,8 @@ namespace ORB_SLAM2 {
         int nmatches = matcher.SearchByProjection(mCurrentFrame, mLastFrame, th, mSensor == System::MONOCULAR);
 
         // If few matches, uses a wider window search
-        if (nmatches < 20) {
+        if (nmatches < 20)
+        {
             fill(mCurrentFrame.mvpMapPoints.begin(), mCurrentFrame.mvpMapPoints.end(), static_cast<MapPoint *>(NULL));
             nmatches = matcher.SearchByProjection(mCurrentFrame, mLastFrame, 2 * th, mSensor == System::MONOCULAR);
         }
@@ -866,9 +972,12 @@ namespace ORB_SLAM2 {
 
         // Discard outliers
         int nmatchesMap = 0;
-        for (int i = 0; i < mCurrentFrame.N; i++) {
-            if (mCurrentFrame.mvpMapPoints[i]) {
-                if (mCurrentFrame.mvbOutlier[i]) {
+        for (int i = 0; i < mCurrentFrame.N; i++)
+        {
+            if (mCurrentFrame.mvpMapPoints[i])
+            {
+                if (mCurrentFrame.mvbOutlier[i])
+                {
                     MapPoint *pMP = mCurrentFrame.mvpMapPoints[i];
 
                     mCurrentFrame.mvpMapPoints[i] = static_cast<MapPoint *>(NULL);
@@ -876,12 +985,14 @@ namespace ORB_SLAM2 {
                     pMP->mbTrackInView = false;
                     pMP->mnLastFrameSeen = mCurrentFrame.mnId;
                     nmatches--;
-                } else if (mCurrentFrame.mvpMapPoints[i]->Observations() > 0)
+                }
+                else if (mCurrentFrame.mvpMapPoints[i]->Observations() > 0)
                     nmatchesMap++;
             }
         }
 
-        if (mbOnlyTracking) {
+        if (mbOnlyTracking)
+        {
             mbVO = nmatchesMap < 10;
             return nmatches > 20;
         }
@@ -889,7 +1000,8 @@ namespace ORB_SLAM2 {
         return nmatchesMap >= 10;
     }
 
-    bool Tracking::TrackLocalMap() {
+    bool Tracking::TrackLocalMap()
+    {
         // We have an estimation of the camera pose and some map points tracked in the frame.
         // We retrieve the local map and try to find matches to points in the local map.
 
@@ -902,18 +1014,23 @@ namespace ORB_SLAM2 {
         mnMatchesInliers = 0;
 
         // Update MapPoints Statistics
-        for (int i = 0; i < mCurrentFrame.N; i++) {
-            if (mCurrentFrame.mvpMapPoints[i]) {
-                if (!mCurrentFrame.mvbOutlier[i]) {
+        for (int i = 0; i < mCurrentFrame.N; i++)
+        {
+            if (mCurrentFrame.mvpMapPoints[i])
+            {
+                if (!mCurrentFrame.mvbOutlier[i])
+                {
                     mCurrentFrame.mvpMapPoints[i]->IncreaseFound();
-                    if (!mbOnlyTracking) {
+                    if (!mbOnlyTracking)
+                    {
                         if (mCurrentFrame.mvpMapPoints[i]->Observations() > 0)
                             mnMatchesInliers++;
-                    } else
+                    }
+                    else
                         mnMatchesInliers++;
-                } else if (mSensor == System::STEREO)
+                }
+                else if (mSensor == System::STEREO)
                     mCurrentFrame.mvpMapPoints[i] = static_cast<MapPoint *>(NULL);
-
             }
         }
 
@@ -928,8 +1045,8 @@ namespace ORB_SLAM2 {
             return true;
     }
 
-
-    bool Tracking::NeedNewKeyFrame() {
+    bool Tracking::NeedNewKeyFrame()
+    {
         if (mbOnlyTracking)
             return false;
 
@@ -955,9 +1072,12 @@ namespace ORB_SLAM2 {
         // Check how many "close" points are being tracked and how many could be potentially created.
         int nNonTrackedClose = 0;
         int nTrackedClose = 0;
-        if (mSensor != System::MONOCULAR) {
-            for (int i = 0; i < mCurrentFrame.N; i++) {
-                if (mCurrentFrame.mvDepth[i] > 0 && mCurrentFrame.mvDepth[i] < mThDepth) {
+        if (mSensor != System::MONOCULAR)
+        {
+            for (int i = 0; i < mCurrentFrame.N; i++)
+            {
+                if (mCurrentFrame.mvDepth[i] > 0 && mCurrentFrame.mvDepth[i] < mThDepth)
+                {
                     if (mCurrentFrame.mvpMapPoints[i] && !mCurrentFrame.mvbOutlier[i])
                         nTrackedClose++;
                     else
@@ -980,31 +1100,39 @@ namespace ORB_SLAM2 {
         const bool c1a = mCurrentFrame.mnId >= mnLastKeyFrameId + mMaxFrames;
         // Condition 1b: More than "MinFrames" have passed and Local Mapping is idle
         const bool c1b = (mCurrentFrame.mnId >= mnLastKeyFrameId + mMinFrames && bLocalMappingIdle);
-        //Condition 1c: tracking is weak
+        // Condition 1c: tracking is weak
         const bool c1c = mSensor != System::MONOCULAR && (mnMatchesInliers < nRefMatches * 0.25 || bNeedToInsertClose);
         // Condition 2: Few tracked points compared to reference keyframe. Lots of visual odometry compared to map matches.
         const bool c2 = ((mnMatchesInliers < nRefMatches * thRefRatio || bNeedToInsertClose) && mnMatchesInliers > 15);
 
-        if ((c1a || c1b || c1c) && c2) {
+        if ((c1a || c1b || c1c) && c2)
+        {
             // If the mapping accepts keyframes, insert keyframe.
             // Otherwise send a signal to interrupt BA
-            if (bLocalMappingIdle) {
+            if (bLocalMappingIdle)
+            {
                 return true;
-            } else {
+            }
+            else
+            {
                 mpLocalMapper->InterruptBA();
-                if (mSensor != System::MONOCULAR) {
+                if (mSensor != System::MONOCULAR)
+                {
                     if (mpLocalMapper->KeyframesInQueue() < 3)
                         return true;
                     else
                         return false;
-                } else
+                }
+                else
                     return false;
             }
-        } else
+        }
+        else
             return false;
     }
 
-    void Tracking::CreateNewKeyFrame() {
+    void Tracking::CreateNewKeyFrame()
+    {
         if (!mpLocalMapper->SetNotStop(true))
             return;
 
@@ -1013,26 +1141,31 @@ namespace ORB_SLAM2 {
         mpReferenceKF = pKF;
         mCurrentFrame.mpReferenceKF = pKF;
 
-        if (mSensor != System::MONOCULAR) {
+        if (mSensor != System::MONOCULAR)
+        {
             mCurrentFrame.UpdatePoseMatrices();
 
             // We sort points by the measured depth by the stereo/RGBD sensor.
             // We create all those MapPoints whose depth < mThDepth.
             // If there are less than 100 close points we create the 100 closest.
-            vector<pair<float, int> > vDepthIdx;
+            vector<pair<float, int>> vDepthIdx;
             vDepthIdx.reserve(mCurrentFrame.N);
-            for (int i = 0; i < mCurrentFrame.N; i++) {
+            for (int i = 0; i < mCurrentFrame.N; i++)
+            {
                 float z = mCurrentFrame.mvDepth[i];
-                if (z > 0) {
+                if (z > 0)
+                {
                     vDepthIdx.push_back(make_pair(z, i));
                 }
             }
 
-            if (!vDepthIdx.empty()) {
+            if (!vDepthIdx.empty())
+            {
                 sort(vDepthIdx.begin(), vDepthIdx.end());
 
                 int nPoints = 0;
-                for (size_t j = 0; j < vDepthIdx.size(); j++) {
+                for (size_t j = 0; j < vDepthIdx.size(); j++)
+                {
                     int i = vDepthIdx[j].second;
 
                     bool bCreateNew = false;
@@ -1040,12 +1173,14 @@ namespace ORB_SLAM2 {
                     MapPoint *pMP = mCurrentFrame.mvpMapPoints[i];
                     if (!pMP)
                         bCreateNew = true;
-                    else if (pMP->Observations() < 1) {
+                    else if (pMP->Observations() < 1)
+                    {
                         bCreateNew = true;
                         mCurrentFrame.mvpMapPoints[i] = static_cast<MapPoint *>(NULL);
                     }
 
-                    if (bCreateNew) {
+                    if (bCreateNew)
+                    {
                         cv::Mat x3D = mCurrentFrame.UnprojectStereo(i);
                         MapPoint *pNewMP = new MapPoint(x3D, pKF, mpMap);
                         pNewMP->AddObservation(pKF, i);
@@ -1056,7 +1191,9 @@ namespace ORB_SLAM2 {
 
                         mCurrentFrame.mvpMapPoints[i] = pNewMP;
                         nPoints++;
-                    } else {
+                    }
+                    else
+                    {
                         nPoints++;
                     }
 
@@ -1074,15 +1211,21 @@ namespace ORB_SLAM2 {
         mpLastKeyFrame = pKF;
     }
 
-    void Tracking::SearchLocalPoints() {
+    void Tracking::SearchLocalPoints()
+    {
         // Do not search map points already matched
         for (vector<MapPoint *>::iterator vit = mCurrentFrame.mvpMapPoints.begin(), vend = mCurrentFrame.mvpMapPoints.end();
-             vit != vend; vit++) {
+             vit != vend; vit++)
+        {
             MapPoint *pMP = *vit;
-            if (pMP) {
-                if (pMP->isBad()) {
+            if (pMP)
+            {
+                if (pMP->isBad())
+                {
                     *vit = static_cast<MapPoint *>(NULL);
-                } else {
+                }
+                else
+                {
                     pMP->IncreaseVisible();
                     pMP->mnLastFrameSeen = mCurrentFrame.mnId;
                     pMP->mbTrackInView = false;
@@ -1094,20 +1237,23 @@ namespace ORB_SLAM2 {
 
         // Project points in frame and check its visibility
         for (vector<MapPoint *>::iterator vit = mvpLocalMapPoints.begin(), vend = mvpLocalMapPoints.end();
-             vit != vend; vit++) {
+             vit != vend; vit++)
+        {
             MapPoint *pMP = *vit;
             if (pMP->mnLastFrameSeen == mCurrentFrame.mnId)
                 continue;
             if (pMP->isBad())
                 continue;
             // Project (this fills MapPoint variables for matching)
-            if (mCurrentFrame.isInFrustum(pMP, 0.5)) {
+            if (mCurrentFrame.isInFrustum(pMP, 0.5))
+            {
                 pMP->IncreaseVisible();
                 nToMatch++;
             }
         }
 
-        if (nToMatch > 0) {
+        if (nToMatch > 0)
+        {
             ORBmatcher matcher(0.8);
             int th = 1;
             if (mSensor == System::RGBD)
@@ -1119,7 +1265,8 @@ namespace ORB_SLAM2 {
         }
     }
 
-    void Tracking::UpdateLocalMap() {
+    void Tracking::UpdateLocalMap()
+    {
         // This is for visualization
         mpMap->SetReferenceMapPoints(mvpLocalMapPoints);
 
@@ -1128,22 +1275,26 @@ namespace ORB_SLAM2 {
         UpdateLocalPoints();
     }
 
-    void Tracking::UpdateLocalPoints() {
+    void Tracking::UpdateLocalPoints()
+    {
         mvpLocalMapPoints.clear();
 
         for (vector<KeyFrame *>::const_iterator itKF = mvpLocalKeyFrames.begin(), itEndKF = mvpLocalKeyFrames.end();
-             itKF != itEndKF; itKF++) {
+             itKF != itEndKF; itKF++)
+        {
             KeyFrame *pKF = *itKF;
             const vector<MapPoint *> vpMPs = pKF->GetMapPointMatches();
 
             for (vector<MapPoint *>::const_iterator itMP = vpMPs.begin(), itEndMP = vpMPs.end();
-                 itMP != itEndMP; itMP++) {
+                 itMP != itEndMP; itMP++)
+            {
                 MapPoint *pMP = *itMP;
                 if (!pMP)
                     continue;
                 if (pMP->mnTrackReferenceForFrame == mCurrentFrame.mnId)
                     continue;
-                if (!pMP->isBad()) {
+                if (!pMP->isBad())
+                {
                     mvpLocalMapPoints.push_back(pMP);
                     pMP->mnTrackReferenceForFrame = mCurrentFrame.mnId;
                 }
@@ -1151,19 +1302,24 @@ namespace ORB_SLAM2 {
         }
     }
 
-
-    void Tracking::UpdateLocalKeyFrames() {
+    void Tracking::UpdateLocalKeyFrames()
+    {
         // Each map point vote for the keyframes in which it has been observed
         map<KeyFrame *, int> keyframeCounter;
-        for (int i = 0; i < mCurrentFrame.N; i++) {
-            if (mCurrentFrame.mvpMapPoints[i]) {
+        for (int i = 0; i < mCurrentFrame.N; i++)
+        {
+            if (mCurrentFrame.mvpMapPoints[i])
+            {
                 MapPoint *pMP = mCurrentFrame.mvpMapPoints[i];
-                if (!pMP->isBad()) {
+                if (!pMP->isBad())
+                {
                     const map<KeyFrame *, size_t> observations = pMP->GetObservations();
                     for (map<KeyFrame *, size_t>::const_iterator it = observations.begin(), itend = observations.end();
                          it != itend; it++)
                         keyframeCounter[it->first]++;
-                } else {
+                }
+                else
+                {
                     mCurrentFrame.mvpMapPoints[i] = NULL;
                 }
             }
@@ -1180,13 +1336,15 @@ namespace ORB_SLAM2 {
 
         // All keyframes that observe a map point are included in the local map. Also check which keyframe shares most points
         for (map<KeyFrame *, int>::const_iterator it = keyframeCounter.begin(), itEnd = keyframeCounter.end();
-             it != itEnd; it++) {
+             it != itEnd; it++)
+        {
             KeyFrame *pKF = it->first;
 
             if (pKF->isBad())
                 continue;
 
-            if (it->second > max) {
+            if (it->second > max)
+            {
                 max = it->second;
                 pKFmax = pKF;
             }
@@ -1195,10 +1353,10 @@ namespace ORB_SLAM2 {
             pKF->mnTrackReferenceForFrame = mCurrentFrame.mnId;
         }
 
-
         // Include also some not-already-included keyframes that are neighbors to already-included keyframes
         for (vector<KeyFrame *>::const_iterator itKF = mvpLocalKeyFrames.begin(), itEndKF = mvpLocalKeyFrames.end();
-             itKF != itEndKF; itKF++) {
+             itKF != itEndKF; itKF++)
+        {
             // Limit the number of keyframes
             if (mvpLocalKeyFrames.size() > 80)
                 break;
@@ -1208,10 +1366,13 @@ namespace ORB_SLAM2 {
             const vector<KeyFrame *> vNeighs = pKF->GetBestCovisibilityKeyFrames(10);
 
             for (vector<KeyFrame *>::const_iterator itNeighKF = vNeighs.begin(), itEndNeighKF = vNeighs.end();
-                 itNeighKF != itEndNeighKF; itNeighKF++) {
+                 itNeighKF != itEndNeighKF; itNeighKF++)
+            {
                 KeyFrame *pNeighKF = *itNeighKF;
-                if (!pNeighKF->isBad()) {
-                    if (pNeighKF->mnTrackReferenceForFrame != mCurrentFrame.mnId) {
+                if (!pNeighKF->isBad())
+                {
+                    if (pNeighKF->mnTrackReferenceForFrame != mCurrentFrame.mnId)
+                    {
                         mvpLocalKeyFrames.push_back(pNeighKF);
                         pNeighKF->mnTrackReferenceForFrame = mCurrentFrame.mnId;
                         break;
@@ -1220,10 +1381,13 @@ namespace ORB_SLAM2 {
             }
 
             const set<KeyFrame *> spChilds = pKF->GetChilds();
-            for (set<KeyFrame *>::const_iterator sit = spChilds.begin(), send = spChilds.end(); sit != send; sit++) {
+            for (set<KeyFrame *>::const_iterator sit = spChilds.begin(), send = spChilds.end(); sit != send; sit++)
+            {
                 KeyFrame *pChildKF = *sit;
-                if (!pChildKF->isBad()) {
-                    if (pChildKF->mnTrackReferenceForFrame != mCurrentFrame.mnId) {
+                if (!pChildKF->isBad())
+                {
+                    if (pChildKF->mnTrackReferenceForFrame != mCurrentFrame.mnId)
+                    {
                         mvpLocalKeyFrames.push_back(pChildKF);
                         pChildKF->mnTrackReferenceForFrame = mCurrentFrame.mnId;
                         break;
@@ -1232,23 +1396,26 @@ namespace ORB_SLAM2 {
             }
 
             KeyFrame *pParent = pKF->GetParent();
-            if (pParent) {
-                if (pParent->mnTrackReferenceForFrame != mCurrentFrame.mnId) {
+            if (pParent)
+            {
+                if (pParent->mnTrackReferenceForFrame != mCurrentFrame.mnId)
+                {
                     mvpLocalKeyFrames.push_back(pParent);
                     pParent->mnTrackReferenceForFrame = mCurrentFrame.mnId;
                     break;
                 }
             }
-
         }
 
-        if (pKFmax) {
+        if (pKFmax)
+        {
             mpReferenceKF = pKFmax;
             mCurrentFrame.mpReferenceKF = mpReferenceKF;
         }
     }
 
-    bool Tracking::Relocalization() {
+    bool Tracking::Relocalization()
+    {
         // Compute Bag of Words Vector
         mCurrentFrame.ComputeBoW();
 
@@ -1257,7 +1424,8 @@ namespace ORB_SLAM2 {
         // vector<KeyFrame *> vpCandidateKFs = mpKeyFrameDB->DetectRelocalizationCandidates(&mCurrentFrame);
         auto vpCandidateKFs = mpMap->GetAllKeyFrames();
 
-        if (vpCandidateKFs.empty()) {
+        if (vpCandidateKFs.empty())
+        {
             // std::cout << "No candidates" << std::endl;
             // std::cout << "Failed" << std::endl;
             return false;
@@ -1278,8 +1446,6 @@ namespace ORB_SLAM2 {
         // }
         // std::cout << std::endl;
 
-
-
         // We perform first an ORB matching with each candidate
         // If enough matches are found we setup a PnP solver
         ORBmatcher matcher(0.75, true);
@@ -1287,7 +1453,7 @@ namespace ORB_SLAM2 {
         vector<PnPsolver *> vpPnPsolvers;
         vpPnPsolvers.resize(nKFs);
 
-        vector<vector<MapPoint *> > vvpMapPointMatches;
+        vector<vector<MapPoint *>> vvpMapPointMatches;
         vvpMapPointMatches.resize(nKFs);
 
         vector<bool> vbDiscarded;
@@ -1295,16 +1461,21 @@ namespace ORB_SLAM2 {
 
         int nCandidates = 0;
 
-        for (int i = 0; i < nKFs; i++) {
+        for (int i = 0; i < nKFs; i++)
+        {
             KeyFrame *pKF = vpCandidateKFs[i];
             if (pKF->isBad())
                 vbDiscarded[i] = true;
-            else {
+            else
+            {
                 int nmatches = matcher.SearchByBoW(pKF, mCurrentFrame, vvpMapPointMatches[i]);
-                if (nmatches < 15) {
+                if (nmatches < 15)
+                {
                     vbDiscarded[i] = true;
                     continue;
-                } else {
+                }
+                else
+                {
                     // std::cout << "nmatches: " << nmatches << std::endl;
                     auto pSolver = new PnPsolver(mCurrentFrame, vvpMapPointMatches[i]);
                     pSolver->SetRansacParameters(0.99, 10, 300, 4, 0.5, 5.991);
@@ -1319,8 +1490,10 @@ namespace ORB_SLAM2 {
         bool bMatch = false;
         ORBmatcher matcher2(0.9, true);
 
-        while (nCandidates > 0 && !bMatch) {
-            for (int i = 0; i < nKFs; i++) {
+        while (nCandidates > 0 && !bMatch)
+        {
+            for (int i = 0; i < nKFs; i++)
+            {
                 if (vbDiscarded[i])
                     continue;
 
@@ -1333,13 +1506,15 @@ namespace ORB_SLAM2 {
                 cv::Mat Tcw = pSolver->iterate(5, bNoMore, vbInliers, nInliers);
 
                 // If Ransac reachs max. iterations discard keyframe
-                if (bNoMore) {
+                if (bNoMore)
+                {
                     vbDiscarded[i] = true;
                     nCandidates--;
                 }
 
                 // If a Camera Pose is computed, optimize
-                if (!Tcw.empty()) {
+                if (!Tcw.empty())
+                {
                     Tcw.copyTo(mCurrentFrame.mTcw);
 
                     set<MapPoint *> sFound;
@@ -1347,11 +1522,14 @@ namespace ORB_SLAM2 {
                     const int np = vbInliers.size();
                     // std::cout << "inliers: " << np << std::endl;
 
-                    for (int j = 0; j < np; j++) {
-                        if (vbInliers[j]) {
+                    for (int j = 0; j < np; j++)
+                    {
+                        if (vbInliers[j])
+                        {
                             mCurrentFrame.mvpMapPoints[j] = vvpMapPointMatches[i][j];
                             sFound.insert(vvpMapPointMatches[i][j]);
-                        } else
+                        }
+                        else
                             mCurrentFrame.mvpMapPoints[j] = nullptr;
                     }
 
@@ -1365,16 +1543,19 @@ namespace ORB_SLAM2 {
                             mCurrentFrame.mvpMapPoints[io] = static_cast<MapPoint *>(nullptr);
 
                     // If few inliers, search by projection in a coarse window and optimize again
-                    if (nGood < 50) {
+                    if (nGood < 50)
+                    {
                         int nadditional = matcher2.SearchByProjection(mCurrentFrame, vpCandidateKFs[i], sFound, 10,
                                                                       100);
 
-                        if (nadditional + nGood >= 50) {
+                        if (nadditional + nGood >= 50)
+                        {
                             nGood = Optimizer::PoseOptimization(&mCurrentFrame);
 
                             // If many inliers but still not enough, search by projection again in a narrower window
                             // the camera has been already optimized with many points
-                            if (nGood > 30 && nGood < 50) {
+                            if (nGood > 30 && nGood < 50)
+                            {
                                 sFound.clear();
                                 for (int ip = 0; ip < mCurrentFrame.N; ip++)
                                     if (mCurrentFrame.mvpMapPoints[ip])
@@ -1383,7 +1564,8 @@ namespace ORB_SLAM2 {
                                                                           64);
 
                                 // Final optimization
-                                if (nGood + nadditional >= 50) {
+                                if (nGood + nadditional >= 50)
+                                {
                                     nGood = Optimizer::PoseOptimization(&mCurrentFrame);
 
                                     for (int io = 0; io < mCurrentFrame.N; io++)
@@ -1394,9 +1576,9 @@ namespace ORB_SLAM2 {
                         }
                     }
 
-
                     // If the pose is supported by enough inliers stop ransacs and continue
-                    if (nGood >= 50) {
+                    if (nGood >= 50)
+                    {
                         bMatch = true;
                         break;
                     }
@@ -1404,13 +1586,16 @@ namespace ORB_SLAM2 {
             }
         }
 
-        if (!bMatch) {
+        if (!bMatch)
+        {
             // std::cout << "Failed here" << std::endl;
             return false;
-        } else {
+        }
+        else
+        {
             mnLastRelocFrameId = mCurrentFrame.mnId;
-            //return true;
-            // std::cout << "Success" << std::endl;
+            // return true;
+            //  std::cout << "Success" << std::endl;
             cv::Mat pose = mCurrentFrame.mTcw;
             cv::Mat R_wc = pose.rowRange(0, 3).colRange(0, 3);
             cv::Mat t_wc = pose.rowRange(0, 3).col(3);
@@ -1420,15 +1605,15 @@ namespace ORB_SLAM2 {
             // std::cout << twc << std::endl;
             return true;
         }
-
     }
 
-    void Tracking::Reset() {
+    void Tracking::Reset()
+    {
         mpViewer->RequestStop();
 
         cout << "System Reseting" << endl;
         while (!mpViewer->isStopped())
-            usleep(3000);
+            Sleep(3);
 
         // Reset Local Mapping
         cout << "Reseting Local Mapper...";
@@ -1452,7 +1637,8 @@ namespace ORB_SLAM2 {
         Frame::nNextId = 0;
         mState = NO_IMAGES_YET;
 
-        if (mpInitializer) {
+        if (mpInitializer)
+        {
             delete mpInitializer;
             mpInitializer = static_cast<Initializer *>(NULL);
         }
@@ -1465,7 +1651,8 @@ namespace ORB_SLAM2 {
         mpViewer->Release();
     }
 
-    void Tracking::ChangeCalibration(const string &strSettingPath) {
+    void Tracking::ChangeCalibration(const string &strSettingPath)
+    {
         cv::FileStorage fSettings(strSettingPath, cv::FileStorage::READ);
         float fx = fSettings["Camera.fx"];
         float fy = fSettings["Camera.fy"];
@@ -1485,7 +1672,8 @@ namespace ORB_SLAM2 {
         DistCoef.at<float>(2) = fSettings["Camera.p1"];
         DistCoef.at<float>(3) = fSettings["Camera.p2"];
         const float k3 = fSettings["Camera.k3"];
-        if (k3 != 0) {
+        if (k3 != 0)
+        {
             DistCoef.resize(5);
             DistCoef.at<float>(4) = k3;
         }
@@ -1496,9 +1684,9 @@ namespace ORB_SLAM2 {
         Frame::mbInitialComputations = true;
     }
 
-    void Tracking::InformOnlyTracking(const bool &flag) {
+    void Tracking::InformOnlyTracking(const bool &flag)
+    {
         mbOnlyTracking = flag;
     }
 
-
-} //namespace ORB_SLAM
+} // namespace ORB_SLAM
diff --git a/slam/src/Viewer.cc b/slam/src/Viewer.cc
index baf0278..69bed3d 100644
--- a/slam/src/Viewer.cc
+++ b/slam/src/Viewer.cc
@@ -1,22 +1,22 @@
 /**
-* This file is part of ORB-SLAM2.
-*
-* Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
-* For more information see <https://github.com/raulmur/ORB_SLAM2>
-*
-* ORB-SLAM2 is free software: you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation, either version 3 of the License, or
-* (at your option) any later version.
-*
-* ORB-SLAM2 is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
-*/
+ * This file is part of ORB-SLAM2.
+ *
+ * Copyright (C) 2014-2016 Ra├║l Mur-Artal <raulmur at unizar dot es> (University of Zaragoza)
+ * For more information see <https://github.com/raulmur/ORB_SLAM2>
+ *
+ * ORB-SLAM2 is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ORB-SLAM2 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ORB-SLAM2. If not, see <http://www.gnu.org/licenses/>.
+ */
 
 #include "Viewer.h"
 #include <pangolin/pangolin.h>
@@ -25,12 +25,13 @@
 
 #include "include/Auxiliary.h"
 
-namespace ORB_SLAM2 {
+namespace ORB_SLAM2
+{
 
     Viewer::Viewer(System *pSystem, FrameDrawer *pFrameDrawer, MapDrawer *pMapDrawer, Tracking *pTracking,
-                   const string &strSettingPath, bool bReuse, bool isPangolinExists) :
-            mpSystem(pSystem), mpFrameDrawer(pFrameDrawer), mpMapDrawer(pMapDrawer), mpTracker(pTracking),
-            mbFinishRequested(false), mbFinished(true), mbStopped(false), mbStopRequested(false) {
+                   const string &strSettingPath, bool bReuse, bool isPangolinExists) : mpSystem(pSystem), mpFrameDrawer(pFrameDrawer), mpMapDrawer(pMapDrawer), mpTracker(pTracking),
+                                                                                       mbFinishRequested(false), mbFinished(true), mbStopped(false), mbStopRequested(false)
+    {
         cv::FileStorage fSettings(strSettingPath, cv::FileStorage::READ);
 
         float fps = fSettings["Camera.fps"];
@@ -40,7 +41,8 @@ namespace ORB_SLAM2 {
 
         mImageWidth = fSettings["Camera.width"];
         mImageHeight = fSettings["Camera.height"];
-        if (mImageWidth < 1 || mImageHeight < 1) {
+        if (mImageWidth < 1 || mImageHeight < 1)
+        {
             mImageWidth = 640;
             mImageHeight = 480;
         }
@@ -76,24 +78,29 @@ namespace ORB_SLAM2 {
         // mRotateScale = data["rotateScale"];
     }
 
-    void Viewer::Run() {
+    void Viewer::Run()
+    {
         mbFinished = false;
-        if (isPangolinExists) {
+        if (isPangolinExists)
+        {
             pangolin::BindToContext("ORB-SLAM2: Map Viewer");
-        } else {
+        }
+        else
+        {
             pangolin::CreateWindowAndBind("ORB-SLAM2: Map Viewer", 1024, 768);
         }
-
-
         // 3D Mouse handler requires depth testing to be enabled
         glEnable(GL_DEPTH_TEST);
 
         // Issue specific OpenGl we might need
         glEnable(GL_BLEND);
         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-        if (isPangolinExists) {
+        if (isPangolinExists)
+        {
             pangolin::Panel("menu").SetBounds(0.0, 1.0, 0.0, pangolin::Attach::Pix(175));
-        } else {
+        }
+        else
+        {
             pangolin::CreatePanel("menu").SetBounds(0.0, 1.0, 0.0, pangolin::Attach::Pix(175));
         }
         pangolin::Var<bool> menuFollowCamera("menu.Follow Camera", true, true);
@@ -115,14 +122,13 @@ namespace ORB_SLAM2 {
 
         // Define Camera Render Object (for view / scene browsing)
         pangolin::OpenGlRenderState s_cam(
-                pangolin::ProjectionMatrix(1024, 768, mViewpointF, mViewpointF, 512, 389, 0.1, 1000),
-                pangolin::ModelViewLookAt(mViewpointX, mViewpointY, mViewpointZ, 0, 0, 0, 0.0, -1.0, 0.0)
-        );
+            pangolin::ProjectionMatrix(1024, 768, mViewpointF, mViewpointF, 512, 389, 0.1, 1000),
+            pangolin::ModelViewLookAt(mViewpointX, mViewpointY, mViewpointZ, 0, 0, 0, 0.0, -1.0, 0.0));
 
         // Add named OpenGL viewport to window and provide 3D Handler
         pangolin::View &d_cam = pangolin::CreateDisplay()
-                .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f)
-                .SetHandler(new pangolin::Handler3D(s_cam));
+                                    .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f)
+                                    .SetHandler(new pangolin::Handler3D(s_cam));
 
         pangolin::OpenGlMatrix Twc;
         Twc.SetIdentity();
@@ -132,7 +138,8 @@ namespace ORB_SLAM2 {
         bool bFollow = true;
         bool bLocalizationMode = mbReuse;
 
-        while (1) {
+        while (1)
+        {
             glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
             if (!menuOpenSimulator)
@@ -154,33 +161,40 @@ namespace ORB_SLAM2 {
                 Twc.m[13] = (float)mTwc.at<double>(13);
                 Twc.m[14] = (float)mTwc.at<double>(14);
             }
-
-            if (menuFollowCamera && bFollow) {
+            if (menuFollowCamera && bFollow)
+            {
                 s_cam.Follow(Twc);
-            } else if (menuFollowCamera && !bFollow) {
+            }
+            else if (menuFollowCamera && !bFollow)
+            {
                 s_cam.SetModelViewMatrix(
-                        pangolin::ModelViewLookAt(mViewpointX, mViewpointY, mViewpointZ, 0, 0, 0, 0.0, -1.0, 0.0));
+                    pangolin::ModelViewLookAt(mViewpointX, mViewpointY, mViewpointZ, 0, 0, 0, 0.0, -1.0, 0.0));
                 s_cam.Follow(Twc);
                 bFollow = true;
-            } else if (!menuFollowCamera && bFollow) {
+            }
+            else if (!menuFollowCamera && bFollow)
+            {
                 bFollow = false;
             }
 
-            if (menuLocalizationMode && !bLocalizationMode && !menuOpenSimulator) {
+            if (menuLocalizationMode && !bLocalizationMode && !menuOpenSimulator)
+            {
                 mpSystem->ActivateLocalizationMode();
                 bLocalizationMode = true;
-            } else if (!menuLocalizationMode && bLocalizationMode && !menuOpenSimulator) {
+            }
+            else if (!menuLocalizationMode && bLocalizationMode && !menuOpenSimulator)
+            {
                 mpSystem->DeactivateLocalizationMode();
                 bLocalizationMode = false;
             }
-
             d_cam.Activate(s_cam);
 
             glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
             // mpMapDrawer->DrawCurrentCamera(Twc);
             if (!menuOpenSimulator && (menuShowKeyFrames || menuShowGraph))
                 mpMapDrawer->DrawKeyFrames(menuShowKeyFrames, menuShowGraph);
-            if (menuShowPoints) {
+            if (menuShowPoints)
+            {
                 if (!menuOpenSimulator)
                 {
                     mpMapDrawer->DrawMapPoints();
@@ -189,19 +203,16 @@ namespace ORB_SLAM2 {
                 {
                     mpMapDrawer->DrawMapPoints(true, mPointsSeen, mNewPointsSeen);
                 }
-                
             }
-
             pangolin::FinishFrame();
-
             if (!menuOpenSimulator)
             {
-                if (mpFrameDrawer != nullptr){
+                if (mpFrameDrawer != nullptr)
+                {
                     cv::Mat im = mpFrameDrawer->DrawFrame();
                     cv::imshow("ORB-SLAM2: Current Frame", im);
                     cv::waitKey(mT);
                 }
-
             }
 
             if (menuMoveLeft)
@@ -381,7 +392,8 @@ namespace ORB_SLAM2 {
                 menuRotateUp = false;
             }
 
-            if (menuReset) {
+            if (menuReset)
+            {
                 menuShowGraph = true;
                 menuShowKeyFrames = true;
                 menuShowPoints = true;
@@ -404,13 +416,16 @@ namespace ORB_SLAM2 {
                 mPointsSeen = std::vector<cv::Point3d>();
             }
 
-            if (menuShutDown) {
+            if (menuShutDown)
+            {
                 mpSystem->shutdown_requested = true;
             }
 
-            if (Stop()) {
-                while (isStopped()) {
-                    usleep(3000);
+            if (Stop())
+            {
+                while (isStopped())
+                {
+                    Sleep(3);
                 }
             }
 
@@ -421,54 +436,62 @@ namespace ORB_SLAM2 {
         SetFinish();
     }
 
-    void Viewer::RequestFinish() {
+    void Viewer::RequestFinish()
+    {
         unique_lock<mutex> lock(mMutexFinish);
         mbFinishRequested = true;
     }
 
-    bool Viewer::CheckFinish() {
+    bool Viewer::CheckFinish()
+    {
         unique_lock<mutex> lock(mMutexFinish);
         return mbFinishRequested;
     }
 
-    void Viewer::SetFinish() {
+    void Viewer::SetFinish()
+    {
         unique_lock<mutex> lock(mMutexFinish);
         mbFinished = true;
     }
 
-    bool Viewer::isFinished() {
+    bool Viewer::isFinished()
+    {
         unique_lock<mutex> lock(mMutexFinish);
         return mbFinished;
     }
 
-    void Viewer::RequestStop() {
+    void Viewer::RequestStop()
+    {
         unique_lock<mutex> lock(mMutexStop);
         if (!mbStopped)
             mbStopRequested = true;
     }
 
-    bool Viewer::isStopped() {
+    bool Viewer::isStopped()
+    {
         unique_lock<mutex> lock(mMutexStop);
         return mbStopped;
     }
 
-    bool Viewer::Stop() {
+    bool Viewer::Stop()
+    {
         unique_lock<mutex> lock(mMutexStop);
         unique_lock<mutex> lock2(mMutexFinish);
 
         if (mbFinishRequested)
             return false;
-        else if (mbStopRequested) {
+        else if (mbStopRequested)
+        {
             mbStopped = true;
             mbStopRequested = false;
             return true;
         }
 
         return false;
-
     }
 
-    void Viewer::Release() {
+    void Viewer::Release()
+    {
         unique_lock<mutex> lock(mMutexStop);
         mbStopped = false;
     }
diff --git a/tools/bin_vocabulary.cc b/tools/bin_vocabulary.cc
index 0c1c53a..57cd322 100644
--- a/tools/bin_vocabulary.cc
+++ b/tools/bin_vocabulary.cc
@@ -16,11 +16,11 @@ void load_as_xml(ORB_SLAM2::ORBVocabulary* voc, const std::string infile) {
   printf("Loading fom xml: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC);
 }
 
-void load_as_binary(ORB_SLAM2::ORBVocabulary* voc, const std::string infile) {
+/*void load_as_binary(ORB_SLAM2::ORBVocabulary* voc, const std::string infile) {
   clock_t tStart = clock();
   voc->loadFromBinaryFile(infile);
   printf("Loading fom binary: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC);
-}
+}*/
 
 void save_as_xml(ORB_SLAM2::ORBVocabulary* voc, const std::string outfile) {
   clock_t tStart = clock();
diff --git a/tools/simulator.cpp b/tools/simulator.cpp
index 18e369a..e058678 100644
--- a/tools/simulator.cpp
+++ b/tools/simulator.cpp
@@ -4,7 +4,8 @@
 
 #include "simulator.h"
 
-cv::Mat Simulator::getCurrentLocation() {
+cv::Mat Simulator::getCurrentLocation()
+{
     locationLock.lock();
     cv::Mat locationCopy = Tcw.clone();
     locationLock.unlock();
@@ -20,7 +21,8 @@ Simulator::Simulator(std::string ORBSLAMConfigFile, std::string model_path, std:
                                             movementFactor(movementFactor), modelPath(model_path), modelTextureNameToAlignTo(modelTextureNameToAlignTo),
                                             isSaveMap(saveMap),
                                             trackImages(trackImages), cull_backfaces(false),
-                                            viewportDesiredSize(640, 480) {
+                                            viewportDesiredSize(640, 480)
+{
     cv::FileStorage fSettings(ORBSLAMConfigFile, cv::FileStorage::READ);
 
     float fx = fSettings["Camera.fx"];
@@ -37,75 +39,89 @@ Simulator::Simulator(std::string ORBSLAMConfigFile, std::string model_path, std:
                                                mapLoadPath,
                                                true);
     K << fx, 0.0, cx, 0.0, fy, cy, 0.0, 0.0, 1.0;
-    orbExtractor = new ORB_SLAM2::ORBextractor(nFeatures, fScaleFactor, nLevels, fIniThFAST, fMinThFAST);
-    char time_buf[21];
-    time_t now;
-    std::time(&now);
-    std::strftime(time_buf, 21, "%Y-%m-%d_%H:%S:%MZ", gmtime(&now));
-    std::string currentTime(time_buf);
-    simulatorOutputDir = simulatorOutputDirPath + "/" + currentTime + "/";
-    std::filesystem::create_directory(simulatorOutputDir);
-
+    orbExtractor = std::make_shared<ORB_SLAM2::ORBextractor>(nFeatures, fScaleFactor, nLevels, fIniThFAST, fMinThFAST);
 }
 
-void Simulator::command(std::string &command, int intervalUsleep, double fps, int totalCommandTimeInSeconds) {
+void Simulator::command(std::string &command, int intervalUsleep, double fps, int totalCommandTimeInSeconds)
+{
     std::istringstream iss(command);
     std::string c;
     double value;
     iss >> c;
-    if (commandMap.count(c) && commandMap[c]) {
+    if (commandMap.count(c) && commandMap[c])
+    {
 
         std::string stringValue;
         iss >> stringValue;
         value = std::stod(stringValue);
         applyCommand(c, value, intervalUsleep, fps, totalCommandTimeInSeconds);
-    } else {
+    }
+    else
+    {
         std::cout << "the command " << c << " is not supported and will be skipped" << std::endl;
     }
 }
+void Simulator::simulatorRunThread()
+{
+    pangolin::CreateWindowAndBind("Model");
 
-void Simulator::simulatorRunThread() {
-    pangolin::CreateWindowAndBind("Main", viewportDesiredSize[0], viewportDesiredSize[1]);
+    // we manually need to restore the properties of the context
     glEnable(GL_DEPTH_TEST);
     s_cam = pangolin::OpenGlRenderState(
-            pangolin::ProjectionMatrix(viewportDesiredSize(0), viewportDesiredSize(1), K(0, 0), K(1, 1), K(0, 2),
-                                       K(1, 2), 0.1, 20),
-            pangolin::ModelViewLookAt(0.1, -0.1, 0.3, 0, 0, 0, 0.0, -1.0,
-                                      pangolin::AxisY)); // the first 3 value are meaningless because we change them later
+        pangolin::ProjectionMatrix(viewportDesiredSize(0), viewportDesiredSize(1), K(0, 0), K(1, 1), K(0, 2),
+                                   K(1, 2), 0.1, 20),
+        pangolin::ModelViewLookAt(0.1, -0.1, 0.3, 0, 0, 0, 0.0, -1.0,
+                                  pangolin::AxisY)); // the first 3 value are meaningless because we change them later
 
     bool show_bounds = false;
     bool show_axis = false;
     bool show_x0 = false;
     bool show_y0 = false;
     bool show_z0 = false;
-    pangolin::RegisterKeyPressCallback('b', [&]() { show_bounds = !show_bounds; });
-    pangolin::RegisterKeyPressCallback('0', [&]() { cull_backfaces = !cull_backfaces; });
-    pangolin::RegisterKeyPressCallback('a', [&]() { show_axis = !show_axis; });
-    pangolin::RegisterKeyPressCallback('k', [&]() { stopFlag = !stopFlag; });
-    pangolin::RegisterKeyPressCallback('t', [&]() { track = !track; });
-    pangolin::RegisterKeyPressCallback('m', [&]() { saveMapSignal = !saveMapSignal; });
-    pangolin::RegisterKeyPressCallback('x', [&]() { show_x0 = !show_x0; });
-    pangolin::RegisterKeyPressCallback('y', [&]() { show_y0 = !show_y0; });
-    pangolin::RegisterKeyPressCallback('z', [&]() { show_z0 = !show_z0; });
-    pangolin::RegisterKeyPressCallback('w', [&]() { applyForwardToModelCam(s_cam, movementFactor); });
-    pangolin::RegisterKeyPressCallback('a', [&]() { applyRightToModelCam(s_cam, movementFactor); });
-    pangolin::RegisterKeyPressCallback('s', [&]() { applyForwardToModelCam(s_cam, -movementFactor); });
-    pangolin::RegisterKeyPressCallback('d', [&]() { applyRightToModelCam(s_cam, -movementFactor); });
-    pangolin::RegisterKeyPressCallback('e', [&]() { applyYawRotationToModelCam(s_cam, 1); });
-    pangolin::RegisterKeyPressCallback('q', [&]() { applyYawRotationToModelCam(s_cam, -1); });
-    pangolin::RegisterKeyPressCallback('r', [&]() {
-        applyUpModelCam(s_cam, -movementFactor);
-    });// ORBSLAM y axis is reversed
-    pangolin::RegisterKeyPressCallback('f', [&]() { applyUpModelCam(s_cam, movementFactor); });
+    pangolin::RegisterKeyPressCallback('b', [&]()
+                                       { show_bounds = !show_bounds; });
+    pangolin::RegisterKeyPressCallback('0', [&]()
+                                       { cull_backfaces = !cull_backfaces; });
+    pangolin::RegisterKeyPressCallback('a', [&]()
+                                       { show_axis = !show_axis; });
+    pangolin::RegisterKeyPressCallback('k', [&]()
+                                       { stopFlag = !stopFlag; });
+    pangolin::RegisterKeyPressCallback('t', [&]()
+                                       { track = !track; });
+    pangolin::RegisterKeyPressCallback('m', [&]()
+                                       { saveMapSignal = !saveMapSignal; });
+    pangolin::RegisterKeyPressCallback('x', [&]()
+                                       { show_x0 = !show_x0; });
+    pangolin::RegisterKeyPressCallback('y', [&]()
+                                       { show_y0 = !show_y0; });
+    pangolin::RegisterKeyPressCallback('z', [&]()
+                                       { show_z0 = !show_z0; });
+    pangolin::RegisterKeyPressCallback('w', [&]()
+                                       { applyForwardToModelCam(s_cam, movementFactor); });
+    pangolin::RegisterKeyPressCallback('a', [&]()
+                                       { applyRightToModelCam(s_cam, movementFactor); });
+    pangolin::RegisterKeyPressCallback('s', [&]()
+                                       { applyForwardToModelCam(s_cam, -movementFactor); });
+    pangolin::RegisterKeyPressCallback('d', [&]()
+                                       { applyRightToModelCam(s_cam, -movementFactor); });
+    pangolin::RegisterKeyPressCallback('e', [&]()
+                                       { applyYawRotationToModelCam(s_cam, 1); });
+    pangolin::RegisterKeyPressCallback('q', [&]()
+                                       { applyYawRotationToModelCam(s_cam, -1); });
+    pangolin::RegisterKeyPressCallback('r', [&]()
+                                       { applyUpModelCam(s_cam, -movementFactor); }); // ORBSLAM y axis is reversed
+    pangolin::RegisterKeyPressCallback('f', [&]()
+                                       { applyUpModelCam(s_cam, movementFactor); });
     const pangolin::Geometry modelGeometry = pangolin::LoadGeometry(modelPath);
     alignModelViewPointToSurface(modelGeometry, modelTextureNameToAlignTo);
     geomToRender = pangolin::ToGlGeometry(modelGeometry);
-    for (auto &buffer: geomToRender.buffers) {
+    for (auto &buffer : geomToRender.buffers)
+    {
         buffer.second.attributes.erase("normal");
     }
-    cv::Mat img;
 
-    auto LoadProgram = [&]() {
+    auto LoadProgram = [&]()
+    {
         program.ClearShaders();
         program.AddShader(pangolin::GlSlAnnotatedShader, pangolin::shader);
         program.Link();
@@ -113,20 +129,25 @@ void Simulator::simulatorRunThread() {
     LoadProgram();
     pangolin::Handler3D handler(s_cam);
     pangolin::View &d_cam = pangolin::CreateDisplay()
-            .SetBounds(0.0, 1.0, 0.0, 1.0, ((float) -viewportDesiredSize[0] / (float) viewportDesiredSize[1]))
-            .SetHandler(&handler);
+                                .SetBounds(0.0, 1.0, 0.0, 1.0, ((float)-viewportDesiredSize[0] / (float)viewportDesiredSize[1]))
+                                .SetHandler(&handler);
     int numberOfFramesForOrbslam = 0;
-    while (!pangolin::ShouldQuit() && !stopFlag) {
+    while (!pangolin::ShouldQuit() && !stopFlag)
+    {
+        cv::Mat img;
         ready = true;
         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-
-        if (d_cam.IsShown()) {
+        if (d_cam.IsShown())
+        {
             d_cam.Activate();
 
-            if (cull_backfaces) {
+            if (cull_backfaces)
+            {
                 glEnable(GL_CULL_FACE);
                 glCullFace(GL_BACK);
             }
+            
+
             program.Bind();
             program.SetUniform("KT_cw", s_cam.GetProjectionMatrix() * s_cam.GetModelViewMatrix());
             pangolin::GlDraw(program, geomToRender, nullptr);
@@ -143,15 +164,21 @@ void Simulator::simulatorRunThread() {
             glReadPixels(0, 0, viewport_size[2], viewport_size[3], GL_RGBA, GL_UNSIGNED_BYTE, buffer.ptr);
 
             cv::Mat imgBuffer = cv::Mat(viewport_size[3], viewport_size[2], CV_8UC4, buffer.ptr);
-            cv::cvtColor(imgBuffer, img, cv::COLOR_RGBA2GRAY);
+            if(!imgBuffer.empty()){
+                cv::cvtColor(imgBuffer, img, cv::COLOR_RGBA2GRAY);
             img.convertTo(img, CV_8UC1);
             cv::flip(img, img, 0);
+            }
+            s_cam.Apply();
 
+            glDisable(GL_CULL_FACE);
+             pangolin::FinishFrame();
             auto now = std::chrono::system_clock::now();
             auto now_ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);
             auto value = now_ms.time_since_epoch();
             double timestamp = value.count() / 1000.0;
-            if (saveMapSignal) {
+            if (saveMapSignal)
+            {
                 saveMapSignal = false;
                 char time_buf[21];
                 time_t now_t;
@@ -163,11 +190,14 @@ void Simulator::simulatorRunThread() {
                 std::cout << "new map saved to " << simulatorOutputDir + "/simulatorCloudPoint" + currentTime + ".bin"
                           << std::endl;
             }
-            if (track) {
+            if(!img.empty()){
                 locationLock.lock();
-                if (trackImages){
+                if (trackImages)
+                {
                     Tcw = SLAM->TrackMonocular(img, timestamp);
-                }else{
+                }
+                else
+                {
                     std::vector<cv::KeyPoint> pts;
                     cv::Mat mDescriptors;
                     orbExtractor->operator()(img, cv::Mat(), pts, mDescriptors);
@@ -176,37 +206,42 @@ void Simulator::simulatorRunThread() {
 
                 locationLock.unlock();
             }
+            
 
-            s_cam.Apply();
 
-            glDisable(GL_CULL_FACE);
+            //             drawPoints(seenPoints, keypoint_points);
+        }else{
+            s_cam.Apply();
+        pangolin::FinishFrame();
 
-//             drawPoints(seenPoints, keypoint_points);
         }
 
-        pangolin::FinishFrame();
     }
-    if (isSaveMap) {
+    if (isSaveMap)
+    {
 
         saveMap("final");
         SLAM->SaveMap(simulatorOutputDir + "/finalSimulatorCloudPoint.bin");
         std::cout << "new map saved to " << simulatorOutputDir + "/finalSimulatorCloudPoint.bin" << std::endl;
-
     }
     SLAM->Shutdown();
 }
 
-std::thread Simulator::run() {
+std::thread Simulator::run()
+{
     std::thread thread(&Simulator::simulatorRunThread, this);
     return thread;
 }
 
-void Simulator::saveMap(std::string prefix) {
+void Simulator::saveMap(std::string prefix)
+{
     std::ofstream pointData;
 
     pointData.open(simulatorOutputDir + "/cloud" + prefix + ".csv");
-    for (auto &p: SLAM->GetMap()->GetAllMapPoints()) {
-        if (p != nullptr && !p->isBad()) {
+    for (auto &p : SLAM->GetMap()->GetAllMapPoints())
+    {
+        if (p != nullptr && !p->isBad())
+        {
             auto point = p->GetWorldPos();
             Eigen::Matrix<double, 3, 1> vector = ORB_SLAM2::Converter::toVector3d(point);
             cv::Mat worldPos = cv::Mat::zeros(3, 1, CV_64F);
@@ -220,9 +255,11 @@ void Simulator::saveMap(std::string prefix) {
             pointData << "," << p->GetMinDistanceInvariance() << "," << p->GetMaxDistanceInvariance() << ","
                       << Pn.at<double>(0) << "," << Pn.at<double>(1) << "," << Pn.at<double>(2);
             std::map<ORB_SLAM2::KeyFrame *, size_t> observations = p->GetObservations();
-            for (auto obs: observations) {
+            for (auto &obs : observations)
+            {
                 ORB_SLAM2::KeyFrame *currentFrame = obs.first;
-                if (!currentFrame->image.empty()) {
+                if (!currentFrame->image.empty())
+                {
                     size_t pointIndex = obs.second;
                     cv::KeyPoint keyPoint = currentFrame->mvKeysUn[pointIndex];
                     cv::Point2f featurePoint = keyPoint.pt;
@@ -233,18 +270,22 @@ void Simulator::saveMap(std::string prefix) {
         }
     }
     pointData.close();
-
 }
 
 void Simulator::extractSurface(const pangolin::Geometry &modelGeometry, std::string modelTextureNameToAlignTo,
-                               Eigen::MatrixXf &surface) {
+                               Eigen::MatrixXf &surface)
+{
     std::vector<Eigen::Vector3<unsigned int>> surfaceIndices;
-    for (auto &o: modelGeometry.objects) {
-        if (o.first == modelTextureNameToAlignTo) {
+    for (auto &o : modelGeometry.objects)
+    {
+        if (o.first == modelTextureNameToAlignTo)
+        {
             const auto &it_vert = o.second.attributes.find("vertex_indices");
-            if (it_vert != o.second.attributes.end()) {
+            if (it_vert != o.second.attributes.end())
+            {
                 const auto &vs = std::get<pangolin::Image<unsigned int>>(it_vert->second);
-                for (size_t i = 0; i < vs.h; ++i) {
+                for (size_t i = 0; i < vs.h; ++i)
+                {
                     const Eigen::Map<const Eigen::Vector3<unsigned int>> v(vs.RowPtr(i));
                     surfaceIndices.emplace_back(v);
                 }
@@ -253,12 +294,16 @@ void Simulator::extractSurface(const pangolin::Geometry &modelGeometry, std::str
     }
     surface = Eigen::MatrixXf(surfaceIndices.size() * 3, 3);
     int currentIndex = 0;
-    for (const auto &b: modelGeometry.buffers) {
+    for (const auto &b : modelGeometry.buffers)
+    {
         const auto &it_vert = b.second.attributes.find("vertex");
-        if (it_vert != b.second.attributes.end()) {
+        if (it_vert != b.second.attributes.end())
+        {
             const auto &vs = std::get<pangolin::Image<float>>(it_vert->second);
-            for (auto &row: surfaceIndices) {
-                for (auto &i: row) {
+            for (auto &row : surfaceIndices)
+            {
+                for (auto &i : row)
+                {
                     const Eigen::Map<const Eigen::Vector3f> v(vs.RowPtr(i));
                     surface.row(currentIndex++) = v;
                 }
@@ -267,17 +312,19 @@ void Simulator::extractSurface(const pangolin::Geometry &modelGeometry, std::str
     }
 }
 
-void Simulator::applyPitchRotationToModelCam(pangolin::OpenGlRenderState &cam, double value) {
+void Simulator::applyPitchRotationToModelCam(pangolin::OpenGlRenderState &cam, double value)
+{
     double rand = double(value) * (M_PI / 180);
     double c = std::cos(rand);
     double s = std::sin(rand);
 
     Eigen::Matrix3d R;
     R << 1, 0, 0,
-            0, c, -s,
-            0, s, c;
+        0, c, -s,
+        0, s, c;
 
-    Eigen::Matrix4d pangolinR = Eigen::Matrix4d::Identity();;
+    Eigen::Matrix4d pangolinR = Eigen::Matrix4d::Identity();
+    ;
     pangolinR.block<3, 3>(0, 0) = R;
 
     auto camMatrix = pangolin::ToEigen<double>(cam.GetModelViewMatrix());
@@ -287,8 +334,10 @@ void Simulator::applyPitchRotationToModelCam(pangolin::OpenGlRenderState &cam, d
 
     // Convert back to pangolin matrix and set
     pangolin::OpenGlMatrix newModelView;
-    for (int i = 0; i < 4; ++i) {
-        for (int j = 0; j < 4; ++j) {
+    for (int i = 0; i < 4; ++i)
+    {
+        for (int j = 0; j < 4; ++j)
+        {
             newModelView.m[j * 4 + i] = camMatrix(i, j);
         }
     }
@@ -297,74 +346,96 @@ void Simulator::applyPitchRotationToModelCam(pangolin::OpenGlRenderState &cam, d
 }
 
 void Simulator::intervalOverCommand(
-        const std::function<void(pangolin::OpenGlRenderState &, double &)> &func, double value,
-        int intervalUsleep, double fps, int totalCommandTimeInSeconds) {
+    const std::function<void(pangolin::OpenGlRenderState &, double &)> &func, double value,
+    int intervalUsleep, double fps, int totalCommandTimeInSeconds)
+{
     double intervalValue = value / (fps * totalCommandTimeInSeconds);
     int intervalIndex = 0;
-    while (intervalIndex <= fps * totalCommandTimeInSeconds) {
-        usleep(intervalUsleep);
+    while (intervalIndex <= fps * totalCommandTimeInSeconds)
+    {
+        Sleep(intervalUsleep);
         func(s_cam, intervalValue);
         intervalIndex += 1;
     }
 }
 
 void Simulator::applyCommand(std::string &command, double value, int intervalUsleep, double fps,
-                             int totalCommandTimeInSeconds) {
-    if (command == "cw") {
+                             int totalCommandTimeInSeconds)
+{
+    if (command == "cw")
+    {
         intervalOverCommand(Simulator::applyYawRotationToModelCam, value, intervalUsleep, fps,
                             totalCommandTimeInSeconds);
-    } else if (command == "ccw") {
+    }
+    else if (command == "ccw")
+    {
         intervalOverCommand(Simulator::applyYawRotationToModelCam, -1 * value,
                             intervalUsleep, fps,
                             totalCommandTimeInSeconds);
-    } else if (command == "forward") {
+    }
+    else if (command == "forward")
+    {
         intervalOverCommand(Simulator::applyForwardToModelCam, value, intervalUsleep, fps,
                             totalCommandTimeInSeconds);
-    } else if (command == "back") {
+    }
+    else if (command == "back")
+    {
         intervalOverCommand(Simulator::applyForwardToModelCam, -1 * value, intervalUsleep,
                             fps, totalCommandTimeInSeconds);
-    } else if (command == "right") {
+    }
+    else if (command == "right")
+    {
         intervalOverCommand(Simulator::applyRightToModelCam, -1 * value, intervalUsleep,
                             fps, totalCommandTimeInSeconds);
-    } else if (command == "left") {
+    }
+    else if (command == "left")
+    {
         intervalOverCommand(Simulator::applyRightToModelCam, value, intervalUsleep, fps,
                             totalCommandTimeInSeconds);
-    } else if (command == "up") {
+    }
+    else if (command == "up")
+    {
         intervalOverCommand(Simulator::applyUpModelCam, -1 * value, intervalUsleep, fps,
                             totalCommandTimeInSeconds);
-    } else if (command == "down") {
+    }
+    else if (command == "down")
+    {
         intervalOverCommand(Simulator::applyUpModelCam, value, intervalUsleep, fps,
                             totalCommandTimeInSeconds);
     }
 }
 
-void Simulator::applyUpModelCam(pangolin::OpenGlRenderState &cam, double value) {
+void Simulator::applyUpModelCam(pangolin::OpenGlRenderState &cam, double value)
+{
     auto camMatrix = pangolin::ToEigen<double>(cam.GetModelViewMatrix());
     camMatrix(1, 3) += value;
     cam.SetModelViewMatrix(camMatrix);
 }
 
-void Simulator::applyForwardToModelCam(pangolin::OpenGlRenderState &cam, double value) {
+void Simulator::applyForwardToModelCam(pangolin::OpenGlRenderState &cam, double value)
+{
     auto camMatrix = pangolin::ToEigen<double>(cam.GetModelViewMatrix());
     camMatrix(2, 3) += value;
     cam.SetModelViewMatrix(camMatrix);
 }
 
-void Simulator::applyRightToModelCam(pangolin::OpenGlRenderState &cam, double value) {
+void Simulator::applyRightToModelCam(pangolin::OpenGlRenderState &cam, double value)
+{
     auto camMatrix = pangolin::ToEigen<double>(cam.GetModelViewMatrix());
     camMatrix(0, 3) += value;
     cam.SetModelViewMatrix(camMatrix);
 }
 
-void Simulator::applyYawRotationToModelCam(pangolin::OpenGlRenderState &cam, double value) {
+void Simulator::applyYawRotationToModelCam(pangolin::OpenGlRenderState &cam, double value)
+{
     double rand = double(value) * (M_PI / 180);
     double c = std::cos(rand);
     double s = std::sin(rand);
 
     Eigen::Matrix3d R;
     R << c, 0, s,
-            0, 1, 0,
-            -s, 0, c;
+        0, 1, 0,
+        -s, 0, c;
 
     Eigen::Matrix4d pangolinR = Eigen::Matrix4d::Identity();
     pangolinR.block<3, 3>(0, 0) = R;
@@ -376,8 +447,10 @@ void Simulator::applyYawRotationToModelCam(pangolin::OpenGlRenderState &cam, dou
 
     // Convert back to pangolin matrix and set
     pangolin::OpenGlMatrix newModelView;
-    for (int i = 0; i < 4; ++i) {
-        for (int j = 0; j < 4; ++j) {
+    for (int i = 0; i < 4; ++i)
+    {
+        for (int j = 0; j < 4; ++j)
+        {
             newModelView.m[j * 4 + i] = camMatrix(i, j);
         }
     }
@@ -385,9 +458,9 @@ void Simulator::applyYawRotationToModelCam(pangolin::OpenGlRenderState &cam, dou
     cam.SetModelViewMatrix(newModelView);
 }
 
-void
-Simulator::alignModelViewPointToSurface(const pangolin::Geometry &modelGeometry,
-                                        std::string modelTextureNameToAlignTo) {
+void Simulator::alignModelViewPointToSurface(const pangolin::Geometry &modelGeometry,
+                                             std::string modelTextureNameToAlignTo)
+{
     Eigen::MatrixXf surface;
     extractSurface(modelGeometry, modelTextureNameToAlignTo, surface);
     Eigen::JacobiSVD<Eigen::MatrixXf> svd(surface, Eigen::ComputeThinU | Eigen::ComputeThinV);
diff --git a/tools/simulator.h b/tools/simulator.h
index a433677..e24ec0c 100644
--- a/tools/simulator.h
+++ b/tools/simulator.h
@@ -11,6 +11,7 @@
 #include <pangolin/gl/glsl.h>
 #include <pangolin/gl/glvbo.h>
 #include <functional>
+#include <pangolin/display/display.h>
 
 #include <pangolin/utils/file_utils.h>
 #include <pangolin/geometry/glgeometry.h>
@@ -37,156 +38,156 @@
  *  - On-the-fly ORBSLAM2 map generation and navigation from the 3D model, and extraction of current location and full map.
  *  - Real-time visualization using Pangolin
  */
-class Simulator {
+class Simulator
+{
 public:
-    /**
- * Constructs a Simulator instance with specified parameters, and loads the ORBSLAM2 object.
- *
- * @param ORBSLAMConfigFile: A string representing the path to the ORBSLAM2 configuration file, an example can be found in the "config" folder in the project.
- *
- * @param model_path: A string representing the path to the 3D blender model used for simulation.
- *
- * @param modelTextureNameToAlignTo: A string representing the texture name used for alignment in the 3D model.
- *
- * @param saveMap: A boolean to determine whether the generated SLAM map should be saved or not. Defaults to false if not specified.
- *
- * @param simulatorOutputDirPath: A string representing the output directory for saving SLAM maps. Defaults to "../slamMaps/" if not specified.
- *
- * @param loadMap: A boolean to determine whether to load a previously saved SLAM map. Defaults to false if not specified.
- *
- * @param mapLoadPath: A string representing the path to a previously saved SLAM map to load. Defaults to "../slamMaps/example.bin" if not specified.
- *
- * @param movementFactor: A double value representing the movement speed in the simulator. Defaults to 0.01 if not specified.
- *
- * @param vocPath: A string representing the path to the ORBSLAM2 vocabulary file. Defaults to "../Vocabulary/ORBvoc.txt" if not specified.
- */
-    Simulator(std::string ORBSLAMConfigFile, std::string model_path, std::string modelTextureNameToAlignTo,bool trackImages = true,
-              bool saveMap = false, std::string simulatorOutputDirPath = "../slamMaps/", bool loadMap = false,
-              std::string mapLoadPath = "../slamMaps/example.bin",
-              double movementFactor = 0.01,
-              std::string vocPath = "../Vocabulary/ORBvoc.txt");
-
-/**
- *Starts the 3D model viewer (pangolin), and wait for the user or code signal to start sending the view to the ORBSLAM2 object
- * */
-    std::thread run();
-/**
- * sample the simulator state, this changes from false to true once the model is loaded
- * @return is the simulator is ready
- * */
-    bool isReady(){return ready;}
-
-    /**
- * @brief Fetches the current location matrix from ORBSLAM2.
- *
- * @return A 4x4 location matrix where:
- * - The first 3x3 sub-matrix represents the rotation matrix.
- * - The last column represents the translation vector.
- * - The y-axis indicates the height in reverse (i.e., negative values correspond to upward direction).
- */
-    cv::Mat getCurrentLocation();
-/**
- * @brief Retrieves the current map from ORBSLAM2.
- *
- * @return A vector of pointers to ORB_SLAM2::MapPoint objects.
- */
-    std::vector<ORB_SLAM2::MapPoint *> getCurrentMap() { return SLAM->GetMap()->GetAllMapPoints(); };
-/**
- * @brief Executes a specific command for controlling the virtual robot in the simulation, NOTICE: the available commands are in the commandMap object .
- *
- * @param command A string specifying the command to be executed.
- * @param intervalUsleep Optional parameter setting the sleep interval between command execution in microseconds. Default is 50000 microseconds.
- * @param fps Optional parameter defining the frames per second rate for visualization. Default is 30.0.
- * @param totalCommandTimeInSeconds Optional parameter setting the total duration for the command execution in seconds. Default is 1 second.
- *
- * This method enables the users to navigate the virtual robot in the simulation by executing specific commands.
- */
-    void command(std::string &command, int intervalUsleep = 50000,
-                 double fps = 30.0,
-                 int totalCommandTimeInSeconds = 1);
-/**
- * @brief kills the run thread
- *
- */
-    void stop() { stopFlag = true; }
-/**
- * @brief enabling or disabling the ORBSLAM process.
- *
- */
-    void setTrack(bool value) { track = value; }
-
+   /**
+    * Constructs a Simulator instance with specified parameters, and loads the ORBSLAM2 object.
+    *
+    * @param ORBSLAMConfigFile: A string representing the path to the ORBSLAM2 configuration file, an example can be found in the "config" folder in the project.
+    *
+    * @param model_path: A string representing the path to the 3D blender model used for simulation.
+    *
+    * @param modelTextureNameToAlignTo: A string representing the texture name used for alignment in the 3D model.
+    *
+    * @param saveMap: A boolean to determine whether the generated SLAM map should be saved or not. Defaults to false if not specified.
+    *
+    * @param simulatorOutputDirPath: A string representing the output directory for saving SLAM maps. Defaults to "../slamMaps/" if not specified.
+    *
+    * @param loadMap: A boolean to determine whether to load a previously saved SLAM map. Defaults to false if not specified.
+    *
+    * @param mapLoadPath: A string representing the path to a previously saved SLAM map to load. Defaults to "../slamMaps/example.bin" if not specified.
+    *
+    * @param movementFactor: A double value representing the movement speed in the simulator. Defaults to 0.01 if not specified.
+    *
+    * @param vocPath: A string representing the path to the ORBSLAM2 vocabulary file. Defaults to "../Vocabulary/ORBvoc.txt" if not specified.
+    */
+   Simulator(std::string ORBSLAMConfigFile, std::string model_path, std::string modelTextureNameToAlignTo, bool trackImages = true,
+             bool saveMap = false, std::string simulatorOutputDirPath = "../slamMaps/", bool loadMap = false,
+             std::string mapLoadPath = "../slamMaps/example.bin",
+             double movementFactor = 0.01,
+             std::string vocPath = "../Vocabulary/ORBvoc.txt");
+
+   /**
+    *Starts the 3D model viewer (pangolin), and wait for the user or code signal to start sending the view to the ORBSLAM2 object
+    * */
+   std::thread run();
+   /**
+    * sample the simulator state, this changes from false to true once the model is loaded
+    * @return is the simulator is ready
+    * */
+   bool isReady() { return ready; }
+
+   /**
+    * @brief Fetches the current location matrix from ORBSLAM2.
+    *
+    * @return A 4x4 location matrix where:
+    * - The first 3x3 sub-matrix represents the rotation matrix.
+    * - The last column represents the translation vector.
+    * - The y-axis indicates the height in reverse (i.e., negative values correspond to upward direction).
+    */
+   cv::Mat getCurrentLocation();
+   /**
+    * @brief Retrieves the current map from ORBSLAM2.
+    *
+    * @return A vector of pointers to ORB_SLAM2::MapPoint objects.
+    */
+   std::vector<ORB_SLAM2::MapPoint *> getCurrentMap() { return SLAM->GetMap()->GetAllMapPoints(); };
+   /**
+    * @brief Executes a specific command for controlling the virtual robot in the simulation, NOTICE: the available commands are in the commandMap object .
+    *
+    * @param command A string specifying the command to be executed.
+    * @param intervalUsleep Optional parameter setting the sleep interval between command execution in microseconds. Default is 50000 microseconds.
+    * @param fps Optional parameter defining the frames per second rate for visualization. Default is 30.0.
+    * @param totalCommandTimeInSeconds Optional parameter setting the total duration for the command execution in seconds. Default is 1 second.
+    *
+    * This method enables the users to navigate the virtual robot in the simulation by executing specific commands.
+    */
+   void command(std::string &command, int intervalUsleep = 50,
+                double fps = 30.0,
+                int totalCommandTimeInSeconds = 1);
+   /**
+    * @brief kills the run thread
+    *
+    */
+   void stop() { stopFlag = true; }
+   /**
+    * @brief enabling or disabling the ORBSLAM process.
+    *
+    */
+   void setTrack(bool value) { track = value; }
+ void simulatorRunThread();
 private:
-    /**
- * @brief A map for controlling the virtual robot's actions.
- *
- * This property is an unordered map where:
- * - The key is a string representing a command for the virtual robot.
- * - The value is a boolean indicating whether the command is executable (true) or not (false).
- */
-    std::unordered_map<std::string, bool> commandMap = {
-            {"cw",      true},
-            {"ccw",     true},
-            {"forward", true},
-            {"back",    true},
-            {"right",   true},
-            {"up",      true},
-            {"down",    true},
-            {"left",    true},
-            {"flip",    false},
-            {"rc",      false}};
-    std::shared_ptr<ORB_SLAM2::System> SLAM;
-    pangolin::OpenGlRenderState s_cam;
-    Eigen::Matrix3d K;
-    ORB_SLAM2::ORBextractor *orbExtractor;
-    std::string simulatorOutputDir;
-    bool stopFlag;
-    bool ready;
-
-    bool saveMapSignal;
-    bool track;
-    double movementFactor{};
-    std::string modelPath;
-    std::string modelTextureNameToAlignTo;
-    std::vector<Eigen::Vector3d> Picks_w;
-    bool isSaveMap;
-    bool trackImages;
-    bool cull_backfaces;
-    pangolin::GlSlProgram program;
-    pangolin::GlGeometry geomToRender;
-    Eigen::Vector2i viewportDesiredSize;
-    cv::Mat Tcw;
-    std::mutex locationLock;
-
-    void simulatorRunThread();
-
-    void extractSurface(const pangolin::Geometry &modelGeometry, std::string modelTextureNameToAlignTo,
-                        Eigen::MatrixXf &surface);
-
-    void alignModelViewPointToSurface(const pangolin::Geometry &modelGeometry, std::string modelTextureNameToAlignTo);
-
-    void saveMap(std::string prefix = "");
-
-    void intervalOverCommand(const std::function<void(pangolin::OpenGlRenderState &, double &)> &func,
-                             double value, int intervalUsleep,
-                             double fps,
-                             int totalCommandTimeInSeconds);
-
-    void
-    applyCommand(std::string &command, double value,
-                 int intervalUsleep,
-                 double fps,
-                 int totalCommandTimeInSeconds);
-
-    void static applyForwardToModelCam(pangolin::OpenGlRenderState &cam, double value);
-
-    void static applyRightToModelCam(pangolin::OpenGlRenderState &cam, double value);
-
-    void static applyYawRotationToModelCam(pangolin::OpenGlRenderState &cam, double value);
-
-    void static applyUpModelCam(pangolin::OpenGlRenderState &cam, double value);
-
-    void static applyPitchRotationToModelCam(pangolin::OpenGlRenderState &cam, double value);
+   /**
+    * @brief A map for controlling the virtual robot's actions.
+    *
+    * This property is an unordered map where:
+    * - The key is a string representing a command for the virtual robot.
+    * - The value is a boolean indicating whether the command is executable (true) or not (false).
+    */
+   std::unordered_map<std::string, bool> commandMap = {
+       {"cw", true},
+       {"ccw", true},
+       {"forward", true},
+       {"back", true},
+       {"right", true},
+       {"up", true},
+       {"down", true},
+       {"left", true},
+       {"flip", false},
+       {"rc", false}};
+   std::shared_ptr<ORB_SLAM2::System> SLAM;
+   pangolin::OpenGlRenderState s_cam;
+   Eigen::Matrix3d K;
+   std::shared_ptr < ORB_SLAM2::ORBextractor> orbExtractor;
+   std::string simulatorOutputDir;
+   bool stopFlag;
+   bool ready;
+
+   bool saveMapSignal;
+   bool track;
+   double movementFactor{};
+   std::string modelPath;
+   std::string modelTextureNameToAlignTo;
+   std::vector<Eigen::Vector3d> Picks_w;
+   bool isSaveMap;
+   bool trackImages;
+   bool cull_backfaces;
+   pangolin::GlSlProgram program;
+   pangolin::GlGeometry geomToRender;
+   Eigen::Vector2i viewportDesiredSize;
+   cv::Mat Tcw;
+   std::mutex locationLock;
+
+  
+
+   void extractSurface(const pangolin::Geometry &modelGeometry, std::string modelTextureNameToAlignTo,
+                       Eigen::MatrixXf &surface);
+
+   void alignModelViewPointToSurface(const pangolin::Geometry &modelGeometry, std::string modelTextureNameToAlignTo);
+
+   void saveMap(std::string prefix = "");
+
+   void intervalOverCommand(const std::function<void(pangolin::OpenGlRenderState &, double &)> &func,
+                            double value, int intervalUsleep,
+                            double fps,
+                            int totalCommandTimeInSeconds);
+
+   void
+   applyCommand(std::string &command, double value,
+                int intervalUsleep,
+                double fps,
+                int totalCommandTimeInSeconds);
+
+   void static applyForwardToModelCam(pangolin::OpenGlRenderState &cam, double value);
+
+   void static applyRightToModelCam(pangolin::OpenGlRenderState &cam, double value);
+
+   void static applyYawRotationToModelCam(pangolin::OpenGlRenderState &cam, double value);
+
+   void static applyUpModelCam(pangolin::OpenGlRenderState &cam, double value);
+
+   void static applyPitchRotationToModelCam(pangolin::OpenGlRenderState &cam, double value);
 };
 
-
-#endif //ORB_SLAM2_SIMULATOR_H
+#endif // ORB_SLAM2_SIMULATOR_H
diff --git a/utils/include/Auxiliary.h b/utils/include/Auxiliary.h
index 92b58db..6354295 100644
--- a/utils/include/Auxiliary.h
+++ b/utils/include/Auxiliary.h
@@ -9,30 +9,32 @@
 #include <vector>
 #include <limits>
 #include <fstream>
-#include <unistd.h>
+#define NOMINMAX
+#include <windows.h>
 #include <signal.h>
 #include <filesystem>
 #include <opencv2/core.hpp>
-#include <eigen3/Eigen/Core>
+#include <Eigen/Core>
 #include <nlohmann/json.hpp>
-#include <eigen3/Eigen/Eigen>
+#include <Eigen/Eigen>
 #include <opencv2/opencv.hpp>
 #include <opencv2/calib3d.hpp>
 #include <pangolin/pangolin.h>
-#include <eigen3/Eigen/Geometry>
+#include <Eigen/Geometry>
 #include <pangolin/scene/axis.h>
 #include <pangolin/scene/scenehandler.h>
 
 #include "Point.h"
 #include "Line.h"
 
-class Auxiliary {
+class Auxiliary
+{
 public:
     static std::string GetGeneralSettingsPath();
 
     static double det(const Point &point1, const Point &point2);
-    
-    static bool isPointVisible(const cv::Point3f& point, const cv::Point3f& cameraPos, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree);
+
+    static bool isPointVisible(const cv::Point3f &point, const cv::Point3f &cameraPos, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree);
 
     static void getPoints(std::string csvPath, std::vector<cv::Point3f> *points, const cv::Point3f &camera_position, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree);
 
@@ -42,8 +44,8 @@ public:
 
     static std::vector<std::string> GetAllFrameDatas();
 
-    static std::vector<std::string> GetFrameDatas(double amount=1); // Between 0 to 1
+    static std::vector<std::string> GetFrameDatas(double amount = 1); // Between 0 to 1
 
-    static void add_unique_points(std::vector<cv::Point3d>& target, const std::vector<cv::Point3d>& source);
+    static void add_unique_points(std::vector<cv::Point3d> &target, const std::vector<cv::Point3d> &source);
 };
-#endif //ORB_SLAM2_AUXILIARY_H
+#endif // ORB_SLAM2_AUXILIARY_H
diff --git a/utils/src/Auxiliary.cpp b/utils/src/Auxiliary.cpp
index 38a7e0b..ab98d1b 100644
--- a/utils/src/Auxiliary.cpp
+++ b/utils/src/Auxiliary.cpp
@@ -4,19 +4,20 @@
 
 #include "include/Auxiliary.h"
 
-double Auxiliary::det(const Point &point1, const Point &point2) {
+double Auxiliary::det(const Point &point1, const Point &point2)
+{
     return point1.x * point2.y - point1.y * point2.x;
 }
 
-std::string Auxiliary::GetGeneralSettingsPath() {
-    char currentDirPath[256];
-    getcwd(currentDirPath, 256);
-    std::string settingPath = currentDirPath;
+std::string Auxiliary::GetGeneralSettingsPath()
+{
+    std::filesystem::path currentDirPath = std::filesystem::current_path();
+    std::string settingPath = currentDirPath.string();
     settingPath += "/../generalSettings.json";
     return settingPath;
 }
 
-bool Auxiliary::isPointVisible(const cv::Point3f& point, const cv::Point3f& cameraPos, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree)
+bool Auxiliary::isPointVisible(const cv::Point3f &point, const cv::Point3f &cameraPos, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree)
 {
     // Define the position and orientation of the camera
     double roll_rad = roll_degree * CV_PI / 180.0;
@@ -29,9 +30,9 @@ bool Auxiliary::isPointVisible(const cv::Point3f& point, const cv::Point3f& came
     cv::Mat tvec = (cv::Mat_<double>(3, 1) << cameraPos.x, cameraPos.y, cameraPos.z);
 
     cv::Mat camera_matrix = (cv::Mat_<float>(3, 3) << fx, 0, cx,
-                                                      0, fy, cy,
-                                                      0, 0, 1);
-    cv::Mat distCoeffs = (cv::Mat_<double>(5,1) << k1, k2, p1, p2, k3);
+                             0, fy, cy,
+                             0, 0, 1);
+    cv::Mat distCoeffs = (cv::Mat_<double>(5, 1) << k1, k2, p1, p2, k3);
 
     // Project the 3D point onto the image plane
     std::vector<cv::Point3f> points = {point};
@@ -48,33 +49,38 @@ bool Auxiliary::isPointVisible(const cv::Point3f& point, const cv::Point3f& came
     return false;
 }
 
-void Auxiliary::getPoints(std::string csvPath, std::vector<cv::Point3f> *points, const cv::Point3f &camera_position, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree) {
+void Auxiliary::getPoints(std::string csvPath, std::vector<cv::Point3f> *points, const cv::Point3f &camera_position, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2, int width, int height, float roll_degree, float yaw_degree, float pitch_degree)
+{
     std::fstream pointData;
     pointData.open(csvPath, std::ios::in);
 
     std::vector<std::string> row;
     std::string line, word, temp;
 
-    while (!pointData.eof()) {
+    while (!pointData.eof())
+    {
         cv::Point3f pointToCompare;
 
         row.clear();
-        
+
         std::getline(pointData, line);
 
         std::stringstream words(line);
 
-        if (line == "") {
+        if (line == "")
+        {
             continue;
         }
 
-        while (std::getline(words, word, ',')) {
+        while (std::getline(words, word, ','))
+        {
             row.push_back(word);
         }
-        
+
         pointToCompare = cv::Point3f(std::stod(row[0]), std::stod(row[1]), std::stod(row[2]));
-        
-        if (Auxiliary::isPointVisible(pointToCompare, camera_position, fx, fy, cx, cy, k1, k2, k3, p1, p2, width, height, roll_degree, yaw_degree, pitch_degree)) {
+
+        if (Auxiliary::isPointVisible(pointToCompare, camera_position, fx, fy, cx, cy, k1, k2, k3, p1, p2, width, height, roll_degree, yaw_degree, pitch_degree))
+        {
             (*points).push_back(pointToCompare);
         }
     }
@@ -94,35 +100,35 @@ std::vector<cv::Point3f> Auxiliary::FilterPointsInView(std::vector<cv::Point3f>
     float cp = cos(Pitch);
     float sp = sin(Pitch);
     cv::Mat Rx = (cv::Mat_<float>(4, 4) << 1, 0, 0, 0,
-                   0, cp, -sp, 0,
-                   0, sp, cp, 0,
-                   0, 0, 0, 1);
-    
+                  0, cp, -sp, 0,
+                  0, sp, cp, 0,
+                  0, 0, 0, 1);
+
     // The rotation on the XZ-plane is the yaw
     float cy = cos(-Yaw);
     float sy = sin(-Yaw);
     cv::Mat Ry = (cv::Mat_<float>(4, 4) << cy, 0, sy, 0,
-                   0, 1, 0, 0,
-                   -sy, 0, cy, 0,
-                   0, 0, 0, 1);
-    
+                  0, 1, 0, 0,
+                  -sy, 0, cy, 0,
+                  0, 0, 0, 1);
+
     // The rotation on the XY-plane is the roll
     float cr = cos(Roll);
     float sr = sin(Roll);
     cv::Mat Rz = (cv::Mat_<float>(4, 4) << cr, -sr, 0, 0,
-                   sr, cr, 0, 0,
-                   0, 0, 1, 0,
-                   0, 0, 0, 1);
+                  sr, cr, 0, 0,
+                  0, 0, 1, 0,
+                  0, 0, 0, 1);
 
     // Matrix to represent the change to cameras axises
     float Cx = cam_pos.x;
     float Cy = cam_pos.y;
     float Cz = cam_pos.z;
     cv::Mat Tc = (cv::Mat_<float>(4, 4) << 1, 0, 0, -Cx,
-                   0, 1, 0, -Cy,
-                   0, 0, 1, -Cz,
-                   0, 0, 0, 1);
-    
+                  0, 1, 0, -Cy,
+                  0, 0, 1, -Cz,
+                  0, 0, 0, 1);
+
     // Calculate the extrinsic transformation
     cv::Mat Rt = Rz * Rx * Ry * Tc;
 
@@ -134,7 +140,7 @@ std::vector<cv::Point3f> Auxiliary::FilterPointsInView(std::vector<cv::Point3f>
     float f_height = focal[1];
     float f_width = focal[2];
     float vt = f_height / f_depth / 2;
-    float ht = f_width  / f_depth / 2;
+    float ht = f_width / f_depth / 2;
 
     // Iterate on the points, and deside which point is in the field of view
     for (cv::Point3f point : points)
@@ -144,24 +150,27 @@ std::vector<cv::Point3f> Auxiliary::FilterPointsInView(std::vector<cv::Point3f>
         float Pwy = point.y;
         float Pwz = point.z;
 
-        // Create homogeneous vector for the point 
+        // Create homogeneous vector for the point
         cv::Mat Pw = (cv::Mat_<float>(4, 1) << Pwx, Pwy, Pwz, 1);
 
         // Calculate the position relative to the camera
         cv::Mat Pc = Rt * Pw;
 
         // If the point have negative side of z-axis, its behind the camera
-        if (Pc.at<float>(2, 0) <= 0) {
+        if (Pc.at<float>(2, 0) <= 0)
+        {
             continue;
         }
 
         // Check if horizantlly, relative to the camera, the point inside the FOV
-        if (abs(Pc.at<float>(0, 0) / Pc.at<float>(2, 0)) > vt) {
+        if (abs(Pc.at<float>(0, 0) / Pc.at<float>(2, 0)) > vt)
+        {
             continue;
         }
 
         // Check if vertically, relative to the camera, the point inside the FOV
-        if (abs(Pc.at<float>(1, 0) / Pc.at<float>(2, 0)) > ht) {
+        if (abs(Pc.at<float>(1, 0) / Pc.at<float>(2, 0)) > ht)
+        {
             continue;
         }
 
@@ -169,7 +178,7 @@ std::vector<cv::Point3f> Auxiliary::FilterPointsInView(std::vector<cv::Point3f>
         // Append the point to the seen points
         SeenPoints.push_back(cv::Point3f(Pwx, Pwy, Pwz));
     }
-    
+
     return SeenPoints;
 }
 
@@ -187,10 +196,10 @@ std::vector<cv::Point3d> Auxiliary::getPointsFromPos(const std::string cloud_poi
 
     // Check settings file
     cv::FileStorage fsSettings(data["DroneYamlPathSlam"], cv::FileStorage::READ);
-    if(!fsSettings.isOpened())
+    if (!fsSettings.isOpened())
     {
-       std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
-       exit(-1);
+        std::cerr << "Failed to open settings file at: " << data["DroneYamlPathSlam"] << std::endl;
+        exit(-1);
     }
 
     double fx = fsSettings["Camera.fx"];
@@ -206,44 +215,50 @@ std::vector<cv::Point3d> Auxiliary::getPointsFromPos(const std::string cloud_poi
     double maxY = height;
 
     Eigen::Matrix4d Tcw_eigen = Eigen::Matrix4d::Identity();
-    Tcw_eigen.block<3, 3>(0, 0) = (Eigen::AngleAxisd(-roll, Eigen::Vector3d::UnitZ()) * 
-                             Eigen::AngleAxisd(-yaw, Eigen::Vector3d::UnitY()) *
-                             Eigen::AngleAxisd(-pitch, Eigen::Vector3d::UnitX())).toRotationMatrix();
+    Tcw_eigen.block<3, 3>(0, 0) = (Eigen::AngleAxisd(-roll, Eigen::Vector3d::UnitZ()) *
+                                   Eigen::AngleAxisd(-yaw, Eigen::Vector3d::UnitY()) *
+                                   Eigen::AngleAxisd(-pitch, Eigen::Vector3d::UnitX()))
+                                      .toRotationMatrix();
     Tcw_eigen.block<3, 1>(0, 3) << -camera_position.x, camera_position.y, -camera_position.z;
 
     cv::Mat Tcw = cv::Mat::eye(4, 4, CV_64FC1);
-    for(int i=0;i<4;i++){
-        for(int j=0;j<4;j++){
-            Tcw.at<double>(i,j) = Tcw_eigen(i,j);
+    for (int i = 0; i < 4; i++)
+    {
+        for (int j = 0; j < 4; j++)
+        {
+            Tcw.at<double>(i, j) = Tcw_eigen(i, j);
         }
     }
 
-    cv::Mat Rcw = Tcw.rowRange(0,3).colRange(0,3);
+    cv::Mat Rcw = Tcw.rowRange(0, 3).colRange(0, 3);
     cv::Mat Rwc = Rcw.t();
-    cv::Mat tcw = Tcw.rowRange(0,3).col(3);
-    cv::Mat mOw = -Rcw.t()*tcw;
+    cv::Mat tcw = Tcw.rowRange(0, 3).col(3);
+    cv::Mat mOw = -Rcw.t() * tcw;
 
     /* Create Matrix for s_cam */
     Eigen::Matrix4d tmp_Tcw_eigen = Eigen::Matrix4d::Identity();
-    tmp_Tcw_eigen.block<3, 3>(0, 0) = (Eigen::AngleAxisd(roll, Eigen::Vector3d::UnitZ()) * 
-                             Eigen::AngleAxisd(yaw, Eigen::Vector3d::UnitY()) *
-                             Eigen::AngleAxisd(pitch, Eigen::Vector3d::UnitX())).toRotationMatrix();
+    tmp_Tcw_eigen.block<3, 3>(0, 0) = (Eigen::AngleAxisd(roll, Eigen::Vector3d::UnitZ()) *
+                                       Eigen::AngleAxisd(yaw, Eigen::Vector3d::UnitY()) *
+                                       Eigen::AngleAxisd(pitch, Eigen::Vector3d::UnitX()))
+                                          .toRotationMatrix();
     tmp_Tcw_eigen.block<3, 1>(0, 3) << camera_position.x, camera_position.y, camera_position.z;
 
     cv::Mat tmpTcw = cv::Mat::eye(4, 4, CV_64FC1);
-    for(int i=0;i<4;i++){
-        for(int j=0;j<4;j++){
-            tmpTcw.at<double>(i,j) = tmp_Tcw_eigen(i,j);
+    for (int i = 0; i < 4; i++)
+    {
+        for (int j = 0; j < 4; j++)
+        {
+            tmpTcw.at<double>(i, j) = tmp_Tcw_eigen(i, j);
         }
     }
 
-    cv::Mat tmpRcw = tmpTcw.rowRange(0,3).colRange(0,3);
+    cv::Mat tmpRcw = tmpTcw.rowRange(0, 3).colRange(0, 3);
     cv::Mat tmpRwc = tmpRcw.t();
-    cv::Mat tmptcw = tmpTcw.rowRange(0,3).col(3);
-    cv::Mat tmpMOw = -tmpRcw.t()*tmptcw;
+    cv::Mat tmptcw = tmpTcw.rowRange(0, 3).col(3);
+    cv::Mat tmpMOw = -tmpRcw.t() * tmptcw;
 
-    Twc = cv::Mat::eye(4,4,tmpTcw.type());
-    tmpRwc.copyTo(Twc.rowRange(0,3).colRange(0,3));
+    Twc = cv::Mat::eye(4, 4, tmpTcw.type());
+    tmpRwc.copyTo(Twc.rowRange(0, 3).colRange(0, 3));
     Twc.at<double>(12) = mOw.at<double>(0);
     Twc.at<double>(13) = mOw.at<double>(1);
     Twc.at<double>(14) = mOw.at<double>(2);
@@ -254,23 +269,26 @@ std::vector<cv::Point3d> Auxiliary::getPointsFromPos(const std::string cloud_poi
 
     pointData.open(cloud_points, std::ios::in);
 
-    while (!pointData.eof()) {
+    while (!pointData.eof())
+    {
         row.clear();
-        
+
         std::getline(pointData, line);
 
         std::stringstream words(line);
 
-        if (line == "") {
+        if (line == "")
+        {
             continue;
         }
 
-        while (std::getline(words, word, ',')) {
-            try 
+        while (std::getline(words, word, ','))
+        {
+            try
             {
                 std::stod(word);
-            } 
-            catch(std::out_of_range)
+            }
+            catch (std::out_of_range)
             {
                 word = "0";
             }
@@ -282,39 +300,39 @@ std::vector<cv::Point3d> Auxiliary::getPointsFromPos(const std::string cloud_poi
 
     std::vector<cv::Point3d> seen_points;
 
-    for(cv::Vec<double, 8>  point : points)
+    for (cv::Vec<double, 8> point : points)
     {
         cv::Mat worldPos = cv::Mat::zeros(3, 1, CV_64F);
         worldPos.at<double>(0) = point[0];
         worldPos.at<double>(1) = point[1];
         worldPos.at<double>(2) = point[2];
 
-        const cv::Mat Pc = Rcw*worldPos+tcw;
+        const cv::Mat Pc = Rcw * worldPos + tcw;
         const double &PcX = Pc.at<double>(0);
-        const double &PcY= Pc.at<double>(1);
+        const double &PcY = Pc.at<double>(1);
         const double &PcZ = Pc.at<double>(2);
 
         // Check positive depth
-        if(PcZ<0.0f)
+        if (PcZ < 0.0f)
             continue;
 
         // Project in image and check it is not outside
-        const double invz = 1.0f/PcZ;
-        const double u=fx*PcX*invz+cx;
-        const double v=fy*PcY*invz+cy;
+        const double invz = 1.0f / PcZ;
+        const double u = fx * PcX * invz + cx;
+        const double v = fy * PcY * invz + cy;
 
-        if(u<minX || u>maxX)
+        if (u < minX || u > maxX)
             continue;
-        if(v<minY || v>maxY)
+        if (v < minY || v > maxY)
             continue;
 
         // Check distance is in the scale invariance region of the MapPoint
         const double minDistance = point[3];
         const double maxDistance = point[4];
-        const cv::Mat PO = worldPos-mOw;
+        const cv::Mat PO = worldPos - mOw;
         const double dist = cv::norm(PO);
 
-        if(dist<minDistance || dist>maxDistance)
+        if (dist < minDistance || dist > maxDistance)
             continue;
 
         // Check viewing angle
@@ -323,9 +341,9 @@ std::vector<cv::Point3d> Auxiliary::getPointsFromPos(const std::string cloud_poi
         Pn.at<double>(1) = point[6];
         Pn.at<double>(2) = point[7];
 
-        const double viewCos = PO.dot(Pn)/dist;
+        const double viewCos = PO.dot(Pn) / dist;
 
-        if(viewCos<0.5)
+        if (viewCos < 0.5)
             continue;
 
         seen_points.push_back(cv::Point3d(worldPos.at<double>(0), worldPos.at<double>(1), worldPos.at<double>(2)));
@@ -346,7 +364,7 @@ std::vector<std::string> Auxiliary::GetAllFrameDatas()
 
     std::vector<std::string> filepaths;
 
-    for (const auto& entry : std::filesystem::directory_iterator(map_input_dir))
+    for (const auto &entry : std::filesystem::directory_iterator(map_input_dir))
     {
         const std::string filename = entry.path().filename().string();
         const int n = std::sscanf(filename.c_str(), "frameData%d.csv", &n);
@@ -388,11 +406,14 @@ std::vector<std::string> Auxiliary::GetFrameDatas(double amount)
     return output;
 }
 
-void Auxiliary::add_unique_points(std::vector<cv::Point3d>& target, const std::vector<cv::Point3d>& source) {
-    for (const cv::Point3d& point : source) {
+void Auxiliary::add_unique_points(std::vector<cv::Point3d> &target, const std::vector<cv::Point3d> &source)
+{
+    for (const cv::Point3d &point : source)
+    {
         // check if the point exists in the target vector
         auto it = std::find(target.begin(), target.end(), point);
-        if (it == target.end()) {
+        if (it == target.end())
+        {
             // point does not exist in target, so add it
             target.push_back(point);
         }
diff --git a/vcpkg.json b/vcpkg.json
new file mode 100644
index 0000000..d8cd389
--- /dev/null
+++ b/vcpkg.json
@@ -0,0 +1,27 @@
+{
+    "name": "simulator-mapping",
+    "version": "1",
+    "builtin-baseline": "b619a233fbf7b2c9765fb4458f3ecb05bd3166e3",
+  "dependencies": [
+    "nlohmann-json",
+    "opencv3",
+    "lz4",
+    "libjpeg-turbo",
+    "libpng",
+    "catch2",
+    "opengl",
+    "openexr",
+    "tiff",
+    "zstd",
+    "eigen3",
+    "glew",
+    "boost",
+    "boost-serialization",
+    "suitesparse",
+    "qt5",
+    "lapack-reference",
+    "ceres",
+    "openblas",
+    "ffmpeg"
+  ]
+  }
\ No newline at end of file
